# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of CO𝘕CEPT can be contacted at
# jeppe.mosgaard.dakin(at)post.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# This is the makefile for the CO𝘕CEPT code. Preferebly you should not
# interact with this file directly, but rather use the concept script to
# build and run the code.

# Use the bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles = analysis commons communication ewald graphics gravity integration main mesh snapshot species utilities
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# List of files generated in the concept directory by running the code, which should be deleted by distclean
files_auxiliary = jobscript .ewald_gridsize* .fftw_wisdom_gridsize*
# List of files in the utilities directory generated by using the utilities
files_utilities = powerspec.params.full render.params.full update_new



################################################
# Environment information from the .paths file #
################################################
# Get the path to the .paths file
paths = $(shell this_dir="$$( cd "$$( dirname "$${BASH_SOURCE[0]}" )" && pwd )"; \
          curr="$${this_dir}"; \
          while :; do \
              if [ -f "$${curr}/.paths" ]; then \
                  paths="$${curr}/.paths"; \
                  break; \
              fi; \
              if [ "$${curr}" == "/" ]; then \
                  paths='fail'; \
                  break; \
              fi; \
              curr="`dirname \"$${curr}\"`"; \
          done; \
          echo "$${paths}")
ifeq ($(paths), fail)
    $(error Could not find the .paths file)
endif
# Source the .paths file for paths.
# Make some paths relative to this makefile (concept_dir), reducing screen clutter when making
concept_dir       = $(shell source $(paths); echo $${concept_dir})
fftw_dir          = $(shell source $(paths); echo $${fftw_dir})
gsl_dir           = $(shell source $(paths); echo $${gsl_dir})
logs_dir_abs      = $(shell source $(paths); echo $${logs_dir})
logs_dir          = $(shell ${python} -c "from os.path import relpath; print(relpath('${logs_dir_abs}', '${concept_dir}'))")
mpi_dir           = $(shell source $(paths); echo $${mpi_dir})
output_dir_abs    = $(shell source $(paths); echo $${output_dir})
output_dir        = $(shell ${python} -c "from os.path import relpath; print(relpath('${output_dir_abs}', '${concept_dir}'))")
python_dir        = $(shell source $(paths); echo $${python_dir})
tests_dir_abs     = $(shell source $(paths); echo $${tests_dir})
tests_dir         = $(shell ${python} -c "from os.path import relpath; print(relpath('${tests_dir_abs}', '${concept_dir}'))")
top_dir_abs       = $(shell source $(paths); echo $${top_dir})
top_dir           = $(shell ${python} -c "from os.path import relpath; print(relpath('${top_dir_abs}', '${concept_dir}'))")
utilities_dir_abs = $(shell source $(paths); echo $${utilities_dir})
utilities_dir     = $(shell ${python} -c "from os.path import relpath; print(relpath('${utilities_dir_abs}', '${concept_dir}'))")
mpicc_abs         = $(shell source $(paths); echo $${mpicc})
mpicc             = $(shell ${python} -c "from os.path import relpath; print(relpath('${mpicc_abs}', '${concept_dir}'))")
python_abs        = $(shell source $(paths); echo $${python})
python            = $(shell ${python_abs} -c "from os.path import relpath; print(relpath('${python_abs}', '${concept_dir}'))")
python_config     = $(shell source $(paths); echo $${python_config})



########################################
# Settings for compilation and linking #
########################################
# Options passed when cythonizing .pyx files
cythonflags = -3 -a
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_dir)/include
python_incl = $(shell $(python_config) --includes)
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC                = $(mpicc)
python_cflags     = $(shell $(python_config) --cflags)
unwanted_warnings = unreachable-code uninitialized
other_cflags      = -pthread -std=c99 -fno-strict-aliasing -fPIC -Wextra $(addprefix -Wno-,$(unwanted_warnings))
CFLAGS_abs        = $(filter-out $(addprefix -W,$(unwanted_warnings)),$(python_cflags) $(other_cflags) $(includes))
# Libraries to link
fftw_libs   = -L$(fftw_dir)/lib -Wl,"-rpath=$(fftw_dir)/lib" -lfftw3_mpi -lfftw3
gsl_libs    = -L$(gsl_dir)/lib -Wl,"-rpath=$(gsl_dir)/lib" -lgsl -lgslcblas -lm
mpi_libs    = -L$(mpi_dir)/lib -Wl,"-rpath=$(mpi_dir)/lib" -lmpi
python_libs = -L$(python_dir)/lib -Wl,"-rpath=$(python_dir)/lib" $(shell $(python_config) --libs)
LDLIBS_abs  = $(fftw_libs) $(gsl_libs) $(mpi_libs) $(python_libs)
# Linker options
python_ldflags = $(shell $(python_config) --ldflags)
other_ldflags  = -shared
LDFLAGS_abs    = $(python_ldflags) $(other_ldflags)
# Reduce screen clutter when making by using relative paths and removing duplicate linker options
CFLAGS  = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${CFLAGS_abs}';\
                                words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                         if word.startswith('-I') or word.startswith('-L')\
                                         else word for word in line.split(' ') if word];\
                                words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                         if word.startswith('-Wl,-rpath=') else word for word in words];\
                                words = [relpath(word, '${concept_dir}')\
                                         if word.startswith('/') else word for word in words];\
                                _, indices = np.unique([word.strip() for word in words], return_index=True);\
                                words = np.array(words)[indices];\
                                [print(word) for word in words]")
LDLIBS  = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${LDLIBS_abs}';\
                               words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                        if word.startswith('-I') or word.startswith('-L')\
                                        else word for word in line.split(' ') if word];\
                               words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                        if word.startswith('-Wl,-rpath=') else word for word in words];\
                               words = [relpath(word, '${concept_dir}')\
                                        if word.startswith('/') else word for word in words];\
                               _, indices = np.unique([word.strip() for word in words], return_index=True);\
                               words = np.array(words)[indices];\
                               [print(word) for word in words]")
LDFLAGS = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${LDFLAGS_abs}';\
                                words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                         if word.startswith('-I') or word.startswith('-L')\
                                         else word for word in line.split(' ')\
                                         if (word and word not in '${LDLIBS_abs}'.split(' '))];\
                                words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                         if word.startswith('-Wl,-rpath=') else word for word in words];\
                                words = [relpath(word, '${concept_dir}')\
                                         if word.startswith('/') else word for word in words];\
                                _, indices = np.unique([word.strip() for word in words], return_index=True);\
                                words = np.array(words)[indices];\
                                [print(word) for word in words]")



###################
# Primary targets #
###################
# The below targets are responsible for the
# .py --> (.pyx --> .pxd) --> .c --> .o --> .so build chain. For each,
# module, a heading are printed at the beginning of its build process.
# The 'build_status' variable is used as a flag, controlling these
# headings.

# Make everything
all: $(addsuffix .so, $(pyfiles))
	@# This suppresses "make: Nothing to be done for `all'."
.PHONY: all

# Link object filed into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(CC) $< -o $@ $(LDFLAGS) $(LDLIBS)
	$(eval build_status = finsihed)

# Compile c source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into c source files
$(addsuffix .c, $(pyfiles)): %.c: %.pyx %.pxd
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(python) -m cython $(cythonflags) $<

# Write .pxd files from .pyx files using the pyxpp script
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx $(pyxpp)
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(python) -B $(pyxpp) $<

# Write .pyx files from .py files using the pyxpp script
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py $(pyxpp)
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(python) -B $(pyxpp) $<



###########################
# Additional dependencies #
###########################
# Add any additional target dependencies here.
# - Every cimport statement in a .pyx/.pxd leads to a dependency of the
#   form .c: imported_module.pxd
# - Implicit cimport statements occur after 'from commons import *'.
#   Also, every module except commons implicitly cimport cclasses
#   from the snapshot and species modules.
analysis.c:                   commons.pxd communication.pxd ewald.pxd       graphics.pxd                             mesh.pxd snapshot.pxd species.pxd
commons.c:
communication.c:              commons.pxd                                                                                     snapshot.pxd species.pxd
ewald.c:                      commons.pxd                                                                            mesh.pxd snapshot.pxd species.pxd
graphics.c:                   commons.pxd                                                                                     snapshot.pxd species.pxd
gravity.c:                    commons.pxd communication.pxd                                                          mesh.pxd snapshot.pxd species.pxd
integration.c:                commons.pxd                                                                                     snapshot.pxd species.pxd
main.c:          analysis.pxd commons.pxd                                   graphics.pxd             integration.pxd          snapshot.pxd species.pxd utilities.pxd
mesh.c:                       commons.pxd                             fft.c                                                   snapshot.pxd species.pxd
snapshot.c:                   commons.pxd communication.pxd                                                                                species.pxd
species.c:                    commons.pxd communication.pxd                              gravity.pxd                          snapshot.pxd
utilities.c:     analysis.pxd commons.pxd                                   graphics.pxd                                      snapshot.pxd species.pxd



###################
# Cleanup targets #
###################
.PHONY: clean clean_auxiliary clean_logs clean_output clean_tests clean_utilities distclean
# Remove all compiled files
clean:
	$(RM) $(foreach ext,pyc pyx pxd c o so so_ html,$(addsuffix .$(ext), $(pyfiles)))
	$(RM) -r __pycache__
# Remove files generated by running the program
clean_auxiliary:
	$(RM) $(files_auxiliary)
# Remove log files
clean_logs:
	$(RM) $(logs_dir)/*
# Remove output files
clean_output:
	$(RM) -r $(output_dir)/*
# Remove files produced by running tests
clean_tests:
	$(foreach clean_file,$(wildcard $(tests_dir)/*/clean),$(clean_file);)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) $(addprefix $(utilities_dir)/,$(files_utilities))
	$(RM) -r $(top_dir)/concept_backup $(top_dir)/tmp
# Remore all unnecessary files, leaving the program in a distribution ready state
distclean: clean clean_auxiliary clean_logs clean_output clean_tests clean_utilities
