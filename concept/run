#!/bin/bash

# This script runs the CONCEPT code.
# Run the script with the -h option to get help

# Absolute paths to this file an its directory
this_file=$(readlink -f "${0}")
this_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Load paths from the .paths file
curr="${this_dir}"
while [ 1 ]; do
    if [ -f "${curr}/.paths" ]; then
        source "${curr}/.paths"
        break
    fi
    if [ "${curr}" == "/" ]; then
        printf "\e[1m\e[91mCould not find the .paths file!\e[0m\n" >&2
        exit 1
    fi
    curr="`dirname \"${curr}\"`"
done

# Default values of command-line arguments
nprocs=1
params="${this_dir}/params/default"
main="${this_dir}/main.py"
pure_python=0
walltime=24

# List of remote queues and number of CPU per node. The first queue is the default queue. 
queues=(q8n q8 q4)
ppns=(8 8 4)

# Use Python's argparse module to handle command-line arguments
args=(`${python} -B -c "
import argparse
import sys
from os.path import basename, dirname
# Enables Python to write directly to screen when asked for help
if any(h in sys.argv for h in ['-h', '--he', '--hel', '--help']):
    sys.stdout = sys.stderr
# Set the filename of the script
sys.argv[0] = '${this_file}'
# Setup command-line arguments
parser = argparse.ArgumentParser(description='Run the CONCEPT code.')
parser.add_argument('-e', '--exit',
                    help='exit as soon as all auxiliary files have been created',
                    default=False,
                    action='store_true',
                    )
parser.add_argument('--local',
                    help='Force the run to be dun locally, without the use of PBS',
                    default=False,
		    action='store_true',
                    )
parser.add_argument('-m', '--main',
                    help='entry point of the code',
                    default='${main}',
                    )
parser.add_argument('-n', '--nprocs',
                    help='number of processes',
                    type=int,
                    default=${nprocs},
                    )
parser.add_argument('-p', '--params',
                    help='parameterfile to use',
                    default='${params}',
                    )
parser.add_argument('--pure-python',
                    help='run in pure Python mode',
                    default=${pure_python},
                    action='store_true',
                    )
parser.add_argument('-t', '--test',
                    help='run test TEST. TEST can be any subdirectory of the tests directory. Use TEST=all to run all tests',
                    default='none',
                    )
parser.add_argument('-q', '--queue',
                    help='Queue for submition of the remote job. If omitted the script will try to choose the best.',
                    default='none',
                    )
parser.add_argument('-w', '--walltime',
                     help='Set the PBS walltime in whole hours',
                     type=int,
                     default=${walltime},
                     )
args = parser.parse_args()
# Warnings when basic parameters are not supplied
unspecified_nprocs = False
unspecified_params = False
arg = '--nprocs'
if not any(n in sys.argv for n in ['-n'] + [arg[:i] for i in range(4, len(arg) + 1)]):
    unspecified_nprocs = True
arg = '--params'
if not any(p in sys.argv for p in ['-p'] + [arg[:i] for i in range(4, len(arg) + 1)]):
    if basename(dirname(args.main)) == 'tests':
        # Running a test but no parameterfile specified!
        args.params = dirname(args.main) + '/params_' + basename(args.main)
    else:
        unspecified_params = True
# Print out the arguments.
# These will be captured in the bash 'args' variable
print(args.nprocs,
      args.params,
      args.main,
      int(args.pure_python),
      int(unspecified_nprocs),
      int(unspecified_params),
      int(args.exit),
      args.test,
      args.walltime,
      args.queue,
      int(args.local),
      )
" "$@"`)
nprocs="${args[0]}"
params="${args[1]}"
main="${args[2]}"
pure_python="${args[3]}"
unspecified_nprocs="${args[4]}"
unspecified_params="${args[5]}"
exit="${args[6]}"
test="${args[7]}"
walltime="${args[8]}"
queue="${args[9]}"
local="${args[10]}"
if [ "${#args[@]}" -ne 11 ]; then
    exit 1
fi

# Set up error trapping
ctrl_c()
{
    trap : 0
    exit 2
}
abort()
{
    printf "\e[1m\e[91mAn error occurred!\e[0m\n" >&2
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Convert all supplied paths to absolute paths
absolute()
{
    local path="${1}"
    path="${path//[ ]/\\ }"        # Places backslashes before spaces. These are needed when expanding tilde, but they will not persist!
    eval path="${path}"            # Expand tilde
    path=$(readlink -f "${path}")  # Convert to absolute path
    echo "${path}"
} 
params="$(absolute "${params}")"
main="$(absolute "${main}")"
if [ "${test}" != "none" ] && [ "${test}" != "all" ]; then
    test="${this_dir}/tests/$(basename "${test}")"
fi

# Do the parameterfile, the main file and the test file exist?
if [ ! -f "${params}" ]; then
    echo "Error: "${params}" does not exist!"
    exit 1
fi
if [ ! -f "${main}" ]; then
    echo "Error: "${main}" does not exist!"
    exit 1
fi
if [ "${test}" != "none" ] && [ "${test}" != "all" ]; then
    if [ ! -d "${test}" ]; then
        echo "Error: "${test}" does not exist!"
        exit 1
    fi
fi

# If a test is to be run, run it and exit
if [ "${test}" != "none" ]; then
    trap : 0
    if [ "${test}" == "all" ]; then
        for dir in "${this_dir}/tests/"*/
        do
            dir=${dir%*/}
           printf "\n\e[1m\e[93mRunning $(basename ${dir}) test\e[0m\n"
           "${dir}/run_test"
        done
        printf "\e[1m\e[92mAll tests ran successfully\e[0m\n"
    else
        printf "\e[1m\e[93mRunning $(basename ${test}) test\e[0m\n"
        "${test}/run_test"
    fi
    exit 0
fi

# Print warnings for unspecified parameters
if [ "${unspecified_nprocs}" == 1 ]; then
    echo "Number of processes not specified - Will use ${nprocs}"
fi
if [ "${unspecified_params}" == 1 ]; then
    echo "Parameterfile not specified - Will use ${params}"
fi

# Compile or do cleanup from last compilation
if [ "${pure_python}" -eq 0 ] ; then
    # Compile with Cython
    (cd "${this_dir}" && make paramsfile="${params}")
else
    # Remove compiled Cython modules
    (cd "${this_dir}" && make clean_so >/dev/null)
    # Process the passed parameter file
    (cd "${this_dir}" && make params.py paramsfile="${params}")
fi

# Prompt the user for the secure shell password,
# if the live frame should be uploaded.
cd "${this_dir}"
args=(`"${python}" -B -c "
# Import parameters from the .py file rather than the .so file
import imp
params = imp.load_source('params', '${this_dir}/params.py')
vars = ('liveframe', 'remote_liveframe', 'protocol')
for var in vars:
    exec(var + ' = params.' + var)
# Other, normal imports
from getpass import getpass
import pexpect
# Ask for password, if upload is requested
password = ''
if liveframe != '' and remote_liveframe != '':
    # Get protocol authentication message
    if protocol == 'scp':
        cmd = 'scp \"${this_file}\" ' + remote_liveframe
    elif protocol == 'sftp':
        cmd = 'sftp ' + remote_liveframe
    else:
        raise Exception('Unknown protocol \"' + protocol + '\".')
    child = pexpect.spawn(cmd, timeout=10)
    msg = child.expect(['password.*', 'passphrase.*', pexpect.EOF, 'continue connecting'])
    prompt = ''
    if msg < 2:
        # Protocol asks for password or passphrase
        prompt = (child.before + child.after).decode('utf-8')
    elif msg == 3:
        # Protocol cannot authenticate host. Connect anyway
        child.sendline('yes')
        msg = child.expect(['password.*', 'passphrase.*', pexpect.EOF])
        if msg < 2:
            # Protocol asks for password or passphrase
            prompt = (child.before + child.after).decode('utf-8')
    child.terminate(force=True)
    # Prompt the user for the password/passphrase
    password = getpass('\nThe latest frame will continuously be ' + protocol + '\'ed to '
                       + remote_liveframe[(remote_liveframe.find('@') + 1):] + '\n'
                       + prompt)
# Print out the password/passphrase.
# This will be captured in the bash 'args' variable.
print(password)
" "$@"`)
password="${args[0]}"

# Create the logs dir and go to the code directory
mkdir -p "${this_dir}/logs"
cd "${this_dir}"

# Determine whether this script is run locally or remotely via ssh.
# Always treat tests as if they were run locally.
if [ "${local}" == 0 ] && [ "${test}" == "none" ] && ([ -n "${SSH_CLIENT}" ] || [ -n "${SSH_TTY}" ]); then
    remote=1
else
    remote=0
fi

# Either submit job or run it locally
if [ "${remote}" -eq 1 ]; then
    # Run remotely
    # First do some cleanup from a potentially previously killed job
    if [ $(echo "${this_dir}/"*.o[0-9]* | awk '{print $1}') != "${this_dir}/*.o[0-9]*" ]; then
        mv "${this_dir}/"*.o[0-9]* "${this_dir}/logs"
    fi
    # If no queue is explicitly chosen, use one with enough free nodes
    if [ "${queue}" == "none" ]; then
        # The first queue in the list is the default queue
        queue="${queues[0]}"
        ppn="${ppns[0]}"
        # Change to the queue that has enogh free CPUS to begin job immediately
        node_table=$(nodes)
        for i in $(eval echo "{0..${#queues[@]}}" | sed s/'\w*$'//)
        do
            free_nodes=$(echo "${node_table}" | grep -o -P "(?<= ${queues[${i}]}:).*(?= free)" | awk '{print $NF}')
            free_cpus=$(echo "$((${free_nodes} * ${ppns[${i}]}))")
            if [ "${free_cpus}" -ge "${nprocs}" ] && [ "$((${nprocs} % ${ppns[${i}]}))" -eq 0 ]; then
                queue="${queues[${i}]}"
                ppn="${ppns[${i}]}"
                break
            fi
        done
    else
        # How many CPU's does the explicitly chosen queue have per node?
        for i in $(eval echo "{0..${#queues[@]}}" | sed s/'\w*$'//)
        do
            if [ "${queue}" == "${queues[${i}]}" ]; then
                ppn="${ppns[${i}]}"
                break
            fi
        done
    fi
    # Check that the chosen queue can be run with all the nodes' cpu's in use
    if [ "$((${nprocs} % ${ppn}))" != 0 ]; then
        printf "\e[1m\e[91mJob submition refused:\nNo queue has the right amount of processors per node\e[0m\n" >&2
        exit 1
    fi
    nodes="$((${nprocs} / ${ppn}))"
    # Write a jobscript file
    echo -e "#!/bin/bash
#PBS -q ${queue}
#PBS -l nodes=${nodes}:ppn=${ppn}
#PBS -N $(whoami):CONCEPT
#PBS -l walltime=${walltime}:00:00
#PBS -m abe
#PBS -j oe
# Get the id of the current job
env | grep PBS
jobid=\"\${PBS_JOBID%.in1}\"
# Print start message
echo
if [ ${pure_python} -eq 0 ] ; then
    printf \"\e[1m\e[93mCO\e[3mN\e[0m\e[1m\e[93mCEPT submitted as job \${jobid}\e[0m\n\" > \"${this_dir}/logs/remote_\${jobid}\"
else
    printf \"\e[1m\e[93mCO\e[3mN\e[0m\e[1m\e[93mCEPT submitted as job \${jobid} in pure Python mode\e[0m\n\" > \"${this_dir}/logs/remote_\${jobid}\"
fi
echo \"Entry point:   ${main}\" >> \"${this_dir}/logs/remote_\${jobid}\"
echo \"Parameterfile: ${params}\" >> \"${this_dir}/logs/remote_\${jobid}\"
echo \"Nr. of CPUs:   ${nprocs}\" >> \"${this_dir}/logs/remote_\${jobid}\"
# Run the code. Note that password and whether to exit is passed as arguments
cd \"${this_dir}\"
\"${mpiexec}\" --prefix \"${openmpi_dir}\" \"${python}\" -B \"${main}\" \"${password}\" \"${exit}\" >> \"${this_dir}/logs/remote_\${jobid}\"
# Change the logs directory, so that the autogenerated file will be dumped there
cd \"${this_dir}/logs\"
" > "${this_dir}/jobscript"
    # Submit the remote job
    jobid=$(qsub "${this_dir}/jobscript")
    jobid="${jobid%.in1}"
    printf "\n\e[1m\e[93mSubmitting job\e[0m\n"
    echo "Job ${jobid} submitted to queue ${queue}"
    echo "You can now kill (Ctrl-C) this script without cancelling the job"
    # Call the watch script so we can follow the output of the run
    trap : 0
    "${this_dir}/watch" "${jobid}"
else
    # Run locally
    # Construct a jobid that does not conflict with the content of the logs dir
    jobid=0
    while [ 1 ]; do
        if [ ! -f "${this_dir}/logs/local_${jobid}" ]; then
            break
        fi
        ((jobid += 1))
    done
    # Print start message
    echo "" 2>&1 | tee "${this_dir}/logs/local_${jobid}"
    if [ "${pure_python}" -eq 0 ] ; then
        printf "\n\e[1m\e[93mRunning CO\e[3mN\e[0m\e[1m\e[93mCEPT\e[0m\n" 2>&1 | tee -a "${this_dir}/logs/local_${jobid}"
    else
        printf "\n\e[1m\e[93mRunning CO\e[3mN\e[0m\e[1m\e[93mCEPT in pure Python mode\e[0m\n" 2>&1 | tee -a "${this_dir}/logs/local_${jobid}"
    fi
    echo "Entry point:   ${main}" 2>&1 | tee -a "${this_dir}/logs/local_${jobid}"
    echo "Parameterfile: ${params}" 2>&1 | tee -a "${this_dir}/logs/local_${jobid}"
    echo "Nr. of CPUs:   ${nprocs}" 2>&1 | tee -a "${this_dir}/logs/local_${jobid}"
    # Run the code. Note that password and whether to exit is passed as arguments
    "${mpiexec}" -n "${nprocs}" --prefix "${openmpi_dir}" "${python}" -B "${main}" "${password}" "${exit}" 2>&1 | tee -a "${this_dir}/logs/local_${jobid}"
    # Run complete. Deactivate trap before exiting.
    trap : 0
fi


