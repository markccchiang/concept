# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015-2016 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of CO𝘕CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# This is the makefile for the CO𝘕CEPT code. Preferebly you should not
# interact with this file directly, but rather use the concept script to
# build and run the code.

# Use the bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles = analysis      \
          commons       \
          communication \
          ewald         \
          graphics      \
          gravity       \
          integration   \
          main          \
          mesh          \
          snapshot      \
          species       \
          utilities
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# List of files generated in the concept directory by running the code,
# which should be deleted by distclean.
files_auxiliary = jobscript .ewald_gridsize* .fftw_wisdom_gridsize*
# List of files in the utilities directory
# generated by using the utilities.
files_utilities = powerspec.params.full render.params.full update_new



################################################
# Environment information from the .paths file #
################################################
# Get the path to the .paths file
paths_filename = $(shell this_dir="$$( cd "$$( dirname "$${BASH_SOURCE[0]}" )" && pwd )"; \
				         path="$${this_dir}";                                             \
				         while :; do                                                      \
				             if [ -f "$${path}/.paths" ]; then                            \
				                 paths_filename="$${path}/.paths";                        \
				                 break;                                                   \
				             fi;                                                          \
				             if [ "$${path}" == "/" ]; then                               \
				                 paths_filename='fail';                                   \
				                 break;                                                   \
				             fi;                                                          \
				             path="$$(dirname "$${path}")";                               \
				         done;                                                            \
				         echo "$${paths_filename}")
ifeq ($(paths_filename), fail)
    $(error Could not find the .paths file)
endif
# Include (absolute) paths from the .paths file
include $(paths_filename)
# Function which takes in a quoted argument. If this argument is
# a path (perhaps prefixed with e.g. -I) and it is located near this
# Makefile, the return value is the relative path. Otherwise, the
# return value is just the untouched argment.
sensible_path = $(shell $(python) -c "import os;\
                                      path = $1;\
                                      prefix = ([''] + [prefix for prefix in \
                                                       ('-I', '-L', '-Wl,-rpath=')\
                                                       if path.startswith(prefix)])[-1];\
                                      abspath = path[len(prefix):];\
                                      relpath = os.path.relpath(abspath, '.');\
                                      path = abspath if relpath.startswith('../../') else relpath;\
                                      path = prefix + path;\
                                      print(path)")
# Transform all the included paths to sensible paths
# to reduce screen clutter when making.
paths = $(shell grep -o '.*=' $(paths_filename) | sed 's/.$$//')
$(foreach path,$(paths),$(eval $(path)=$(call sensible_path,$($(path)))))



########################################
# Settings for compilation and linking #
########################################
# Options passed when cythonizing .pyx files
python_version_major = $(shell $(python) -c "import sys; print(sys.version_info.major)")
cythonflags = -$(python_version_major) -a
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_dir)/include
python_incl = $(foreach flag,$(shell $(python_config) --includes), \
                             $(call sensible_path,'$(flag)'))
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC                = $(mpicc)
python_cflags     = $(foreach flag,$(shell $(python_config) --cflags), \
                                   $(call sensible_path,'$(flag)'))
unwanted_warnings = unreachable-code uninitialized
other_cflags      = -pthread             \
                    -std=c99             \
                    -fno-strict-aliasing \
                    -fPIC                \
                    -Wextra              \
                    $(addprefix -Wno-,$(unwanted_warnings))
CFLAGS            = $(filter-out $(addprefix -W,$(unwanted_warnings)),$(python_cflags) \
                                                                      $(other_cflags)  \
                                                                      $(includes))
# Libraries to link
fftw_libs   = -L$(fftw_dir)/lib -Wl,"-rpath=$(fftw_dir)/lib" -lfftw3_mpi -lfftw3
gsl_libs    = -L$(gsl_dir)/lib -Wl,"-rpath=$(gsl_dir)/lib" -lgsl -lgslcblas -lm
mpi_libs    = -L$(mpi_dir)/lib -Wl,"-rpath=$(mpi_dir)/lib" -lmpi
python_libs = -L$(python_dir)/lib -Wl,"-rpath=$(python_dir)/lib" $(shell $(python_config) --libs)
LDLIBS      = $(fftw_libs) $(gsl_libs) $(mpi_libs) $(python_libs)
# Linker options
python_ldflags = $(foreach flag,$(shell $(python_config) --ldflags), \
                                $(call sensible_path,'$(flag)'))
other_ldflags  = -shared
LDFLAGS        = $(python_ldflags) $(other_ldflags)



###################
# Primary targets #
###################
# The below recipes are responsible for the
# .py --> (.pyx --> .pxd) --> (.c + .html) --> .o --> .so build chain.
# For each module, a heading are printed at the beginning of its
# build process. The 'build_status' variable is used as a flag,
# controlling these headings.
define heading
$(python) -c "from blessings import Terminal;                              \
              t = Terminal(force_styling=True);                            \
              print(('\n' if '$(build_status)' else '')                    \
                    + t.bold_yellow('Building the $(basename $@) module')) \
              if '$(build_status)' != 'running' else None"
endef

# Make everything
all: $(addsuffix .so, $(pyfiles))
	@# This suppresses "make: Nothing to be done for `all'."
.PHONY: all

# Link object filed into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	@$(call heading)
	$(CC) $< -o $@ $(LDFLAGS) $(LDLIBS)
	$(eval build_status = finsihed)

# Compile c source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	@$(call heading)
	$(eval build_status = running)
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into C source files
# (and also produce the annotated .html file).
$(addsuffix .c, $(pyfiles)): %.c: %.pyx %.pxd
	@$(call heading)
	$(eval build_status = running)
	$(python) -m cython $(cythonflags) $<
# Same as above (for explicit builds of html)
$(addsuffix .html, $(pyfiles)): %.html: %.pyx %.pxd
	$(python) -m cython $(cythonflags) $<

# Write .pxd files from .pyx files using the pyxpp script
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx $(pyxpp)
	@$(call heading)
	$(eval build_status = running)
	$(python) -B $(pyxpp) $<

# Write .pyx files from .py files using the pyxpp script
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py $(pyxpp) $(MAKEFILE_LIST)
	@$(call heading)
	$(eval build_status = running)
	$(python) -B $(pyxpp) $<



###########################
# Additional dependencies #
###########################
# Add any additional target dependencies here.
# - Every cimport statement in a .pyx/.pxd leads to a dependency of the
#   form .c: imported_module.pxd
# - Implicit cimport statements occur after 'from commons import *'.
#   Also, every module except commons implicitly cimport cclasses
#   from the snapshot and species modules.
analysis.c:                   commons.pxd communication.pxd ewald.pxd       graphics.pxd                             mesh.pxd snapshot.pxd species.pxd
commons.c:
communication.c:              commons.pxd                                                                                     snapshot.pxd species.pxd
ewald.c:                      commons.pxd                                                                            mesh.pxd snapshot.pxd species.pxd
graphics.c:                   commons.pxd                                                                                     snapshot.pxd species.pxd
gravity.c:                    commons.pxd communication.pxd                                                          mesh.pxd snapshot.pxd species.pxd
integration.c:                commons.pxd                                                                                     snapshot.pxd species.pxd
main.c:          analysis.pxd commons.pxd                                   graphics.pxd             integration.pxd          snapshot.pxd species.pxd utilities.pxd
mesh.c:                       commons.pxd                             fft.c                                                   snapshot.pxd species.pxd
snapshot.c:                   commons.pxd communication.pxd                                                                                species.pxd
species.c:                    commons.pxd communication.pxd                              gravity.pxd                          snapshot.pxd
utilities.c:     analysis.pxd commons.pxd                                   graphics.pxd                                      snapshot.pxd species.pxd



###################
# Cleanup targets #
###################
.PHONY: clean clean_auxiliary clean_logs clean_output clean_tests clean_utilities distclean
# Remove all compiled files
clean:
	$(RM) $(foreach ext,pyc pyx pxd c o so so_ html,$(addsuffix .$(ext), $(pyfiles)))
	$(RM) -r __pycache__
# Remove files generated by running the program
clean_auxiliary:
	$(RM) $(files_auxiliary)
# Remove log files
clean_logs:
	$(RM) $(logs_dir)/*
# Remove output files
clean_output:
	$(RM) -r $(output_dir)/*
# Remove files produced by running tests
clean_tests:
	$(foreach clean_file,$(wildcard $(tests_dir)/*/clean),$(clean_file);)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) $(addprefix $(utilities_dir)/,$(files_utilities))
	$(RM) -r $(top_dir)/concept_backup $(top_dir)/tmp
# Remove all unnecessary files,
# leaving CO𝘕CEPT in a distribution ready state.
distclean: clean clean_auxiliary clean_logs clean_output clean_tests clean_utilities
