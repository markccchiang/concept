#!/usr/bin/env bash

# This script downloads and installs the CONCEPT code by Jeppe Dakin
# with all its dependencies. If run without an argument, it will prompt for
# an installation directory. Alternatively, this directory can be passed
# as an argument. Everything will be installed within this directory.
# You can also download and run the newest version of this script by
# executing the following command:
# bash <(wget -O- --no-ch tiny.cc/nbody)
# The above uses a URL shortener. If it does not work, use the full URL:
# bash <(wget -O- --no-ch https://raw.githubusercontent.com/jmd-dk/concept/master/installer)

# The following software will be installed in order:
# - FreeType (needed by matplotlib)
# - OpenSSL (needed by pip)
# - ncurses (needed by _curses, which is needed by blessings)
# - Python
# - GSL
# - MPICH
# - HDF5
# - FFTW
#   Additionally, the following Python packages (together with
#   their own Python package dependencies will be installed:
#   - Yolk3k
#   - Blessings
#   - Cython
#   - Cython_GSL
#   - NumPy
#   - Matplotlib
#   - MPI4Py
#   - Pexpect
#   - Pillow
#   - H5Py



##################
# Specifications #
##################
# Specification of paths. The substring "__top_dir__"
# will later be replaced with the top level directory.
concept_dir="__top_dir__/concept"
python_dir="__top_dir__/python"
openssl_dir="${python_dir}/openssl"
freetype_dir="${python_dir}"
ncurses_dir="${python_dir}"
fftw_dir="__top_dir__/fftw"
gadget_dir="__top_dir__/gadget"
fftw_for_gadget_dir="${gadget_dir}/fftw"
gsl_dir="__top_dir__/gsl"
hdf5_dir="__top_dir__/hdf5"
mpi_dir="__top_dir__/mpich"
log="__top_dir__/install_log"
dotpaths="__top_dir__/.paths"

# Specification of software versions. A specification of
# "newest" will be replaced with the latest stable version.
concept_version="newest"         # only newest        is known to work
python_version="newest"          #      3.4.3         is known to work
openssl_version="newest"         #      1.0.2d        is known to work
freetype_version="newest"        #      2.6           is known to work
ncurses_version="newest"         #      6.0           is known to work
fftw_version="newest"            #      3.3.4         is known to work
gadget_version="2.0.7"           # only 2.0.7         is known to work
fftw_for_gadget_version="2.1.5"  # only 2.1.5         is known to work
gsl_version="newest"             #      1.16          is known to work
hdf5_version="newest"            #      1.8.15-patch1 is known to work
mpich_version="newest"           #      3.1.4         is known to work
blessings_version="newest"       #      1.6           is known to work
cython_version="0.22.1"          #      0.22.1        is known to work (0.23 does not work)
cython_gsl_version="newest"      #      0.2.1         is known to work
matplotlib_version="newest"      #      1.4.3         is known to work
numpy_version="newest"           #      1.9.2         is known to work
pexpect_version="newest"         #      3.3           is known to work
pillow_version="newest"          #      2.9.0         is known to work
mpi4py_version="newest"          #      1.3.1         is known to work
h5py_version="newest"            #      2.5.0         is known to work



#################
# Initial setup #
#################
# A small pause is needed when executing as the result of wget,
# if installation directory is not supplied as an argument.
sleep 1

# Set up error trapping
ctrl_c()
{
    current_step="aborting"
    sleep 0.5
    kill -- -$$
    exit 2
}
abort()
{
    kill -- -$$
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Status control sequenses
status="initialization"
status_prefix="__new_status__="
status_prefix_length=${#status_prefix}
status_disable="disable"
status_enable="enable"
status_on="on"
status_off="off"
status_visible="${status_on}"

# ANSI/VT100 escape sequences
esc="\x1b"
# Text formatting
esc_normal="${esc}[0m"
esc_bold="${esc}[1m"
esc_italic="${esc}[3m"
esc_reverted="${esc}[7m"
esc_no_italic="${esc}[23m"
esc_concept="CO${esc_italic}N${esc_no_italic}CEPT"
esc_concept_double_backslashes=$(echo "${esc_concept}" | sed 's,\\,\\\\,g')
# Text colors
esc_red="${esc}[91m"
esc_green="${esc}[92m"
esc_yellow="${esc}[93m"
# Cursor movement
esc_up="${esc}[1A"
esc_erase="${esc}[K"
# Special characters
en_quad="\u2000"
# Functions for pretty printing text
heading()
{
    printf "\n${esc_bold}${esc_yellow}${1}${esc_normal}\n"
}
error()
{
    printf "\n${esc_bold}${esc_red}${1}${esc_normal}\n" >&2
}

# Print out welcome message
printf "${esc_bold}${esc_yellow}This is the installation script to ${esc_concept},
the cosmological ${esc_italic}N${esc_no_italic}-body code by Jeppe Dakin${esc_normal}\n\n"

# Backup of initial environment variables
CC_backup="${CC}"
CFLAGS_backup="${CFLAGS}"
CPPFLAGS_backup="${CPPFLAGS}"
DYLD_LIBRARY_PATH_backup="${DYLD_LIBRARY_PATH}"
LD_LIBRARY_PATH_backup="${LD_LIBRARY_PATH}"
LDFLAGS_backup="${LDFLAGS}"
PATH_backup="${PATH}"

# Check whether system dependencies are installed and located on PATH
current_step="check for preinstalled system dependencies"
# Function for testing whether system dependencies are installed and
# located on PATH. For missing system dependencies, it will attempt to
# figure out the command to install it.
check_dependency()
{
    # Arguments: name, command, Debian package
    path=$(which "${2}" || echo)
    if [ -z "${path}" ]; then
        apt_cache_path=$(which apt-cache || echo)
        if [ -n "${apt_cache_path}" ]; then
            # APT installed
            echo "Could not find '${1}'"
            not_in_repo=$(apt-cache show "${3}" &> /dev/null; echo $?)
            if [ ${not_in_repo} == 0 ]; then
                echo "You can install it by typing:"
                echo "sudo apt-get -y install ${3}"
                while true; do
                    read -p "Run above command now? [Y/n] " yn
                    case $yn in
                        [Yy]* ) sudo apt-get -y install ${3}; printf "${1} successfully installed\n\n"; return;;
                        [Nn]* ) error "Terminated install due to missing component '${1}'"; exit 1;;
                        "" ) sudo apt-get -y install ${3}; printf "${1} successfully installed\n\n"; return;;
                        * ) "Terminated install due to missing component '${1}'"; exit 1;;
                    esac
                done
            fi
            exit 1
        else
            # No package manager found
            error "Error: Could not find '${1}'"
            exit 1
        fi
    fi
}
check_dependency "awk" "awk" "gawk"
check_dependency "g++" "g++" "g++"
check_dependency "gcc" "gcc" "gcc"
check_dependency "gfortran" "gfortran" "gfortran"
check_dependency "make" "make" "build-essential"
check_dependency "sed" "sed" "sed"
check_dependency "tar" "tar" "tar"
check_dependency "wget" "wget" "wget"

# Creating top level directory (top_dir)
current_step="setup of top level directory"
if [ -z "${1}" ]; then
    read -p "Where should the code be installed?$(echo $'\n> ')" -e top_dir
else 
    top_dir="${1}"
fi
top_dir="${top_dir//[ ]/\\ }"        # Places backslashes before spaces. These are needed when expanding tilde, but they will not persist
eval top_dir="${top_dir}"            # Expand tilde
top_dir=$(readlink -f "${top_dir}")  # Convert to absolute path
echo "The code will be installed in ${top_dir}"
mkdir -p "${top_dir}"
cd "${top_dir}"

# Replace "__top_dir__" in paths with the user specified top_dir 
concept_dir="${concept_dir/__top_dir__/${top_dir}}"
python_dir="${python_dir/__top_dir__/${top_dir}}"
openssl_dir="${openssl_dir/__top_dir__/${top_dir}}"
freetype_dir="${freetype_dir/__top_dir__/${top_dir}}"
ncurses_dir="${ncurses_dir/__top_dir__/${top_dir}}"
fftw_dir="${fftw_dir/__top_dir__/${top_dir}}"
gadget_dir="${gadget_dir/__top_dir__/${top_dir}}"
fftw_for_gadget_dir="${fftw_for_gadget_dir/__top_dir__/${top_dir}}"
gsl_dir="${gsl_dir/__top_dir__/${top_dir}}"
hdf5_dir="${hdf5_dir/__top_dir__/${top_dir}}"
mpi_dir="${mpi_dir/__top_dir__/${top_dir}}"
log="${log/__top_dir__/${top_dir}}"
dotpaths="${dotpaths/__top_dir__/${top_dir}}"



###########################
# Beginning of subprocess #
(
# Set up error trapping
ctrl_c_subprocess()
{
    trap : 0
    ctrl_c
    exit 0
}
abort_subprocess()
{
    trap : 0
    if [ "${current_step}" != "aborting" ]; then
        error "An error occurred during ${current_step}!"
    fi
    abort
    exit 0
}
trap 'ctrl_c_subprocess' SIGINT
trap 'abort_subprocess' EXIT
set -e

# Functions for controlling the current status
set_status()
{
    status="${1}"
    echo "${status_prefix}${status}"
}
disable_status()
{
    echo "${status_prefix}${status_disable}"
}
enable_status()
{
    echo "${status_prefix}${status_enable}"
}



#############################
# URL's to all the software #
#############################
# Function for checking that a given url actually exists
validate_url()
{
    # Arguments: Name, URL
    current_step="validation of ${1} link"
    set_status "Validating ${1} link"
    text=$(wget -S --spider "${2}" 2>&1)
    text_http=$(echo "${text}" | grep "Remote file exists" || echo)
    filename=$(basename "${2}")
    text_ftp=$(echo "${text}" | grep "${filename}.*exists" || echo)
    if ! ([ -n "${text_http}" ] || ([[ "${2}" == "ftp://"* ]] && [ -n "${text_ftp}" ])); then
        error "Error: The ${1} link is broken!"
        exit 1
    fi
}

# FreeType
if [ "${freetype_version}" == "newest" ]; then
    current_step="search for latest version of FreeType"
    set_status "Searching for latest version of FreeType"
    freetype_version=$(wget -q -O- --no-check-certificate "http://download.savannah.gnu.org/releases/freetype/" | grep -o "freetype-[0-9.]*tar" | sort -u | tail -n 1 | grep -o [0-9.]*)
    freetype_version="${freetype_version%?}"
    if [ -z "${freetype_version}" ]; then
        error "Error: Could not identify the version number of the latest FreeType!"
        exit 1
    fi
fi
freetype_url="http://download.savannah.gnu.org/releases/freetype/freetype-${freetype_version}.tar.gz"
validate_url "FreeType" "${freetype_url}"

# OpenSSL
if [ "${openssl_version}" == "newest" ]; then
    current_step="search for latest version of OpenSSL"
    set_status "Searching for latest version of OpenSSL"
    openssl_version=$(wget -q -O- --no-check-certificate "https://www.openssl.org/source/" | grep -o -P "(?<=openssl-).*(?=LATEST)" || echo)
    openssl_version="$(sed 's/.tar.gz.*//' <<< "${openssl_version}")"
    if [ -z "${openssl_version}" ]; then
        error "Error: Could not identify the version number of the latest OpenSSL!"
        exit 1
    fi
fi
openssl_url="ftp://ftp.openssl.org/source/openssl-${openssl_version}.tar.gz"
validate_url "OpenSSL" "${openssl_url}"

# ncurses
if [ "${ncurses_version}" == "newest" ]; then
    current_step="search for latest version of ncurses"
    set_status "Searching for latest version of ncurses"
    ncurses_version=$(wget -q -O- --no-check-certificate "http://ftp.gnu.org/pub/gnu/ncurses/" | grep -o "ncurses-[0-9.]*tar" | sort -u | tail -n 1 | grep -o [0-9.]*)
    ncurses_version="${ncurses_version%?}"
    if [ -z "${ncurses_version}" ]; then
        error "Error: Could not identify the version number of the latest ncurses!"
        exit 1
    fi
fi
ncurses_url="http://ftp.gnu.org/pub/gnu/ncurses/ncurses-${ncurses_version}.tar.gz"
validate_url "ncurses" "${ncurses_url}"

# Python (note that python_version will be overwritten later!)
if [ "${python_version}" == "newest" ]; then
    current_step="search for latest version of Python"
    set_status "Searching for latest version of Python"
    python_version=$(wget -q -O- --no-check-certificate "https://www.python.org/downloads/" | grep -o -P "(?<=Python-).*(?=.tar.xz)" | head -1  || echo)
    if [ -z "${python_version}" ]; then
        error "Error: Could not identify the version number of the latest Python!"
        exit 1
    fi
fi
python_url="https://www.python.org/ftp/python/${python_version}/Python-${python_version}.tar.xz"
validate_url "Python" "${python_url}"

# GSL
if [ "${gsl_version}" == "newest" ]; then
    current_step="search for latest version of GSL"
    set_status "Searching for latest version of GSL"
    gsl_version=$(wget -q -O- --no-check-certificate "http://mirrors.dotsrc.org/gnu/gsl/" | grep -o -P "(?<=gsl-[0-9]).*(?=.tar.gz)" || echo)
    gsl_version="${gsl_version##*gsl-}"
    if [ -z "${gsl_version}" ]; then
        error "Error: Could not identify the version number of the latest GSL!"
        exit 1
    fi
fi
gsl_url="http://mirrors.dotsrc.org/gnu/gsl/gsl-${gsl_version}.tar.gz"
validate_url GSL "${gsl_url}"

# MPICH
if [ "${mpich_version}" == "newest" ]; then
    current_step="search for latest version of MPICH"
    set_status "Searching for latest version of MPICH"
    mpich_version=$(wget -q -O- --no-check-certificate "http://www.mpich.org/downloads" | grep -m 1 -o -P "(?<=mpich-).*(?=stable)" | awk '{print $1}' || echo "")
    if [ -z "${mpich_version}" ]; then
        error "Error: Could not identify the version number of the latest MPICH!"
        exit 1
    fi
fi
mpich_url="http://www.mpich.org/static/downloads/${mpich_version}/mpich-${mpich_version}.tar.gz"
validate_url "MPICH" "${mpich_url}"

# HDF5
if [ "${hdf5_version}" == "newest" ]; then
    current_step="search for latest version of HDF5"
    set_status "Searching for latest version of HDF5"
    hdf5_version=$(wget -q -O- --no-check-certificate "ftp://ftp.hdfgroup.org/HDF5/current/src/" | grep -m 1 -o -P "(?<=hdf5-).*(?=.tar.bz2\")" || echo "")
    if [ -z "${hdf5_version}" ]; then
        error "Error: Could not identify the version number of the latest HDF5!"
        exit 1
    fi
fi
hdf5_url="ftp://ftp.hdfgroup.org/HDF5/current/src/hdf5-${hdf5_version}.tar.bz2"
validate_url "HDF5" "${hdf5_url}"

# FFTW
if [ "${fftw_version}" == "newest" ]; then
    current_step="search for latest version of FFTW"
    set_status "Searching for latest version of FFTW"
    fftw_version=$(wget -q -O- --no-check-certificate "http://www.fftw.org/download.html" | grep -m 1 -o -P "(?<=fftw-).*(?=.tar.gz\")" || echo)
    if [ -z "${fftw_version}" ]; then
        error "Error: Could not identify the version number of the latest FFTW!"
        exit 1
    fi
fi
fftw_url="http://www.fftw.org/fftw-${fftw_version}.tar.gz"
validate_url "FFTW" "${fftw_url}"

# CONCEPT
concept_repo_url="https://github.com/jmd-dk/concept"
if [ "${concept_version}" == "newest" ]; then
    current_step="search for latest version of ${esc_concept}"
    set_status "Searching for latest version of ${esc_concept_double_backslashes}"
    # The version of CONCEPT is set to the commit number
    repo_text=$(wget -q -O- --no-check-certificate ${concept_repo_url})
    line_nr=$(echo "${repo_text}" | grep -n "  commits" | awk '{print $1}')
    line_nr=${line_nr::-1}
    line_nr=$(expr ${line_nr} - 2)
    commit_nr=$(echo "${repo_text}" | sed -n -e "${line_nr}p" | sed -e 's/^[[:space:]]*//')
    concept_version="commit ${commit_nr}"
else
    error "Error: The installer does not know how to find a specific version of CONCEPT!"
    exit 1
fi
concept_url="${concept_repo_url}/archive/master.tar.gz"
validate_url "${esc_concept_double_backslashes}" "${concept_url}"

# FFTW for Gadget
if [ "${fftw_for_gadget_version}" == "newest" ]; then
    current_step="search for latest version of FFTW for GADGET"
    set_status "Searching for latest version of FFTW for GADGET"
    fftw_for_gadget_version=$(wget -q -O- --no-check-certificate "http://www.fftw.org/download.html" | grep -m 1 -o -P "(?<=fftw-).*(?=.tar.gz\")" || echo)
    if [ -z "${fftw_for_gadget_version}" ]; then
        error "Error: Could not identify the version number of the latest FFTW"
        exit 1
    fi
fi
fftw_for_gadget_url="http://www.fftw.org/fftw-${fftw_for_gadget_version}.tar.gz"
validate_url "FFTW for GADGET" "${fftw_for_gadget_url}"

# GADGET2
if [ "${gadget_version}" == "newest" ]; then
    error "Error: The installer does not know how to search for the newest version of GADGET!"
    exit 1
fi
gadget_url="http://www.mpa-garching.mpg.de/gadget/gadget-${gadget_version}.tar.gz"
validate_url GADGET "${gadget_url}"

# Write out installation overview
disable_status
heading "Installation overview"
printf "The following software will be installed\n"
printf "${esc_bold}Name{}${en_quad}${en_quad}${en_quad}Version{}${en_quad}${en_quad}${en_quad}Installation path${esc_normal}
CONCEPT{}${concept_version}{}${concept_dir}
├─Python{}${python_version}{}${python_dir}
│ ├─OpenSSL{}${openssl_version}{}${openssl_dir}
│ ├─FreeType{}${freetype_version}{}${freetype_dir}
│ └─ncurses{}${ncurses_version}{}${ncurses_dir}
├─GSL{}${gsl_version}{}${gsl_dir}
├─MPICH{}${mpich_version}{}${mpi_dir}
├─HDF5{}${hdf5_version}{}${hdf5_dir}
├─FFTW{}${fftw_version}{}${fftw_dir}
└─GADGET{}${gadget_version}{}${gadget_dir}
${en_quad}${en_quad}└─FFTW{}${fftw_for_gadget_version}{}${fftw_for_gadget_dir}\n" | column -n -t -s {}
sleep 10
enable_status



###################################
# Installing CONCEPT dependencies #
###################################
# FreeType (needed by matplotlib)
current_step="installation of FreeType"
heading "Installing FreeType"
set_status "Installing FreeType"
mkdir tmp
cd tmp
disable_status
wget -c -O freetype.tar.gz --no-check-certificate "${freetype_url}"
enable_status
tar xfz freetype.tar.gz
cd freetype*
./configure --prefix="${freetype_dir}"
make
make install
cd "${top_dir}"
rm -rf tmp

# OpenSSL (needed by pip)
current_step="installation of OpenSSL"
heading "Installing OpenSSL"
set_status "Installing OpenSSL"
mkdir tmp
cd tmp
disable_status
wget -c -O openssl.tar.gz --no-check-certificate "${openssl_url}"
enable_status
tar xfz openssl.tar.gz
cd openssl*
./config shared --prefix="${python_dir}" --openssldir="${openssl_dir}"
make
make install
cd "${top_dir}"
rm -rf tmp

# ncurses (needed by _curses, which is needed by blessings)
current_step="installation of ncurses"
heading "Installing ncurses"
set_status "Installing ncurses"
mkdir tmp
cd tmp
disable_status
wget -c -O ncurses.tar.gz --no-check-certificate "${ncurses_url}"
enable_status
tar xfz ncurses.tar.gz
cd ncurses*
./configure --with-shared --prefix="${ncurses_dir}"
make
make install
cd "${top_dir}"
rm -rf tmp

# Python
current_step="installation of Python"
heading "Installing Python"
set_status "Installing Python"
mkdir tmp
cd tmp
disable_status
wget -c -O python.tar.xz --no-check-certificate "${python_url}"
enable_status
tar -xJf python.tar.xz
cd Python*
export LDFLAGS="-L${python_dir}/lib -Wl,-rpath ${python_dir}/lib ${LDFLAGS}"
export LD_LIBRARY_PATH="${python_dir}/lib:${LD_LIBRARY_PATH}"
export CPPFLAGS="-I${python_dir}/include -I${openssl_dir}/include/openssl -I${ncurses_dir}/include/ncurses ${CPPFLAGS}"
./configure --enable-shared --prefix="${python_dir}" --with-ensurepip=install
make
make install
export LDFLAGS="${LDFLAGS_backup}"
export LD_LIBRARY_PATH="${LD_LIBRARY_PATH_backup}"
export CPPFLAGS="${CPPFLAGS_backup}"
cp LICENSE README "${python_dir}/"
cd "${top_dir}"
rm -rf tmp
# Overwrite the 'python_version' variable with the major.minor version and
# create a python variable, storing the path to the newly installed Python interpreter
python_version=$("${python_dir}/bin/python3" -c "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
python="${python_dir}/bin/python${python_version}"
# Update Python packages preinstalled with Python itself, utilizing yolk
current_step="update of Python"
disable_status
"${python}" -m pip install --no-cache-dir --upgrade pip
"${python}" -m pip install --no-cache-dir yolk3k
"${python}" -m pip install --no-cache-dir --upgrade $("${python}" -m yolk -U | awk '{print $1}' | uniq)
enable_status

# GSL
current_step="installation of GSL"
heading "Installing GSL"
set_status "Installing GSL"
mkdir "${gsl_dir}"
mkdir tmp
cd tmp
disable_status
wget -c -O gsl.tar.gz --no-check-certificate "${gsl_url}"
enable_status
tar xfz gsl.tar.gz
cd gsl*
./configure --prefix="${gsl_dir}"
make
make install
cp COPYING README "${gsl_dir}"
cd "${top_dir}"
rm -rf tmp

# MPICH
current_step="installation of MPICH"
heading "Installing MPICH"
set_status "Installing MPICH"
mkdir "${mpi_dir}"
mkdir tmp
cd tmp
disable_status
wget -c -O mpich.tar.gz --no-check-certificate "${mpich_url}"
enable_status
tar xfz mpich.tar.gz
cd mpich*
./configure --enable-shared --disable-fortran --prefix="${mpi_dir}"
make
make install
cp COPYRIGHT "${mpi_dir}"
cd "${top_dir}"
rm -rf tmp

# HDF5
current_step="installation of HDF5"
heading "Installing HDF5"
set_status "Installing HDF5"
mkdir tmp
cd tmp
disable_status
wget -c -O hdf5.tar.bz2 --no-check-certificate "${hdf5_url}"
enable_status
tar xjf hdf5.tar.bz2
cd hdf5*
CC="${mpi_dir}/bin/mpicc" LD_LIBRARY_PATH="${mpi_dir}/lib:${LD_LIBRARY_PATH}" ./configure --enable-shared --enable-parallel --prefix="${hdf5_dir}"
make
make install
cp COPYING README.txt "${hdf5_dir}"
cd "${top_dir}"
rm -rf tmp

# FFTW
current_step="installation of FFTW"
heading "Installing FFTW"
set_status "Installing FFTW"
mkdir tmp
cd tmp
disable_status
wget -c -O fftw.tar.gz "${fftw_url}"
enable_status
tar xfz fftw.tar.gz
cd fftw*
# Double-precision
CC="${mpi_dir}/bin/mpicc" MPICC="${mpi_dir}/bin/mpicc" CFLAGS="-O3 -fPIC" CPPFLAGS="-I/${mpi_dir}/include" LDFLAGS="-L${mpi_dir}/lib" MPILIBS=-lmpi ./configure --enable-shared --enable-mpi --enable-openmp --enable-threads --prefix="${fftw_dir}"
make
make install
# Single-precision goes here ..........................
cp COPYING README "${fftw_dir}"
cd "${top_dir}"
rm -rf tmp



##############################
# Installing Python packages #
##############################
# Get versions of Python packages from PyPI.
# Function for finding the newest version of Python packages, utilizing yolk.
yolk_version()
{
    # Arguments: Python package name, variable to be set to version number
    current_step="search for latest version of ${1} in PyPI"
    set_status "Searching for latest version of ${1} in PyPI"
    pip_name="${1//_/}"  # Remove underscores from name
    local version=$("${python}" -m yolk -V "${pip_name}" | head -n 1 | awk '{print $NF}')
    local pythonpackage_version_var=$2
    eval $pythonpackage_version_var="'$version'"
}

# Function for validating that specific versions of
# Python packages are available on PyPI.
pip_validate_version()
{
    # Arguments: Python package name, version
    current_step="search for ${1} version ${2} in PyPI"
    set_status "Searching for ${1} version ${2} in PyPI"
    pip_name="${1//_/}"  # Remove underscores from name
    pip_versions=$(${python} -m pip install ${pip_name}==versionsplease 2>&1 || :)
    pip_versions="${pip_versions// /$'\n'}"
    pip_versions=$(echo "${pip_versions}" | sed 's/.$//')
    version_exists=$(echo "${pip_versions}" | grep -x "${2}" || :)
    if [ -z "${version_exists}" ]; then
        error "Error: Could not find version ${2} of ${1} in PyPI!"
        exit 1
    fi
}

# Blessings
if [ "${blessings_version}" == "newest" ]; then
    yolk_version "Blessings" blessings_version
else
    pip_validate_version "Blessings" "${blessings_version}"
fi

# Cython
if [ "${cython_version}" == "newest" ]; then
    yolk_version "Cython" cython_version
else
    pip_validate_version "Cython" "${cython_version}"
fi

# Cython_GSL
if [ "${cython_gsl_version}" == "newest" ]; then
    yolk_version "Cython_GSL" cython_gsl_version
else
    pip_validate_version "Cython_GSL" "${cython_gsl_version}"
fi

# NumPy
if [ "${numpy_version}" == "newest" ]; then
    yolk_version "NumPy" numpy_version
else
    pip_validate_version "NumPy" "${numpy_version}"
fi

# Matplotlib
if [ "${matplotlib_version}" == "newest" ]; then
    yolk_version "Matplotlib" matplotlib_version
else
    pip_validate_version "Matplotlib" "${matplotlib_version}"
fi

# MPI4Py
if [ "${mpi4py_version}" == "newest" ]; then
    yolk_version "MPI4Py" mpi4py_version
else
    pip_validate_version "MPI4Py" "${mpi4py_version}"
fi

# Pexpect
if [ "${pexpect_version}" == "newest" ]; then
    yolk_version "Pexpect" pexpect_version
else
    pip_validate_version "Pexpect" "${pexpect_version}"
fi

# Pillow
if [ "${pillow_version}" == "newest" ]; then
    yolk_version "Pillow" pillow_version
else
    pip_validate_version "Pillow" "${pillow_version}"
fi      

# H5Py 
if [ "${h5py_version}" == "newest" ]; then
    yolk_version "H5Py" h5py_version
else
    pip_validate_version "H5Py" "${h5py_version}"
fi

# Print out Python package installation overview
disable_status
heading "Python packages overview"
printf "The following Python packages will be installed\n"
printf "${esc_bold}Name{}${en_quad}${en_quad}${en_quad}Version{}${en_quad}${en_quad}${en_quad}Installation path${esc_normal}
┌─Blessings{}${blessings_version}{}${python_dir}/lib/python${python_version}/site-packages/blessings
├─Cython{}${cython_version}{}${python_dir}/lib/python${python_version}/site-packages/Cython
├─Cython_GSL{}${cython_gsl_version}{}${python_dir}/lib/python${python_version}/site-packages/cython_gsl
├─H5Py{}${h5py_version}{}${python_dir}/lib/python${python_version}/site-packages/h5py-${h5py_version}-py${python_version}-$(uname -s | awk '{print tolower($0)}')-$(uname -m).egg/h5py
├─Matplotlib{}${matplotlib_version}{}${python_dir}/lib/python${python_version}/site-packages/matplotlib
├─MPI4Py{}${mpi4py_version}{}${python_dir}/lib/python${python_version}/site-packages/mpi4py
├─NumPy{}${numpy_version}{}${python_dir}/lib/python${python_version}/site-packages/numpy
├─Pexpect{}${pexpect_version}{}${python_dir}/lib/python${python_version}/site-packages/pexpect
└─Pillow{}${pillow_version}{}${python_dir}/lib/python${python_version}/site-packages/PIL\n" | column -t -s {}
sleep 10
enable_status

# Install Python packages from PyPI.
# Function for installing Python packages, utilizing pip.
pip_install()
{
    # Arguments: Python package name, version
    current_step="installation of ${1}"
    heading "Installing ${1}"
    set_status "Installing ${1}"
    mkdir "${top_dir}/tmp"
    pip_name="${1//_/}"  # Remove underscores from name
    "${python}" -m pip install -v -v -v --no-cache-dir --no-binary=:all: --download "${top_dir}/tmp" "${pip_name}==${2}"
    "${python}" -m pip install -v -v -v --no-index --find-links="${top_dir}/tmp" "${pip_name}==${2}"
    rm -rf "${top_dir}/tmp"
}

# Blessings
pip_install "Blessings" "${blessings_version}"

# Cython
pip_install "Cython" "${cython_version}"

# The Cython_GSL Python package
export LD_LIBRARY_PATH="${gsl_dir}/lib:${LD_LIBRARY_PATH}"
pip_install "Cython_GSL" "${cython_gsl_version}"
export LD_LIBRARY_PATH="${LD_LIBRARY_PATH_backup}"

# NumPy
pip_install "NumPy" "${numpy_version}"

# Matplotlib
export LDFLAGS="-L${python_dir}/lib -Wl,-rpath ${python_dir}/lib ${LDFLAGS}"
export LD_LIBRARY_PATH="${python_dir}/lib:${LD_LIBRARY_PATH}"
export PATH="${python_dir}/bin:${python_dir}/lib:${python_dir}/include:${python_dir}/include/freetype2:${PATH}"
pip_install "Matplotlib" "${matplotlib_version}"
export LDFLAGS="${LDFLAGS_backup}"
export LD_LIBRARY_PATH="${LD_LIBRARY_PATH_backup}"
export PATH="${PATH_backup}"

# MPI4Py
MPI_DIR_backup="${MPI_DIR}"
export MPI_DIR="${mpi_dir}"
export PATH="${mpi_dir}/bin:${PATH}"
export LD_LIBRARY_PATH="${mpi_dir}/lib:${LD_LIBRARY_PATH}"
export DYLD_LIBRARY_PATH="${mpi_dir}/lib:${DYLD_LIBRARY_PATH}"
pip_install "MPI4Py" "${mpi4py_version}"
export MPI_DIR="${MPI_DIR_backup}"
export PATH="${PATH_backup}"
export LD_LIBRARY_PATH="${LD_LIBRARY_PATH_backup}"
export DYLD_LIBRARY_PATH="${DYLD_LIBRARY_PATH_backup}"

# Pexpect (for some reason, this has to be before H5Py)
pip_install "Pexpect" "${pexpect_version}"

# Pillow
pip_install "Pillow" "${pillow_version}"

# H5Py (manual invocation of setup.py needed as --mpi needs to be supplied)
current_step="installation of H5Py"
heading "Installing H5Py"
set_status "Installing H5Py"
mkdir "${top_dir}/tmp"
"${python}" -m pip install -v -v -v --no-cache-dir --no-binary=:all: --download "${top_dir}/tmp" "h5py==${h5py_version}"
cd "${top_dir}/tmp"
tar xfz h5py*.gz
cd h5py*
export CC="${mpi_dir}/bin/mpicc"
"${python}" setup.py configure --mpi --hdf5="${hdf5_dir}"
"${python}" setup.py build
"${python}" setup.py install
export CC="${CC_backup}"
cd "${top_dir}"
rm -rf "${top_dir}/tmp"



###########################
# The CONCEPT code itself #
###########################
# The CONCEPT code
current_step="installation of ${esc_concept}"
printf "\n${esc_bold}${esc_yellow}Installing ${esc_concept}${esc_normal}\n"
set_status 'Installing CONCEPT'
disable_status
wget -c -O concept.tar.gz --no-check-certificate "${concept_url}"
enable_status
tar xfz concept.tar.gz
rm concept.tar.gz
mv concept-master/* "${top_dir}"  # Note: This leaves the .paths file behind in the concept-master folder
rm -r concept-master
# Create empty logs and output directories
mkdir -p "${concept_dir}/logs"
mkdir -p "${concept_dir}/output"

# Create the .paths file, storing important paths used by the program
current_step="creataion of the .paths file"
heading "Writing paths to .paths"
set_status "Writing paths to .paths"
Gadget2_dir="${gadget_dir}/Gadget2"
tests_dir="${concept_dir}/tests"
cython="${python_dir}/bin/cython"
mpicc="${mpi_dir}/bin/mpicc"
mpiexec="${mpi_dir}/bin/mpiexec"
python_config="${python_dir}/bin/python${python_version}-config"
run="${concept_dir}/run"
echo "# This file contains absolute paths to directories and files used by the
# program. You must manually edit the paths below. All other files rely on
# these paths, as they are not given anywhere else.

###############
# Directories #
###############
# Directory containing the CONCEPT source code
concept_dir='${concept_dir}'
# Directory of FFTW
fftw_dir='${fftw_dir}'
# Directory of FFTW2, used by GADGET
fftw_for_gadget_dir='${fftw_for_gadget_dir}'
# Directory of Gadget2
gadget_dir='${gadget_dir}'
# Directory containing the GADGET2 source code
Gadget2_dir='${Gadget2_dir}'
# Directory of GSL
gsl_dir='${gsl_dir}'
# Directory of HDF5
hdf5_dir='${hdf5_dir}'
# Directory of MPI
mpi_dir='${mpi_dir}'
# Directory of Python
python_dir='${python_dir}'
# Directory containing tests for the CONCEPT code
tests_dir='${tests_dir}'
# Top level directory, containing e.g. README.md
top_dir='${top_dir}'

#########
# Files #
#########
# The Cython executable
cython='${cython}'
# The MPI C compiler
mpicc='${mpicc}'
# The MPI executable
mpiexec='${mpiexec}'
# The Python3 interpreter
python='${python}'
# The Python3 configuration executable
python_config='${python_config}'
# The run script of the CONCEPT code
run='${run}'
" > "${dotpaths}"



######################################################
# Install GADGET2, used for testing the CONCEPT code #
######################################################
# FFTW 2.1.5 (GADGET2 is incompatible with FFTW 3.x)
current_step="installation of FFTW2 used by GADGET"
heading "Installing FFTW2 used by GADGET"
set_status "Installing FFTW2 used by GADGET"
mkdir tmp
cd tmp
disable_status
wget -c -O fftw.tar.gz "${fftw_for_gadget_url}"
enable_status
tar xfz fftw.tar.gz
cd fftw*
# Double-precision
CC="${mpi_dir}/bin/mpicc" MPICC="${mpi_dir}/bin/mpicc" CFLAGS="-O3 -fPIC" CPPFLAGS="-I${mpi_dir}/include" LDFLAGS="-L${mpi_dir}/lib" MPILIBS=-lmpi ./configure --enable-shared --enable-mpi --enable-openmp --enable-threads --enable-type-prefix --prefix="${fftw_for_gadget_dir}"
make
make install
# Single-precision
make clean
CC="${mpi_dir}/bin/mpicc" MPICC="${mpi_dir}/bin/mpicc" CFLAGS="-O3 -fPIC" CPPFLAGS="-I${mpi_dir}/include" LDFLAGS="-L${mpi_dir}/lib" MPILIBS=-lmpi ./configure --enable-shared --enable-mpi --enable-openmp --enable-threads --enable-float --enable-type-prefix --prefix="${fftw_for_gadget_dir}"
make
make install
cp COPYING README "${fftw_for_gadget_dir}"
cd "${top_dir}"
rm -rf tmp

# GADGET2
current_step="installation of GADGET"
heading "Installing GADGET"
set_status "Installing GADGET"
mkdir tmp
cd tmp
disable_status
wget -c -O gadget2.tar.gz "${gadget_url}"
enable_status
tar xfz gadget2.tar.gz
mv Gadget*/* "${gadget_dir}"
cd "${top_dir}"
rm -rf tmp

# Copyright notice
current_step="copyright notice"
heading "Copyright notice"
printf "FFTW 2, FFTW 3, GADGET, GSL, HDF5, MPICH and
Python (with dependency libraries FreeType, ncurses and OpenSSL and 
site-packages Blessings, Cython, Cython_GSL, H5Py, Matplotlib, MPI4Py,
NumPy, Pexpect, Pillow and Yolk) has been installed into seperate folders in
${top_dir}.
Any use of ${esc_concept} must conform to the license terms of the
above software. These can be found in their seperate installation
directories.\n\n"

# Subprocess complete. Deactivate trap before exiting
disable_status
trap : 0
) > "${log}" &
log_pid=$!
# End of subprocess #
#####################



################
# Display loop #
################
printf "\n\n"
tail -f "${log}" --pid $log_pid | while read line; do
    if [[ "${line}" == "${status_prefix}"* ]]; then
        status_backup_="${status}"
        status=${line:${status_prefix_length}}
        # Enable/disable status
        if [ "${status}" == "${status_disable}" ]; then
            status_visible="${status_off}"
            status_backup="${status_backup_}"
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
        elif [ "${status}" == "${status_enable}" ]; then
            status_visible="${status_on}"
            status="${status_backup}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        else
            # Normal status update
            if [ "${status_visible}" == "${status_on}" ]; then
                printf "${esc_up}${esc_erase}"
                printf "${esc_up}"
                printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
            fi
        fi
    else
        if [ "${status_visible}" == "on" ]; then
            # Line with status enabled
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
            echo -e "${line}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        else
            # Line with status disabled
            echo -e "${line}"
        fi
    fi
done
printf "${esc_up}${esc_erase}"
printf "${esc_up}"

# Remove the log file
rm -f "${log}"

# Installation complete. Deactivate trap before exiting.
trap : 0
printf "\n${esc_bold}${esc_green}${esc_concept} successfully installed${esc_normal}\n"
