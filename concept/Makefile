# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015-2017 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The author of CO𝘕CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# This is the makefile for the CO𝘕CEPT code. Preferebly you should not
# interact with this file directly, but rather use the concept script to
# build and run the code.

# Use the bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles = analysis      \
          commons       \
          communication \
          ewald         \
          fluid         \
          graphics      \
          gravity       \
          gravity_old   \
          integration   \
          interactions  \
          linear        \
          main          \
          mesh          \
          snapshot      \
          species       \
          utilities
# Filename of the module holding common definitions
commons = commons.py
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# Filename of the temporary .pyx file storing the custom types
types = .types.pyx
# List of files generated in the concept directory by running the code,
# which should be removed by the distclean target
# (the types file is removed by the clean target).
files_auxiliary = jobscript              \
                  .exit_code             \
                  .ewald_gridsize*       \
                  .fftw_wisdom_gridsize*
# List of files and directories in the utilities directory
# generated by using the utilities.
files_utilities = params     \
                  update_new



################################################
# Environment information from the .paths file #
################################################
# Get the path to the .paths file
paths_filename = $(shell this_dir="$(CURDIR)";                     \
				         path="$${this_dir}";                      \
				         while :; do                               \
				             if [ -f "$${path}/.paths" ]; then     \
				                 paths_filename="$${path}/.paths"; \
				                 break;                            \
				             fi;                                   \
				             if [ "$${path}" == "/" ]; then        \
				                 paths_filename='fail';            \
				                 break;                            \
				             fi;                                   \
				             path="$$(dirname "$${path}")";        \
				         done;                                     \
				         echo "$${paths_filename}";                \
				   )
ifeq ($(paths_filename),fail)
    $(error Could not find the .paths file)
endif
# Include (absolute) paths from the .paths file
include $(paths_filename)
# Function which takes in a quoted argument. If this argument is
# a path (perhaps prefixed with e.g. -I) and it is located near this
# Makefile, the return value is the relative path. Otherwise, the
# return value is just the untouched argument.
# A backslash will be placed before spaces.
sensible_path = $(shell $(python) -c "import os;                                                  \
                                      path = $1;                                                  \
                                      prefix = ([''] + [prefix for prefix in                      \
                                                        ('-I', '-L', '-Wl,-rpath=')               \
                                                        if path.startswith(prefix)]               \
                                                )[-1];                                            \
                                      abspath = path[len(prefix):];                               \
                                      relpath = os.path.relpath(abspath, '.');                    \
                                      path = abspath if relpath.startswith('../..') else relpath; \
                                      path = prefix + path;                                       \
                                      path = path.replace(' ', chr(92) + ' ');                    \
                                      path = path.replace(2*chr(92), chr(92));                    \
                                      path = path.strip();                                        \
                                      print(path);                                                \
                                      "                                                           \
                  )
# Transform all the included paths to sensible paths
# to reduce screen clutter when making.
paths = $(shell grep -o '.*=' $(paths_filename) | sed 's/.$$//')
$(foreach path,$(paths),$(eval $(path)=$(call sensible_path,$($(path)))))



########################################
# Settings for compilation and linking #
########################################
# Function which eliminates duplicates
uniq = $(strip $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1))))
# The python configuration script
python_config = $(shell readlink -f $$(which $(python)))-config
# Options passed when cythonizing .pyx files
python_version_major = $(shell $(python) -c "import sys; print(sys.version_info.major)")
cythonflags = -$(python_version_major) -a
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_dir)/include
python_incl = $(shell $(python_config) --includes)
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC                = $(mpicc)
unwanted_warnings = unused-but-set-variable \
                    uninitialized
python_cflags     = $(filter-out $(addprefix -W,$(unwanted_warnings)), \
                                 $(shell $(python_config) --cflags))
other_cflags      = -O3                  \
                    -ffast-math          \
                    -pthread             \
                    -std=c99             \
                    -fno-strict-aliasing \
                    -fPIC                \
                    -Wall                \
                    -Wextra              \
                    $(addprefix -Wno-,$(unwanted_warnings))
CFLAGS            = $(call uniq, $(foreach flag, $(python_cflags)                \
                                                 $(other_cflags)                 \
                                                 $(includes)                     \
                                                 ,                               \
                                                 $(call sensible_path,'$(flag)') \
                                   )                                             \
                      )
# Libraries to link
fftw_libs     = -L$(fftw_dir)/lib -Wl,-rpath=$(fftw_dir)/lib -lfftw3_mpi -lfftw3
gsl_libs      = -L$(gsl_dir)/lib -Wl,-rpath=$(gsl_dir)/lib -lgsl -lgslcblas -lm
mpi_libs      = -L$(mpi_dir)/lib -Wl,-rpath=$(mpi_dir)/lib -lmpi
python_libdir = $(shell $(python) -c "import sysconfig;                          \
                                      print(sysconfig.get_config_var('LIBDIR')); \
                                      "                                          \
                  )
python_libs   = -L$(python_libdir) -Wl,-rpath=$(python_libdir) $(shell $(python_config) --libs)
other_libs    = -Wl,-O3
LDLIBS        = $(call uniq, $(foreach flag, $(fftw_libs)                     \
                                             $(gsl_libs)                      \
                                             $(mpi_libs)                      \
                                             $(python_libs)                   \
                                             $(other_libs)                    \
                                             ,                                \
                                              $(call sensible_path,'$(flag)') \
                               )                                              \
                  )
# Linker options
python_ldflags = $(shell $(python_config) --ldflags)
other_ldflags  = -shared
LDFLAGS        = $(call uniq, $(foreach flag, $(python_ldflags)               \
                                              $(other_ldflags)                \
                                              ,                               \
                                              $(call sensible_path,'$(flag)') \
                                )                                             \
                   )



###################
# Primary targets #
###################
# The below recipes are responsible for the
# .py --> ((.pyx --> types) --> .pxd) --> (.c + .html) --> .o --> .so
# build chain. A heading is printed at the beginning of the build.
define heading
    $(python) -c "import blessings;                                                     \
                  import sys;                                                           \
                  from time import sleep;                                               \
                  sys.exit() if '$(heading_printed)' else None;                         \
                  unsafe = ' (unsafe)' if '$(unsafe_build)' == 'True' else '';          \
                  terminal = blessings.Terminal(force_styling=True);                    \
                  print(terminal.bold_yellow('Building modules' + unsafe), flush=True); \
                  sleep(0.1);                                                           \
                  "
    $(eval heading_printed = True)
endef

# Make all compiled Python modules.
# When finished, update time stamps so that all dependencies are
# synchronized (this is needed because .pxd files are only updated
# when their contents actually change. That is, `make pyfile.pxd` does
# not necessarily update the timestamp of pyfile.pxd, even though its
# rule is run. This makes .c (and therefore .o and .so) files
# dependent on such .pxd files not up-to-date). The types file is also
# only updated when its content actually changes.
all: $(addsuffix .so, $(pyfiles))
ifeq ($(MAKELEVEL),0)
	@$(MAKE) -s -t $@
endif
.PHONY: all

# Link object files into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	@$(call heading)
	$(CC) $< -o $@ $(LDFLAGS) $(LDLIBS)

# Compile C source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	@$(call heading)
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into C source files
# (and also produce the annotated .html file).
$(addsuffix .c, $(pyfiles)): %.c: %.pyx %.pxd
	@$(call heading)
	$(python) -m cython $(cythonflags) $<
# Same as above (for explicit builds of html)
$(addsuffix .html, $(pyfiles)): %.html: %.pyx %.pxd
	$(python) -m cython $(cythonflags) $<

# Write .pxd files from .pyx files together with the types file
# using the pyxpp script.
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx $(types)
	@$(call heading)
	$(python) -B $(pyxpp) $< $(commons) $(types)

# Write the types file from the .pyx files using the pyxpp script
$(types): $(addsuffix .pyx, $(pyfiles))
	@$(call heading)
	$(python) -B $(pyxpp) $@ $(commons) $(types) $(addsuffix .pyx, $(pyfiles))

# Write .pyx files from .py files using the pyxpp script
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py
	@$(call heading)
	$(python) -B $(pyxpp) $< $(commons)



###########################
# Additional dependencies #
###########################
# Target dependencies which strictly speaking should be
# taken into account, but can be ignored using the --unsafe-build flag.
ifneq ($(unsafe_build),True)
# Because modules cimport stuff from each other, some .c (and therefore
# also .html) files depend on the .pxd files of other modules.
# Unless unsafe_build is explicitly set to False,
# we let all .c and .html files depend on all .pxd files.
$(foreach ext,c html,$(addsuffix .$(ext), $(pyfiles))): $(addsuffix .pxd, $(pyfiles))
# Every module cimport everything from the commons module.
# The commons module is also needed when building the types file.
$(foreach ext,pyx pxd,$(addsuffix .$(ext), $(pyfiles))): $(commons)
$(types): $(commons)
# The pyxpp script is used to create .pyx files,
# .pxd files and the types file.
$(foreach ext,pyx pxd,$(addsuffix .$(ext), $(pyfiles))): $(pyxpp)
$(types): $(pyxpp)
# Let the bottom of the build chain depend on this makefile itself
$(addsuffix .pyx, $(pyfiles)): $(MAKEFILE_LIST)
endif
# Additional target dependencies
$(foreach ext,c html,$(addsuffix .$(ext), mesh)): fft.c



###################
# Cleanup targets #
###################
.PHONY: clean           \
	    clean_autosave  \
	    clean_auxiliary \
	    clean_logs      \
	    clean_output    \
	    clean_params_cp \
	    clean_tests     \
	    clean_utilities \
	    distclean
# Remove all compile files
clean:
	$(RM) -r $(foreach ext,pyc pyx pxd c html o so so_,\
		       $(addsuffix .$(ext), $(pyfiles))) $(types) __pycache__
# Remove files generated via autosave
clean_autosave:
	$(RM) $(ics_dir)/autosave_*
	$(RM) $(params_dir)/autosave_*
# Remove auxiliary files generated by running the program
clean_auxiliary:
	$(RM) $(files_auxiliary)
# Remove everything in the log directory
clean_logs:
	$(RM) -r $(logs_dir)/* $(logs_dir)/.[^.]*
# Remove everything in the output directory
clean_output:
	$(RM) -r $(output_dir)/* $(output_dir)/.[^.]*
# Remove parameter file copies
clean_params_cp:
	$(RM) $(params_dir)/.[^.]*
# Remove files produced by running tests
clean_tests:
	$(foreach clean_file,$(wildcard $(tests_dir)/*/clean),$(clean_file);)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) -r $(addprefix $(utilities_dir)/,$(files_utilities))
	$(RM) -r $(top_dir)/concept_backup $(top_dir)/tmp
# Remove all unnecessary files,
# leaving CO𝘕CEPT in a distribution ready state.
distclean: clean           \
	       clean_autosave  \
	       clean_auxiliary \
	       clean_logs      \
	       clean_output    \
	       clean_params_cp \
	       clean_tests     \
	       clean_utilities
