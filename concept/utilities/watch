#!/usr/bin/env bash

# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of CO𝘕CEPT can be contacted at
# jeppe.mosgaard.dakin(at)post.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# Running this script after submitting a remote job via PBS will print out the
# output of the code as it is being run. If multiple jobs are running or in
# queue, the latest will be watched. Alternatively, the job ID can be passed
# as the first argument when calling this script.
# You can run this script directly or by invoking the concept script with the
# --util watch
# option.

# Absolute paths to this file and its directory
this_file="$(readlink -f "${BASH_SOURCE[0]}")"
this_dir="$(dirname "${this_file}")"

# Set up error trapping
ctrl_c()
{
    trap : 0
    exit 2
}
abort()
{
    colorprint "An error occurred while using the \"$(basename ${this_file})\" utility!" "red"
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Source the concept script
source "${this_dir}/../concept"

# Exit if this script is not run remotely via ssh
if ([ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]); then
    colorprint "Error: Cannot watch remote job as you are working on a local machine" "red"
    exit 1
fi

# Get the jobid
if [ "$#" -lt 1 ]; then
    # Find the current (latest) jobid
    jobid=$(mj | grep ".in1" | awk '{print $1}')
    Njobs=$(echo "${jobid}" | wc -w)
    if [ "${Njobs}" == "0" ]; then
        echo "You currently have no jobs submitted"
        exit 0
    elif [ "${Njobs}" -gt 1 ]; then
        echo "You currently have ${Njobs} jobs submitted. The latest will be watched"
        jobid=$(echo "${jobid}" | awk -F'.in1' '{ print $1 }' | awk '{if($1>max) {max=$1}; count+=1} END {print max}')
    fi
else
    # The jobid was supplied as an argument
    jobid="$1"
fi
jobid="${jobid%.in1}"

# Check for unrequired positional arguments
if [ "$#" -gt 1 ]; then
    badvars=""
    for badvar in ${@:2}; do
        badvars="${badvars}, \"${badvar}\""
    done
    badvars="${badvars:2}"
    colorprint "Warning: The following arguments will be ignored by the $(basename ${this_file}) utility:" "red"
    colorprint "${badvars}" "red"
fi

# Function for continuous printout of the tail of logs/jobid
function read_tail()
{
    echo "Job ${jobid} is running"
    # Wait for logs/jobid to be created
    if [ ! -f "${concept_dir}/logs/${jobid}" ]; then
        sleep 10
        while :; do
            if [ -f "${concept_dir}/logs/${jobid}" ]; then
                break
            fi
            sleep 300
        done
    fi
    # Continuously print out the tail of logs/jobid
    echo
    tail -n 1000 -f "${concept_dir}/logs/${jobid}" &
    tail_pid=$!
    # Trap possible future Ctrl-C and make it kill above tail commands before exiting this script
    trap 'kill -9 $tail_pid; echo ; exit 130; echo ' SIGINT
    # Continue script until jobid is not listed as one of my jobs
    while :; do
        if [[ -z $(mj | grep "${jobid}") ]]; then
            sleep 10
            # Kill above tail command silently
            exec 3>&2; exec 2> /dev/null; kill ${tail_pid} >/dev/null 2>&1; sleep 1; exec 2>&3; exec 3>&-
            break
        fi
        sleep 300
    done
}

# Wait for execution of job, then call read_tail
if [[ -z $(je | grep "${jobid}") ]]; then
    # Job not running
    if [[ -z $(js | grep "${jobid}") ]]; then
        # Job not in progress
        cat "${concept_dir}/logs/${jobid}"
        exit 0
    else
        # Job is in queue
        echo "Job ${jobid} is queued"
        # Some time will always be spend in the queue
        sleep 20
        while :; do
            if [[ -n $(je | grep "${jobid}") ]]; then
                break
            fi
            sleep 1
            if [[ -z $(mj | grep "${jobid}") ]]; then
                # Job already done
                cat "${concept_dir}/logs/${jobid}"
                exit 0
            fi
            sleep 300
        done
        # Job running
        read_tail
    fi
else
    # Job running
    read_tail
fi

# Exit gracefully
trap : 0

