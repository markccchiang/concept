# It is exspedted that you call this makefile with the paramsfile=paramfile option.
# Otherwise $(params_default) will be used as parameterfile.

#############################################################################################################
# Specification of filenames                                                                                #
#############################################################################################################
# List of .py files which should be cythonized and compiled to modules
pyfiles = communication ewald graphics gravity integration IO mesh params species timeloop units
# The default parameterfile to use (never needed when invoked via the run script)
params_default = params/default
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# List of files generated by running the code, which should be deleted by distclean
files_generated = .ewald_gridsize* .fftw_wisdom_gridsize*

#############################################################################################################
# Environment information                                                                                   #
#############################################################################################################
anaconda_dir = ../anaconda
openmpi_dir  = ../openmpi
fftw_dir     = ../fftw
gsl_dir      = ../gsl
pyversion = $(shell $(anaconda_dir)/bin/python -c "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
python = $(anaconda_dir)/bin/python$(pyversion)
cython = $(anaconda_dir)/bin/cython

#############################################################################################################
# Compiling and linking                                                                                     #
#############################################################################################################
# Options passed when cynthonizing .pyx files
cythonflags = -3 -a -o
# Includes
anaconda_incl = -I$(anaconda_dir)/include/python$(pyversion)m
openmpi_incl  = -I$(openmpi_dir)/include
fftw_incl     = -I$(fftw_dir)/include
gsl_incl      = -I$(gsl_dir)/include
includes = $(anaconda_incl) $(openmpi_incl) $(fftw_incl) $(gsl_incl)
# Compiler options
CC = $(openmpi_dir)/bin/mpicc
mathoptimizations = -fassociative-math -fno-trapping-math -fno-signed-zeros  # Is this smart?
CFLAGS = -pthread -DNDEBUG -g -std=c99 -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC $(mathoptimizations) $(includes)
# Libraries to link
anaconda_libs = -L$(anaconda_dir)/lib -L$(python)m
openmpi_libs  = -L$(openmpi_dir)/lib -Wl,"-rpath=$(openmpi_dir)/lib" -lmpi
fftw_libs     = -L$(fftw_dir)/lib -Wl,"-rpath=$(fftw_dir)/lib" -lfftw3_mpi -lfftw3
gsl_libs      = -L$(gsl_dir)/lib -Wl,"-rpath=$(gsl_dir)/lib" -lgsl -lgslcblas
LDLIBS = $(anaconda_libs) $(openmpi_libs) $(fftw_libs) $(gsl_libs) -lm
# Linker options
LDFLAGS = -pthread -shared

#############################################################################################################
# Preprocessing                                                                                             #
#############################################################################################################
# If no paramsfile argument is supplied, the default parameterfile will be used
ifndef $(paramsfile)
    paramsfile=$(params_default)
endif
# Touches $(paramsfile) if the parameterfile passed as $(paramsfile) differ from the last run.
# This forces a recompilation. Here, 37 is 1 plus the length of the string
# "# The following is an exact copy of ", used in the params.py target.
IGNORE := $(shell if [ -f params.py ] && [ "$(paramsfile)" != "$(shell head -n 1 \
          params.py 2> /dev/null | cut -c 37-)" ] ; then touch "$(paramsfile)" ; fi)
# Update which $(pyfile) to compile in this recursion step
ifndef $(pyfile_nr)
    pyfile_nr=1
endif
pyfile = $(word $(pyfile_nr), $(pyfiles))

#############################################################################################################
# Implicit rules                                                                                            #
#############################################################################################################
# Automatic linking of .o files into .so files (the same as builtin implicit rule for .o to executable)
%.so : %.o
	$(CC) $(LDFLAGS) $< $(LOADLIBES) $(LDLIBS) -o $@

#############################################################################################################
# Targets begin here                                                                                        #
#############################################################################################################
# Make everything
all: recursive

#############################################################################################################
# Extra dependencies to any of the files                                                                    #
#############################################################################################################
# Timeloop should probably not be dependent on species.pxd in the end!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
gravity.c IO.c mesh.c timeloop.c communication.c: species.pxd
gravity.c: fft.c

#############################################################################################################
# This target cythonizes and compiles all .py files in $(pyfiles) recursively, passing $(pyfile_nr) down    #
# the recursions to keep track of the .py files                                                             #
#############################################################################################################
recursive: $(pyfile).so
	@if [ $(words $(pyfiles)) -gt $(pyfile_nr) ] ; then \
	    make --no-print-directory $@ paramsfile=$(paramsfile) pyfile_nr=$(shell $(python) -c "print($(pyfile_nr) + 1)") ;\
	fi

##############################################################################################################
# Targets handling the cythonizing, compiling and linking of an arbitrary .py file with basename $(pyfile)   #
##############################################################################################################
# Copy the specified parameterfile to params.py and inserts a header, telling which parameterfile it is a
# copy of. Also import everything from numpy and the units moddule in the header, enabling the use of math
# and units in parameter files
params.py: $(paramsfile)
	@echo
	@echo "Processing parameters from $(paramsfile)"
	@cp $(paramsfile) $@
	@sed -i '1i# The following is an exact copy of $(paramsfile)\
	from numpy import pi, e, sqrt, sin, cos, tan, arcsin, arccos, arctan, sinh, cosh, tanh, arcsinh, arccosh, arctanh, exp, log, log10, log2, abs, floor, ceil, arange, linspace\
	# Seperate but equivalent imports in pure Python and Cython\
	import cython\
	if not cython.compiled:\
	    # Import units from the non-compiled .py file\
	    import imp\
	    units = imp.load_source("units", "units.py")\
	    for key, value in units.__dict__.items():\
	        if isinstance(key, str):\
	            try:\
	                exec(key + "= value")\
	            except:\
	                pass\
	else:\
	    # Lines in triple quotes will be executed in the .pyx file\
	    """\
	    from units cimport *\
	    """\
	#Original parameter file below\n' $@
# Make a .pyx copy of the .py file with the cython_import triple quotes removed and a
# hard copy of the content of commons.py in place of 'from commons import *'.
# Other tweeks are performed by the .pyx preprocessor script as well.
$(pyfile).pyx: $(pyfile).py $(MAKEFILE_LIST) commons.py $(pyxpp)
	@printf "\n\033[1m\033[93mBuilding the $(pyfile) module\033[0m\n"  # Print module in progress in yellow
	cp $< $@
	@# Run the .pyx preprocessor on the .pyx file
	$(python) $(pyxpp) $@ $(paramsfile)
# Cythonize .pyx
$(pyfile).c: $(pyfile).pyx $(pyfile).pxd
	$(cython) $(cythonflags) $@ $<
# Compile .c to object file
$(pyfile).o: $(pyfile).c
# Perform linking and make Python module
$(pyfile).so: $(pyfile).o

#############################################################################################################
# Cleanup targets                                                                                           #
#############################################################################################################
# Remove all compiled files
clean:
	$(RM) -r $(addsuffix .pyx, $(pyfiles)) $(addsuffix .c, $(pyfiles)) $(addsuffix .o, $(pyfiles)) \
	$(addsuffix .html, $(pyfiles)) $(addsuffix .so, $(pyfiles)) params.py __pycache__
# Remove compiled modules only
clean_so:
	$(RM) $(addsuffix .so, $(pyfiles))
# Remove files produced by running tests
clean_tests:
	$(RM) -r tests/*.pdf tests/__pycache__ tests/ewaldforce_gadget.c tests/ewaldforce_gadget
# Remove files generated by running the program
clean_files_generated:
	$(RM) $(files_generated)
# Restore all unnecessary files, leaving the program in a distribution ready state
distclean: clean clean_tests clean_files_generated

