# This is the makefile for the CONCEPT code. Preferebly you should not interact
# with this file directly, but rather through the run script.
# It is exspedted that you call this makefile with the paramsfile=paramfile option.
# Otherwise $(params_default) will be used as parameterfile.

# Use the bash shell rather than sh
SHELL = /bin/bash


##############################
# Specification of filenames #
##############################
# List of .py files which should be cythonized and compiled to modules
pyfiles = communication ewald graphics gravity integration IO mesh params species timeloop units
# The default parameterfile to use (never needed when invoked via the run script)
params_default = params/default
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# List of files generated by running the code, which should be deleted by distclean
files_auxiliary = output logs __pycache__ jobscript .ewald_gridsize* .fftw_wisdom_gridsize*


################################################
# Environment information from the .paths file #
################################################
paths=$(shell this_dir="$$( cd "$$( dirname "$${BASH_SOURCE[0]}" )" && pwd )"; \
          curr="$${this_dir}"; \
          while [ 1 ]; do \
              if [ -f "$${curr}/.paths" ]; then \
                  paths="$${curr}/.paths"; \
                  break; \
              fi; \
              if [ "$${curr}" == "/" ]; then \
                  paths='fail'; \
                  break; \
              fi; \
              curr="`dirname \"$${curr}\"`"; \
          done; \
          echo "$${paths}")
ifeq ($(paths), fail)
    $(error Could not find .paths file)
endif
miniconda_dir  = $(shell source $(paths); echo $${miniconda_dir})
openmpi_dir   = $(shell source $(paths); echo $${openmpi_dir})
fftw_dir      = $(shell source $(paths); echo $${fftw_dir})
gsl_dir       = $(shell source $(paths); echo $${gsl_dir})
python        = $(shell source $(paths); echo $${python})
python_incl_m = $(shell source $(paths); echo $${python_incl_m})
cython        = $(shell source $(paths); echo $${cython})


#########################
# Compiling and linking #
#########################
# Options passed when cynthonizing .pyx files
cythonflags = -3 -a -o
# Includes
miniconda_incl = -I$(python_incl_m)
openmpi_incl  = -I$(openmpi_dir)/include
fftw_incl     = -I$(fftw_dir)/include
gsl_incl      = -I$(gsl_dir)/include
includes = $(miniconda_incl) $(openmpi_incl) $(fftw_incl) $(gsl_incl)
# Compiler options
CC = $(openmpi_dir)/bin/mpicc
mathoptimizations = -fassociative-math -fno-trapping-math -fno-signed-zeros  # Is this smart?
CFLAGS = -pthread -DNDEBUG -g -std=c99 -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC $(mathoptimizations) $(includes)
# Libraries to link
miniconda_libs = -L$(miniconda_dir)/lib -L$(python)m
openmpi_libs  = -L$(openmpi_dir)/lib -Wl,"-rpath=$(openmpi_dir)/lib" -lmpi
fftw_libs     = -L$(fftw_dir)/lib -Wl,"-rpath=$(fftw_dir)/lib" -lfftw3_mpi -lfftw3
gsl_libs      = -L$(gsl_dir)/lib -Wl,"-rpath=$(gsl_dir)/lib" -lgsl -lgslcblas
LDLIBS = $(miniconda_libs) $(openmpi_libs) $(fftw_libs) $(gsl_libs) -lm
# Linker options
LDFLAGS = -pthread -shared


#################
# Preprocessing #
#################
# If no paramsfile argument is supplied, the default parameterfile will be used
ifndef $(paramsfile)
    paramsfile=$(params_default)
endif
# Touches $(paramsfile) if the parameterfile passed as $(paramsfile) differ from the last run.
# This forces a recompilation. Here, 37 is 1 plus the length of the string
# "# The following is an exact copy of ", used in the params.py target.
IGNORE := $(shell if [ -f params.py ] && [ "$(paramsfile)" != "$(shell head -n 1 \
          params.py 2> /dev/null | cut -c 37-)" ] ; then touch "$(paramsfile)" ; fi)
# Update which $(pyfile) to compile in this recursion step
ifndef $(pyfile_nr)
    pyfile_nr=1
endif
pyfile = $(word $(pyfile_nr), $(pyfiles))


##################
# Implicit rules #
##################
# Automatic linking of .o files into .so files (the same as builtin implicit rule for .o to executable)
%.so : %.o
	$(CC) $(LDFLAGS) $< $(LOADLIBES) $(LDLIBS) -o $@


######################
# Targets begin here #
######################
# Make everything
all: recursive


##########################################
# Extra dependencies to any of the files #
##########################################
# Timeloop should probably not be dependent on species.pxd in the end!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
gravity.c IO.c mesh.c timeloop.c communication.c: species.pxd
gravity.c: fft.c


##########################################################################################################
# This target cythonizes and compiles all .py files in $(pyfiles) recursively, passing $(pyfile_nr) down #
# the recursions to keep track of the .py files                                                          #
##########################################################################################################
recursive: $(pyfile).so
	@if [ $(words $(pyfiles)) -gt $(pyfile_nr) ] ; then \
	    make --no-print-directory $@ paramsfile=$(paramsfile) pyfile_nr=$(shell $(python) -c "print($(pyfile_nr) + 1)") ;\
	fi


############################################################################################################
# Targets handling the cythonizing, compiling and linking of an arbitrary .py file with basename $(pyfile) #
############################################################################################################
# Copy the specified parameterfile to params.py and inserts a header, telling which parameterfile it is a
# copy of. Also include imports of some useful numpy functions and constants, imports of everything from the
# units moddule and all paths from .path file in the header, enabling the use of math, units and absolute
# paths in parameter files.
params.py: $(paramsfile)
	@echo
	@echo "Processing parameters from $(paramsfile)"
	@cp $(paramsfile) $@
	@sed -i '1i# The following is an exact copy of $(paramsfile)\
	# Import useful numpy functions and constants\
	from numpy import abs, arange, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, ceil, cos, cosh, e, exp, floor, linspace, loadtxt, log, log10, log2, pi, sqrt, sin, sinh, tan, tanh\
	# Get access to the absolute paths stored in the .paths file\
	import os, imp\
	top_dir = "."\
	ls_prev = []\
	possible_root_dir = 0\
	while True:\
	    ls = os.listdir(top_dir)\
	    possible_root_dir = (possible_root_dir + 1) if ls == ls_prev else 0\
	    if possible_root_dir == 3:  # 3 ../ and still the same files. "Must" be /.\
	        raise Exception("Cannot find the .paths file!")\
	    if ".paths" in ls:\
	        break\
	    top_dir = "../" +  top_dir\
	    ls_prev = ls\
	paths_module = imp.load_source("paths", top_dir + "/.paths")\
	paths = paths_module.__dict__\
	# Seperate but equivalent imports in pure Python and Cython\
	import cython\
	if not cython.compiled:\
	    # Import units from the non-compiled .py file\
	    units = imp.load_source("units", "units.py")\
	    for key, value in units.__dict__.items():\
	        if isinstance(key, str):\
	            try:\
	                exec(key + "= value")\
	            except:\
	                pass\
	else:\
	    # Lines in triple quotes will be executed in the .pyx file\
	    """\
	    from units cimport *\
	    """\
	#Original parameter file below\n' $@
# Make a .pyx copy of the .py file with the cython_import triple quotes removed and a
# hard copy of the content of commons.py in place of 'from commons import *'.
# Other tweeks are performed by the .pyx preprocessor script as well.
$(pyfile).pyx: $(pyfile).py commons.py $(pyxpp) $(MAKEFILE_LIST) $(paths)
	@printf "\n\033[1m\033[93mBuilding the $(pyfile) module\033[0m\n"  # Print module in progress in yellow
	cp $< $@
	@# Run the .pyx preprocessor on the .pyx file
	$(python) $(pyxpp) $@ $(paramsfile)
# Cythonize .pyx
$(pyfile).c: $(pyfile).pyx $(pyfile).pxd
	$(cython) $(cythonflags) $@ $<
# Compile .c to object file
$(pyfile).o: $(pyfile).c
# Perform linking and make Python module
$(pyfile).so: $(pyfile).o


###################
# Cleanup targets #
###################
# Remove all compiled files
clean:
	$(RM) -r $(addsuffix .pyx, $(pyfiles)) $(addsuffix .c, $(pyfiles)) $(addsuffix .o, $(pyfiles)) \
	$(addsuffix .html, $(pyfiles)) $(addsuffix .so, $(pyfiles)) params.py
# Remove compiled modules only
clean_so:
	$(RM) $(addsuffix .so, $(pyfiles))
# Remove files produced by running tests
clean_tests:
	$(addsuffix ;, $(shell find tests/ -type f -name 'clean'))
# Remove files generated by running the program
clean_auxiliary:
	$(RM) -r $(files_auxiliary)
# Restore all unnecessary files, leaving the program in a distribution ready state
distclean: clean clean_tests clean_auxiliary

