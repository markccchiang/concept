#!/usr/bin/env bash

# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015-2017 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The author of CO𝘕CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# Running this script after submitting a remote job via PBS will print
# out the output of the code as it is being run. If multiple jobs are
# running or in queue, the latest will be watched.
# Alternatively, the job ID can be passed as the first argument when
# calling this script.
# You can run this file directly as
# utilities/watch [jobid]
# or invoke it via the concept script as
# ./concept --util watch [jobid]



# Absolute paths to this file and its directory
this_file="$(readlink -f "${BASH_SOURCE[0]}")"
this_dir="$(dirname "${this_file}")"

# Source the concept script
source "${this_dir}/../concept"

# Set up error trapping
ctrl_c()
{
    # Kill the tail command silently before exiting
    if [ -n "${tail_pid}" ]; then
        exec 3>&2
        exec 2>/dev/null
        kill -SIGKILL ${tail_pid} >/dev/null 2>&1 || :
        sleep 0.1
        exec 2>&3
        exec 3>&-
    fi
    trap : 0
    exit 2
}
abort()
{
    # Kill the tail command silently before exiting
    if [ -n "${tail_pid}" ]; then
        exec 3>&2
        exec 2>/dev/null
        kill -SIGKILL ${tail_pid} >/dev/null 2>&1 || :
        sleep 0.1
        exec 2>&3
        exec 3>&-
    fi
    colorprint "An error occurred while using the \"$(basename "${this_file}")\" utility!" "red"
    exit 1
}
if [ "${called_from_concept}" == "True" ]; then
    trap 'ctrl_c' SIGINT
    trap 'abort' EXIT
    set -e
fi

# Use Python's argparse module to handle command-line arguments
args=$("${python}" -B -c "
import argparse, sys
# Setup command-line arguments
parser = argparse.ArgumentParser(prog='$(basename "${this_file}")',
                                 description='Run the CO𝘕CEPT $(basename "${this_file}") utility')
parser.add_argument('jobid',
                    default='__none__',
                    help='jobid of the submitted CO𝘕CEPT PBS job to watch',
                    nargs='?',
                    )
# Enables Python to write directly to screen (stderr)
# in case of help request.
stdout_copy = sys.stdout
sys.stdout = sys.stderr
# Now do the actual argument parsing,
# including writing out the help message.
if '${called_from_concept}' == 'True':
    # Called from concept - Throw exception on illegal args
    args = parser.parse_args()
else:
    # Called directly - Allow what appears to be illegal args
    # (these might be known to the concept script).
    args, unknown_args = parser.parse_known_args()
# Reset stdout
sys.stdout = stdout_copy
# Print out the arguments.
# These will be captured in the Bash 'args' variable.
print('argparse_finished=yes')
print('jobid={}'.format(args.jobid))
" "$@" || :)
# Evaluate the handled arguments into this scope
eval "${args}"
# Exit if argparse exited without finishing
if [ "${argparse_finished}" != "yes" ]; then
    trap : 0
    exit 0
fi

# If not called indirectly through the concept script,
# call the concept script now.
if [ "${called_from_concept}" != "True" ]; then
    "${concept}" --util "${this_file}" "$@"
    trap : 0
    exit 0
fi

# Exit if this script is not run remotely via ssh
if ([ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]); then
    colorprint "Error: Cannot watch remote job as you are working on a local machine" "red"
    exit 1
fi

# Check for the qstat command
qstat_path="$(which qstat 2> /dev/null || :)"
if [ -z "${qstat_path}" ]; then
    colorprint "Error: Could not find the \"qstat\" command. Is PBS installed and on the PATH?" "red"
    exit 1
fi

# Get the username. As at least some PBS implementations enforce a
# maximum username length of 15 characters,
# truncate the username to 15 characters.
my_username="$(whoami)"
my_username="${my_username:0:15}"

# Aquire information about submitted jobs.
# Revert the output of qstat, so that the newest jobs are in the top.
qstat_info="$(qstat | tac)"

# Function that update the state variable by running the qstat command
update_job_info()
{
    # Remove possible suffix on jobid
    jobid="${jobid%.*}"
    # Aquire information about submitted jobs.
    # Revert the output of qstat,
    # so that the newest jobs are in the top.
    qstat_info="$(qstat | tac)"
    # Reset the state variable
    state="None"
    # Iterate through qstat output
    while read -r line; do
        jobid_line="$(echo "${line}" | awk '{print $1}')"
        jobid_line="${jobid_line%.*}"
        if [ ${jobid_line} == ${jobid} ]; then
            # Submitted job with matching jobid found
            username="$(echo "${line}" | awk '{print $3}')"
            username="${username:0:15}"
            if [ "${username}" != "${my_username}" ]; then
                colorprint "Job ${jobid} does not belong to you" "red"
                exit 1
            fi
            if ! echo "${line}" | grep "CONCEPT" > "/dev/null"; then
                colorprint "Job ${jobid} is not a CO𝘕CEPT job" "red"
                exit 1
            fi
            state="$(echo "${line}" | awk '{print $5}')"
            queue="$(echo "${line}" | awk '{print $6}')"
            break
        fi
    done <<< "${qstat_info}"
}

# If the jobid was not given as an argument, find the CO𝘕CEPT job
# which were submitted last. If an argument (the jobid) is given,
# find information about the job.
if [ "${jobid}" == "__none__" ]; then
    # Aquire information about all submitted jobs
    qstat_info="$(qstat)"
    # Find all jobs submitted by the user. Keep only the latest one
    Njobs=0
    while read -r line; do
        username="$(echo "${line}" | awk '{print $3}')"
        username="${username:0:15}"
        if [ "${username}" == "${my_username}" ]; then
            jobname="$(echo "${line}" | awk '{print $2}')"
            if [[ "${jobname}" == *"CONCEPT"* ]]; then
                # CO𝘕CEPT job submitted by the user found
                ((Njobs += 1))
                jobid="$(echo "${line}" | awk '{print $1}')"
                state="$(echo "${line}" | awk '{print $5}')"
                queue="$(echo "${line}" | awk '{print $6}')"
            fi
        fi
    done <<< "${qstat_info}"
    if [ ${Njobs} == 0 ]; then
        colorprint "Error: You currently have no CO𝘕CEPT jobs submitted" "red"
        exit 1
    elif [ ${Njobs} -gt 1 ]; then
        printf "You currently have ${Njobs} CO𝘕CEPT jobs submitted.\n"
        printf "The latest will be watched\n"
        sleep 1
    fi
    # Remove possible suffix on jobid
    jobid="${jobid%.*}"
else
    jobid="$1"
    # Remove possible suffix on jobid
    jobid="${jobid%.*}"
    update_job_info
    if [ "${state}" == "None" ]; then
        # Job not in progress
        if [ -f "${logs_dir}/${jobid}" ]; then
            cat "${logs_dir}/${jobid}"
            trap : 0
            exit 0
        else
            colorprint "Error: Job ${jobid} is not running and no matching log found" "red"
            exit 1
        fi
    fi
fi

# Functin for printing changes to the job state
state_last=""
inform_on_new_state()
{
    if [ "${state}" != "${state_last}" ]; then
        case "${state}" in
            "C"    ) echo "Job ${jobid} is completed after having run";;
            "E"    ) echo "Job ${jobid} is exiting after having run";;
            "H"    ) echo "Job ${jobid} is held";;
            "Q"    ) echo "Job ${jobid} is queued in ${queue}";;
            "R"    ) echo "Job ${jobid} is running in queue ${queue}";;
            "T"    ) echo "Job ${jobid} is being moved to new location";;
            "W"    ) echo "Job ${jobid} is waiting for its executing time to be reached";;
            "S"    ) echo "Job ${jobid} is suspend";;
            "None" ) echo "Job ${jobid} has finished running";;
            ""     ) echo "Job ${jobid} is in an unspecified state";;
            *      ) echo "Job ${jobid} is in the unknown state \"${state}\"";;
        esac
        state_last="${state}"
    fi
}

# Function for checking if the job suddenly finished.
# Do not call this function after beginning reading the logfile.
check_suddenly_finished()
{
    update_job_info
    inform_on_new_state
    # If the job is already finished, printout the entire log and exit
    if [ "${state}" == "None" ]; then
        if [ -f "${logs_dir}/${jobid}" ]; then
            cat "${logs_dir}/${jobid}"
        else
            echo "Job ${jobid} has finished running, but no logfile is to be found. Curious ..."
        fi
        trap : 0
        exit 0
    fi
}

# Sleep durations in seconds
sleep_little=30
sleep_much=300

# Print initial state of job
inform_on_new_state

# Wait until job is running
if [ "${state}" != "R" ]; then
    # Wait a small time before calling qstat again
    sleep ${sleep_little}
    check_suddenly_finished
    while [ "${state}" != "R" ] ; do   
        # Wait a long time before calling qstat again
        sleep ${sleep_much}
        check_suddenly_finished
    done
fi
state_last="R"

# Job running. Wait for logfile to be created
slept=0
while [ ! -f "${logs_dir}/${jobid}" ]; do
    sleep ${sleep_little}
    # After having slept for a long time, check that the job
    # has not just finished without producing a log file.
    ((slept += ${sleep_little}))
    if [ ${slept} -ge ${sleep_much} ]; then
        check_suddenly_finished
        slept=0
    fi
done

# Logfile created. Continuously print out its tail until end of job
echo
cat "${logs_dir}/${jobid}"
tail -n 0 --follow --sleep-interval=${sleep_little} "${logs_dir}/${jobid}" &
tail_pid=$!
update_job_info
inform_on_new_state
if [ "${state}" != "None" ]; then
    # Wait a small time before calling qstat again
    sleep ${sleep_little}
    update_job_info
    inform_on_new_state
    while [ "${state}" != "None" ]; do
        # Wait a long time before calling qstat again
        sleep ${sleep_much}
        update_job_info
        inform_on_new_state
    done
fi

# Kill the tail command silently before exiting
if [ -n "${tail_pid}" ]; then
    sleep ${sleep_little}
    exec 3>&2
    exec 2>/dev/null
    kill -SIGKILL ${tail_pid} >/dev/null 2>&1 || :
    sleep 0.1
    exec 2>&3
    exec 3>&-
fi

# Exit gracefully
trap : 0

