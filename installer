#!/bin/bash

# Run this script to download and install the CONCEPT code by Jeppe Dakin
# with all dependencies. If run without an argument, it will prompt for
# an installation directory. This can also be passed as an argument.
# You can also download and run this script via the following command:
# bash <(wget -O- --no-ch tiny.cc/nbody)
# The above uses a URL shortener. If it does not work, use the full URL:
# https://raw.githubusercontent.com/jmd-dk/concept/master/installer

# A small pause is needed when executing as the result of wget,
# if installation directory is not supplied as an argument.
sleep 1

# Set up error trapping
ctrl_c()
{
    trap : 0
    exit 2
}
abort()
{
    printf "\n\e[1m\e[91mAn error occurred during ${current_step}!\e[0m\n" >&2
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Creating top level directory
current_step="setup of top level directory"
printf "This is the installation script to CO\e[3mN\e[0mCEPT,
the cosmological \e[3mN\e[0m-body code by Jeppe Dakin.\n\n"
if [ -z "${1}" ]; then
    read -p "Where should I install the code?`echo $'\n> '`" -e top_dir
else 
    top_dir="${1}"
fi
top_dir="${top_dir//[ ]/\\ }"        # Places backslashes before spaces. These are needed when expanding tilde, but they will not persist!
eval top_dir="${top_dir}"            # Expand tilde
top_dir=$(readlink -f "${top_dir}")  # Convert to absolute path
echo "The code will be installed in ${top_dir}"
mkdir -p "${top_dir}"
cd "${top_dir}"

# Specify installation directories
concept_dir="${top_dir}/concept"
miniconda_dir="${top_dir}/miniconda"
fftw_dir="${top_dir}/fftw"
gadget_dir="${top_dir}/gadget"
fftw_for_gadget_dir="${gadget_dir}/fftw"
gsl_dir="${top_dir}/gsl"
hdf5_dir="${top_dir}/hdf5"
openmpi_dir="${top_dir}/openmpi"

# URL's to the latest stable versions of the different software
current_step="setup of dependency versions and download URL's"
echo -e "\nSearching for latest versions of dependencies"
# Function for checking that a given url actually exists
function validate_url(){
    text=$(wget -S --spider "${1}" 2>&1)
    text_http=$(echo "${text}" | grep "HTTP/1.1 200 OK")
    text_ftp=$(echo "${text}" | grep "Can't check for file existence")
    if [ -n "${text_http}" ] || ([[ "${1}" == "ftp://"* ]] && [ -z "${text_ftp}" ]); then
        echo 1
    else
        echo 0
    fi
}
# Miniconda (3.7.0 with Python 3.4 is known to work)
miniconda_version=$(wget -q -O- --no-check-certificate "http://repo.continuum.io/miniconda/.files.json" | grep -o -P "(?<=Miniconda3-).*(?=-Linux-x86_64)" || echo "")
miniconda_version=$(echo ${miniconda_version} | awk '{print $(NF-1)}')
if [ -z "${miniconda_version}" ]; then
    echo "Could not identify the version number of the latest Miniconda."
    miniconda_version="..."
fi
miniconda_url="http://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh"
if [ $(validate_url "${miniconda_url}") -eq 0 ]; then
    echo "Error: The Miniconda link is broken!"
    exit 1
fi
# The Python version. Python will be updated to the newest stable version by Conda, though this version may not yet be listed on their website.
# Note that this variable will be overwritten later!
python_version=$(wget -q -O- --no-check-certificate "https://www.python.org/downloads/" | grep -o -P "(?<=Python-).*(?=.tar.xz)" | head -1  || echo "")
if [ -z "${python_version}" ]; then
    echo "Could not identify the version number of the latest Python."
    python_version="..."
fi
# Version of Python packages in the Conda package manager
miniconda_pkgdocs="..."
cython_version="..."
matplotlib_version="..."
numpy_version="..."
pillow_version="..."
scipy_version="..."
# Pexpect is not listed on the Anaconda website, but it is included
pexpect_version="..."
# GSL (1.16 is known to work)
gsl_version=$(wget -q -O- --no-check-certificate "http://mirrors.dotsrc.org/gnu/gsl/" | grep -o -P "(?<=gsl-[0-9]).*(?=.tar.gz)" || echo "")
gsl_version="${gsl_version##*gsl-}"
if [ -z "${gsl_version}" ]; then
    echo "Could not identify the version number of the latest GSL."
    gsl_version="..."
fi
gsl_url="http://mirrors.dotsrc.org/gnu/gsl/gsl-latest.tar.gz"
if [ $(validate_url "${gsl_url}") -eq 0 ]; then
    echo "Error: The GSL link is broken!"
    exit 1
fi
# Cython_GSL (0.2.1 is known to work)
cython_gsl_version=$(wget -q -O- --no-check-certificate "https://raw.githubusercontent.com/twiecki/CythonGSL/master/README.rst" | grep ":Version:" | awk '{print $NF}' || echo "")
if [ -z "${cython_gsl_version}" ]; then
    echo "Could not identify the version number of the latest Cython_GSL."
    cython_gsl_version="..."
fi
cython_gsl_url="https://github.com/twiecki/CythonGSL/archive/master.tar.gz"
if [ $(validate_url "${cython_gsl_url}") -eq 0 ]; then
    echo "Error: The Cython_GSL link is broken!"
    exit 1
fi
# Open MPI (1.8.3 is known to work)
openmpi_version=$(wget -q -O- --no-check-certificate "http://www.open-mpi.org/software/" | grep -m 1 -o -P "(?<=Version).*(?=<)" || echo "")
openmpi_version=${openmpi_version//[[:blank:]]/}
if [ -z "${openmpi_version}" ]; then
    echo "Could not identify the version number of the latest Open MPI."
    openmpi_version="..."
fi
openmpi_url="http://www.open-mpi.org/software/ompi/v${openmpi_version%.*}/downloads/openmpi-${openmpi_version}.tar.bz2"
if [ $(validate_url "${openmpi_url}") -eq 0 ]; then
    echo "Error: The Open MPI link is broken!"
    exit 1
fi
# MPI4Py (1.3.1 is known to work)
mpi4py_version=$(wget -q -O- --no-check-certificate "https://bitbucket.org/mpi4py/mpi4py/downloads/" | grep -m 1 -o -P "(?<=mpi4py/get/).*(?=.tar.gz)" || echo "")
if [ -z "${mpi4py_version}" ]; then
    echo "Could not identify the version number of the latest MPI4Py."
    mpi4py_version="..."
fi
mpi4py_url="https://bitbucket.org/mpi4py/mpi4py/get/${mpi4py_version}.tar.gz"
if [ $(validate_url "${mpi4py_url}") -eq 0 ]; then
    echo "Error: The MPI4Py link is broken!"
    exit 1
fi
# HDF5 (1.8.14 is known to work)
hdf5_version=$(wget -q -O- --no-check-certificate "ftp://ftp.hdfgroup.org/HDF5/current/src/" | grep -m 1 -o -P "(?<=hdf5-).*(?=.tar.bz2\")" || echo "")
if [ -z "${hdf5_version}" ]; then
    echo "Could not identify the version number of the latest HDF5."
    hdf5_version="..."
fi
hdf5_url="ftp://ftp.hdfgroup.org/HDF5/current/src/hdf5-${hdf5_version}.tar.bz2"
if [ $(validate_url "${hdf5_url}") -eq 0 ]; then
    echo "Error: The HDF5 link is broken!"
    exit 1
fi
# h5py (2.4.0 is known to work)
h5py_version=$(wget -q -O- --no-check-certificate "https://pypi.python.org/pypi/h5py/#downloads" | grep -m 1 -o -P "(?<=h5py/).*(?=\"\>h5py)" || echo "")
if [ -z "${h5py_version}" ]; then
    echo "Could not identify the version number of the latest H5Py."
    h5py_version="..."
fi
h5py_url="https://pypi.python.org/packages/source/h/h5py/h5py-${h5py_version}.tar.gz"
if [ $(validate_url "${h5py_url}") -eq 0 ]; then
    echo "Error: The H5Py link is broken!"
    exit 1
fi
# FFTW (3.3.4 is known to work)
fftw_version=$(wget -q -O- --no-check-certificate "http://www.fftw.org/download.html" | grep -m 1 -o -P "(?<=fftw-).*(?=.tar.gz\")" || echo "")
if [ -z "${fftw_version}" ]; then
    echo "Could not identify the version number of the latest FFTW."
    fftw_version="..."
fi
fftw_url="http://www.fftw.org/fftw-${fftw_version}.tar.gz"
if [ $(validate_url "${fftw_url}") -eq 0 ]; then
    echo "Error: The FFTW link is broken!"
    exit 1
fi
# CONCEPT
concept_version="..."
concept_url="https://github.com/jmd-dk/concept/archive/master.tar.gz"
if [ $(validate_url "${concept_url}") -eq 0 ]; then
    printf "Error: The CO\e[3mN\e[0mCEPT link is broken!\n"
    exit 1
fi
# FFTW 2.1.5 for Gadget
fftw_for_gadget_version="2.1.5"
fftw_for_gadget_url="http://www.fftw.org/fftw-${fftw_for_gadget_version}.tar.gz"
if [ $(validate_url "${fftw_for_gadget_url}") -eq 0 ]; then
    echo "Error: The FFTW for GADGET link is broken!"
    exit 1
fi
# Gadget2
gadget_version="2.0.7"
gadget_url="http://www.mpa-garching.mpg.de/gadget/gadget-${gadget_version}.tar.gz"
if [ $(validate_url "${gadget_url}") -eq 0 ]; then
    echo "Error: The GADGET link is broken!"
    exit 1
fi

# Write out installation overview
printf "\n\e[1m\e[93mInstallation overview\e[0m\n"
printf "The following software will be installed\n"
printf "Name:\t\tVersion:\tPath:\n"
printf "CO\e[3mN\e[0mCEPT\t\t${concept_version}\t\t${concept_dir}\n"
printf "Miniconda\t${miniconda_version}\t\t${miniconda_dir}\n"
printf "  Cython\t${cython_version}\n"
printf "  Cython_GSL\t${cython_gsl_version}\n"
printf "  Matplotlib\t${matplotlib_version}\n"
printf "  MPI4Py\t${mpi4py_version}\n"
printf "  Numpy\t\t${numpy_version}\n"
printf "  Pexpect\t${pexpect_version}\n"
printf "  Pillow\t${pillow_version}\n"
printf "  Python\t${python_version}\n"
printf "  SciPy\t\t${scipy_version}\n"
printf "FFTW\t\t${fftw_version}\t\t${fftw_dir}\n"
printf "FFTW\t\t${fftw_for_gadget_version}\t\t${fftw_for_gadget_dir}\n"
printf "GADGET\t\t${gadget_version}\t\t${gadget_dir}\n"
printf "GSL\t\t${gsl_version}\t\t${gsl_dir}\n"
printf "HDF5\t\t${hdf5_version}\t\t${hdf5_dir}\n"
printf "Open MPI\t${openmpi_version}\t\t${openmpi_dir}\n"
sleep 5


################################################################
# Installing CONCEPT dependencies and download the code itself #
################################################################
# Miniconda
current_step="installation of Miniconda"
printf "\n\e[1m\e[93mInstalling Miniconda\e[0m\n"
wget -c -O miniconda.sh --no-check-certificate "${miniconda_url}"
bash miniconda.sh -b -p "${miniconda_dir}"
rm miniconda.sh
# Update Conda
"${miniconda_dir}/bin/conda" update --yes conda
# Create a python variable, storing the path to the newly installed Python interpreter
python_version=`"${miniconda_dir}/bin/python" -c "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))"`
python="${miniconda_dir}/bin/python${python_version}"
# Cython, Matplotlib, NumPy, Pexpect, Pillow and SciPy via Conda
current_step="installation of Cython, Matplotlib, NumPy, Pexpect and SciPy"
printf "\n\e[1m\e[93mInstalling Cython, Matplotlib, NumPy, Pexpect and SciPy\e[0m\n"
"${miniconda_dir}/bin/conda" install --yes cython matplotlib numpy pexpect pillow scipy
# Update all packages in Miniconda
"${miniconda_dir}/bin/conda" update --yes --all
# Do some cleanup in the Miniconda distribution
"${miniconda_dir}/bin/conda" clean --yes -i -l -t -p

# GSL
current_step="installation of GSL"
printf "\n\e[1m\e[93mInstalling GSL\e[0m\n"
mkdir "${gsl_dir}"
mkdir tmp
cd tmp
wget -c -O gsl.tar.gz --no-check-certificate "${gsl_url}"
tar xf gsl.tar.gz
cd gsl*
./configure --prefix="${gsl_dir}"
make
make install
cp COPYING README "${gsl_dir}"
cd ../../
rm -rf tmp

# The cython_gsl Python package
current_step="installation of Cython_GSL"
printf "\n\e[1m\e[93mInstalling Cython_GSL\e[0m\n"
wget -c -O CythonGSL.tar.gz --no-check-certificate "${cython_gsl_url}"
tar xf CythonGSL.tar.gz
cd CythonGSL*
export LD_LIBRARY_PATH="${gsl_dir}/lib:$LD_LIBRARY_PATH"
"${python}" setup.py build
"${python}" setup.py install
cd ..
rm -rf CythonGSL*

# Open MPI
current_step="installation of Open MPI"
printf "\n\e[1m\e[93mInstalling Open MPI\e[0m\n"
mkdir "${openmpi_dir}"
mkdir tmp
cd tmp
wget -c -O openmpi.tar.bz2 --no-check-certificate "${openmpi_url}"
tar xjf openmpi.tar.bz2
cd openmpi*
./configure --prefix="${openmpi_dir}"
make all
make install
cp LICENSE README "${openmpi_dir}"
cd ../../
rm -rf tmp

# The mpi4py Python package (cannot use conda, as it installs an outdated version)
current_step="installation of MPI4Py"
printf "\n\e[1m\e[93mInstalling MPI4Py\e[0m\n"
wget -c -O mpi4py.tar.gz --no-check-certificate "${mpi4py_url}"
tar xf mpi4py.tar.gz
cd mpi4py*
export LD_LIBRARY_PATH="${openmpi_dir}/lib":"$LD_LIBRARY_PATH"
export MPICC="${openmpi_dir}/bin/mpicc"
"${python}" setup.py install
cd ..
rm -rf mpi4py*

# HDF5
current_step="installation of HDF5"
printf "\n\e[1m\e[93mInstalling HDF5\e[0m\n"
mkdir tmp
cd tmp
wget -c -O hdf5.tar.bz2 --no-check-certificate "${hdf5_url}"
tar xjf hdf5.tar.bz2
cd hdf5*
CC="${openmpi_dir}/bin/mpicc" ./configure --enable-shared --enable-parallel --prefix="${hdf5_dir}"
make
make install
cp COPYING README.txt "${hdf5_dir}"
cd ../../
rm -rf tmp

# The h5py Python package (cannot use conda, as it does not install the parallel version)
current_step="installation of h5py"
printf "\n\e[1m\e[93mInstalling h5py\e[0m\n"
wget -c -O h5py.tar.gz --no-check-certificate "${h5py_url}"
tar xf h5py.tar.gz
cd h5py*
export CC="${openmpi_dir}/bin/mpicc"
"${python}" setup.py configure --mpi --hdf5="${hdf5_dir}"
"${python}" setup.py build
"${python}" setup.py install
cd ..
rm -rf h5py*

# FFTW
current_step="installation of FFTW"
printf "\n\e[1m\e[93mInstalling FFTW\e[0m\n"
mkdir tmp
cd tmp
wget -c -O fftw.tar.gz "${fftw_url}"
tar xf fftw.tar.gz
cd fftw*
# Double-precision
CC="${openmpi_dir}/bin/mpicc" MPICC="${openmpi_dir}/bin/mpicc" CFLAGS="-O3 -fPIC" CPPFLAGS="-I/${openmpi_dir}/include" LDFLAGS="-L${openmpi_dir}/lib" MPILIBS=-lmpi ./configure --enable-shared --enable-mpi --enable-openmp --enable-threads --prefix="${fftw_dir}"
make
make install
# Single-precision goes here ..........................
cp COPYING README "${fftw_dir}"
cd ../../
rm -rf tmp

# The CONCEPT code
current_step="installation of CO\e[3mN\e[0m\e[1m\e[91mCEPT"
printf "\n\e[1m\e[93mInstalling CO\e[3mN\e[0m\e[1m\e[93mCEPT\e[0m\n"
wget -c -O concept.tar.gz --no-check-certificate "${concept_url}"
tar xf concept.tar.gz
rm concept.tar.gz
mv concept-master/* "${top_dir}"  # This leaves the .paths file behind in the concept-master folder
rm -r concept-master

# Create the .paths file, storing important paths used by the program
current_step="creataion of the .paths file"
printf "\nWriting paths to .paths\n"
Gadget2_dir="${gadget_dir}/Gadget2"
cython="${miniconda_dir}/bin/cython"
mpicc="${openmpi_dir}/bin/mpicc"
mpiexec="${openmpi_dir}/bin/mpiexec"
python_incl_m="${miniconda_dir}/include/python${python_version}m"
run="${concept_dir}/run"
tests_dir="${concept_dir}/tests"
echo "# This file contains absolute paths to directories and files used by the
# program. You must manually edit the paths below. All other files rely on
# these paths, as they are not given anywhere else.

###############
# Directories #
###############
# Directory containing the GADGET2 source code
Gadget2_dir='${Gadget2_dir}'
# Directory containing the CONCEPT source code
concept_dir='${concept_dir}'
# Directory of the Miniconda Python distribution
mini_dir='${miniconda_dir}'
# Directory of FFTW
fftw_dir='${fftw_dir}'
# Directory of FFTW2, used by GADGET
fftw_for_gadget_dir='${fftw_for_gadget_dir}'
# Directory of Gadget2
gadget_dir='${gadget_dir}'
# Directory of GSL
gsl_dir='${gsl_dir}'
# Directory of HDF5
hdf5_dir='${hdf5_dir}'
# Directory of MPI
openmpi_dir='${openmpi_dir}'
# Directory containing tests for the CONCEPT code
tests_dir='${tests_dir}'
# Top level directory, containing e.g. README.md
top_dir='${top_dir}'

#########
# Files #
#########
# The Python3 interpreter
python='${python}'
# The python3.xm file within the include directory of Miniconda
python_incl_m='${python_incl_m}'
# The Cython executable
cython='${cython}'
# The MPI C compiler
mpicc='${mpicc}'
# The MPI executable
mpiexec='${mpiexec}'
# The run script of the CONCEPT code
run='${run}'
" > "${top_dir}/.paths"


######################################################
# Install GADGET2, used for testing the CONCEPT code #
######################################################
# FFTW 2.1.5 (GADGET2 is incompatible with FFTW 3.x)
current_step="installation of FFTW2 used by GADGET"
printf "\n\e[1m\e[93mInstalling FFTW2, used by GADGET\e[0m\n"
mkdir tmp
cd tmp
wget -c -O fftw.tar.gz "${fftw_for_gadget_url}"
tar xf fftw.tar.gz
cd fftw*
# Double-precision
CC="${openmpi_dir}/bin/mpicc" MPICC="${openmpi_dir}/bin/mpicc" CFLAGS="-O3 -fPIC" CPPFLAGS="-I${openmpi_dir}/include" LDFLAGS="-L${openmpi_dir}/lib" MPILIBS=-lmpi ./configure --enable-shared --enable-mpi --enable-openmp --enable-threads --enable-type-prefix --prefix="${fftw_for_gadget_dir}"
make
make install
# Single-precision
make clean
CC="${openmpi_dir}/bin/mpicc" MPICC="${openmpi_dir}/bin/mpicc" CFLAGS="-O3 -fPIC" CPPFLAGS="-I${openmpi_dir}/include" LDFLAGS="-L${openmpi_dir}/lib" MPILIBS=-lmpi ./configure --enable-shared --enable-mpi --enable-openmp --enable-threads --enable-float --enable-type-prefix --prefix="${fftw_for_gadget_dir}"
make
make install
cp COPYING README "${fftw_for_gadget_dir}"
cd ../../
rm -rf tmp

# GADGET2
current_step="installation of GADGET"
printf "\n\e[1m\e[93mInstalling GADGET\e[0m\n"
mkdir tmp
cd tmp
wget -c -O gadget2.tar.gz "${gadget_url}"
tar xf gadget2.tar.gz
mv Gadget*/* "${gadget_dir}"
cd ..
rm -rf tmp

# Copyright notice
current_step="copyright notice"
printf "\n\e[1m\e[93mCopyright notice\e[0m
Miniconda, GSL, Open MPI, HDF5, FFTW and GADGET (along with its own
version of FFTW) has been installed into seperate folders in ${top_dir}.
Any use of CO\e[3mN\e[0mCEPT must conform to the license terms of the
above software. These can be found in their seperate installation
directories.\n"

# Installation complete. Deactivate trap before exiting.
trap : 0
printf "\n\e[1m\e[92mCO\e[3mN\e[0m\e[1m\e[92mCEPT successfully installed\e[0m\n"

