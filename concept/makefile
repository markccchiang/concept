# This is the makefile for the CONCEPT code. Preferebly you should not interact
# with this file directly, but rather use the run script to build and run the code.
# It is expected that you call this makefile with the paramsfile=filename option.
# Otherwise 'params_default' will be used as parameterfile.

# Use the bash shell
SHELL = /bin/bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles = analysis communication ewald graphics gravity integration IO main mesh params species units
# The default parameterfile to use (never needed when invoked via the run script)
params_default = $(shell this_dir="$$( cd "$$( dirname "$${BASH_SOURCE[0]}" )" && pwd )"; echo "$${this_dir}")/params/default
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# Modules imported by the commons module
commons_imports = units params species IO
# Modules which import the commons module
do_import_commons = analysis communication ewald graphics gravity integration IO main mesh species
# List of files generated by running the code, which should be deleted by distclean
files_auxiliary = output/* logs/* __pycache__ jobscript .ewald_gridsize* .fftw_wisdom_gridsize*
# List of files generated by using the utilities in the utilities directory
files_utilities = $(addprefix utilities/, plots plot.params plot.py generate_random_ICs.py)



################################################
# Environment information from the .paths file #
################################################
paths = $(shell this_dir="$$( cd "$$( dirname "$${BASH_SOURCE[0]}" )" && pwd )"; \
          curr="$${this_dir}"; \
          while [ 1 ]; do \
              if [ -f "$${curr}/.paths" ]; then \
                  paths="$${curr}/.paths"; \
                  break; \
              fi; \
              if [ "$${curr}" == "/" ]; then \
                  paths='fail'; \
                  break; \
              fi; \
              curr="`dirname \"$${curr}\"`"; \
          done; \
          echo "$${paths}")
ifeq ($(paths), fail)
    $(error Could not find the .paths file)
endif
python        = $(shell source $(paths); echo $${python})
concept_dir   = $(shell source $(paths); echo $${concept_dir})
fftw_dir      = $(shell source $(paths); echo $${fftw_dir})
gsl_dir       = $(shell source $(paths); echo $${gsl_dir})
mpi_dir       = $(shell source $(paths); echo $${mpi_dir})
python_dir    = $(shell source $(paths); echo $${python_dir})
cython_abs    = $(shell source $(paths); echo $${cython})
cython        = $(shell ${python} -c "from os.path import relpath; print(relpath('${cython_abs}', '${concept_dir}'))")# Make path relative to this makefile (concept_dir), reducing screen clutter when making
mpicc_abs     = $(shell source $(paths); echo $${mpicc})
mpicc         = $(shell ${python} -c "from os.path import relpath; print(relpath('${mpicc_abs}', '${concept_dir}'))")# Make path relative to this makefile (concept_dir), reducing screen clutter when making
python_config = $(shell source $(paths); echo $${python_config})



########################################
# Settings for compilation and linking #
########################################
# Options passed when cynthonizing .pyx files
cythonflags = -3 -a -o
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_dir)/include
python_incl = $(shell $(python_config) --includes)
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC = $(mpicc)
python_cflags = $(shell $(python_config) --cflags)
other_cflags  = -pthread -std=c99 -fno-strict-aliasing -fPIC
CFLAGS_abs    = $(python_cflags) $(other_cflags) $(includes)
# Libraries to link
fftw_libs   = -L$(fftw_dir)/lib -Wl,"-rpath=$(fftw_dir)/lib" -lfftw3_mpi -lfftw3
gsl_libs    = -L$(gsl_dir)/lib -Wl,"-rpath=$(gsl_dir)/lib" -lgsl -lgslcblas -lm
mpi_libs    = -L$(mpi_dir)/lib -Wl,"-rpath=$(mpi_dir)/lib" -lmpi
python_libs = -L$(python_dir)/lib -Wl,"-rpath=$(python_dir)/lib" $(shell $(python_config) --libs)
LDLIBS_abs  = $(fftw_libs) $(gsl_libs) $(mpi_libs) $(python_libs)
# Linker options
python_ldflags = $(shell $(python_config) --ldflags)
other_ldflags  = -shared
LDFLAGS_abs    = $(python_ldflags) $(other_ldflags)
# Reduce screen clutter when making by using relative paths and removing duplicate linker options
CFLAGS  = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${CFLAGS_abs}';\
                                words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                         if word.startswith('-I') or word.startswith('-L')\
                                         else word for word in line.split(' ') if word];\
                                words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                         if word.startswith('-Wl,-rpath=') else word for word in words];\
                                words = [relpath(word, '${concept_dir}')\
                                         if word.startswith('/') else word for word in words];\
                                _, indices = np.unique([word.strip() for word in words], return_index=True);\
                                words = np.array(words)[indices];\
                                [print(word) for word in words]")
LDLIBS  = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${LDLIBS_abs}';\
                               words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                        if word.startswith('-I') or word.startswith('-L')\
                                        else word for word in line.split(' ') if word];\
                               words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                        if word.startswith('-Wl,-rpath=') else word for word in words];\
                               words = [relpath(word, '${concept_dir}')\
                                        if word.startswith('/') else word for word in words];\
                               _, indices = np.unique([word.strip() for word in words], return_index=True);\
                               words = np.array(words)[indices];\
                               [print(word) for word in words]")
LDFLAGS = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${LDFLAGS_abs}';\
                                words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                         if word.startswith('-I') or word.startswith('-L')\
                                         else word for word in line.split(' ')\
                                         if (word and word not in '${LDLIBS_abs}'.split(' '))];\
                                words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                         if word.startswith('-Wl,-rpath=') else word for word in words];\
                                words = [relpath(word, '${concept_dir}')\
                                         if word.startswith('/') else word for word in words];\
                                _, indices = np.unique([word.strip() for word in words], return_index=True);\
                                words = np.array(words)[indices];\
                                [print(word) for word in words]")



################################
# Preprocess the params module #
################################
# The message to be inserted by the params.py target
copy_msg = \# The following is an exact copy of
copy_msg_len = $(shell ${python} -c "print(len('${copy_msg}') + 1)")
# If no paramsfile argument is supplied, the default parameterfile will be used
ifndef paramsfile
    paramsfile=$(params_default)
endif
# Force execution of the params.py target if the parameterfile
# passed as $(paramsfile) differ from that of the last run.
ifndef rebuild_params
    rebuild_params="no"
endif
.PHONY := $(shell if [ -f params.py ] && [ "$(paramsfile)" != "$$(head -n 1 \
          params.py 2> /dev/null | cut -c $(copy_msg_len)-)" ] && [ $(rebuild_params) == "no" ] ; then \
          $(MAKE) --always-make paramsfile=$(paramsfile) rebuild_params="yes" params.py; fi)
ifneq ($(.PHONY),)
    $(info )
    $(info $(strip $(.PHONY)))
endif



###################
# Primary targets #
###################
# Make everything
all: $(addsuffix .so, $(pyfiles))
	@# This suppresses "make: Nothing to be done for `all'."

# Link object filed into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	$(CC) $< -o $@ $(LDFLAGS) $(LDLIBS)

# Compile c source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into c source files
$(addsuffix .c, $(pyfiles)): %.c: %.pyx
	@$(python) -c "from blessings import Terminal; t = Terminal(); print('\n' + t.bold_yellow('Building the $(subst .c,,$@) module'))"
	$(cython) $(cythonflags) $@ $<

# Use declarations in .pyx files to create .pxd files
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx
	@$(python) $(pyxpp) $< $(paramsfile) "pxd"

# Transform .py files into .pyx files
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py
	@cp $< $@
	@$(python) $(pyxpp) $@ $(paramsfile) "pyx"

# Copy the specified parameterfile to params.py and inserts a header, telling which parameterfile it is a
# copy of. Also include imports of some useful numpy functions and constants, import everything from the
# units module and the paths from the .paths file in the header, enabling the use of math, units and absolute
# paths in parameter files. Lastly, write pxd information directly to the params.py so that the pyxpp script
# can make a pxd file.
params.py: $(paramsfile) $(MAKEFILE_LIST)
	@echo
	@echo "Processing parameters from $(paramsfile)"
	@cp $(paramsfile) $@
	@sed -i '1i$(copy_msg) $(paramsfile)\
	# Import useful numpy functions and constants\
	from numpy import abs, arange, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, ceil, cos, cosh, e, exp, floor, linspace, loadtxt, log, log10, log2, pi, sqrt, sin, sinh, tan, tanh\
	from numpy import pi as π\
	# Get access to the absolute paths stored in the .paths file\
	import imp, os\
	top_dir = os.path.abspath(".")\
	while True:\
	    if ".paths" in os.listdir(top_dir):\
	        break\
	    elif top_dir == "/":\
	        raise Exception("Cannot find the .paths file!")\
	    top_dir = os.path.dirname(top_dir)\
	paths_module = imp.load_source("paths", top_dir + "/.paths")\
	paths = {key: value for key, value in paths_module.__dict__.items()\
	         if isinstance(key, str) and not key.startswith("__")}\
	# Include the directory of the parameter file as "params_dir"\
	paths["params_dir"] = os.path.dirname("$(paramsfile)")\
	# Seperate but equivalent imports in pure Python and Cython\
	import cython\
	if not cython.compiled:\
	    # Import units from the non-compiled .py file\
	    units = imp.load_source("units", "units.py")\
	    for key, value in units.__dict__.items():\
	        if isinstance(key, str):\
	            try:\
	                exec(key + "= value")\
	            except:\
	                pass\
	else:\
	    # Lines in triple quotes will be executed in the .pyx file\
	    """\
	    from units cimport *\
	    """\
	#Original parameter file below\n' $@
	@# Append pxd information to the params file
	@sed -i '$$a\\n\
	# The pxd content of this file. The pyxpp script will recognize\
	# it and put it in the pxd file.\
	pxd = """\
	# Input/output\
	str IC_file\
	str snapshot_type\
	str snapshot_dir\
	str snapshot_base\
	tuple snapshot_times\
	str powerspec_dir\
	str powerspec_base\
	tuple powerspec_times\
	# Numerical parameters\
	double boxsize\
	int ewald_gridsize\
	ptrdiff_t PM_gridsize\
	double P3M_scale\
	double P3M_cutoff\
	dict softeningfactors\
	double Δt_factor\
	# Cosmological parameters\
	double H0\
	double Ωm\
	double ΩΛ\
	double a_begin\
	# Graphics\
	str frame_dir\
	str liveframe\
	str image_format\
	size_t framespace\
	tuple color\
	str bgcolor\
	int resolution\
	str remote_liveframe\
	str protocol\
	# Simulation options\
	bint use_Ewald\
	dict kick_algorithms\
	# Extra hidden feature\
	str special\
	"""\n' $@



###########################
# Additional dependencies #
###########################
# All Cython-generated c source files depend on their own header file
$(addsuffix .c, $(pyfiles)): %.c: %.pxd
# Lots of modules import the commons module, but it itself has imports
$(addsuffix .c, $(do_import_commons)): $(addsuffix .pxd, $(commons_imports))
# The .pyx files are generated with the pyxpp script
$(addsuffix .pyx, $(pyfiles)): $(pyxpp)
# The .pyx files get a copy of commons.py dumped into them.
# They are generated by the pyxpp script.
# Since creating .pyx files is the first step in the make process,
# they should depend on this makefile itself.
$(addsuffix .pyx, $(pyfiles)): commons.py $(pyxpp) $(MAKEFILE_LIST)
# Dependencies due to imports
analysis.c: gravity.pxd
communication.c:
ewald.c: mesh.pxd
graphics.c:
gravity.c: ewald.pxd fft.c communication.pxd mesh.pxd
integration.c:
IO.c: species.pxd communication.pxd
mesh.c: communication.pxd
species.c: gravity.pxd communication.pxd
main.c: species.pxd IO.pxd integration.pxd graphics.pxd
units.c:



###################
# Cleanup targets #
###################
# Remove all compiled files
clean:
	$(RM) $(foreach ext, pyx pxd c o so html,$(addsuffix .$(ext), $(pyfiles))) params.py
# Remove compiled modules only
clean_so:
	$(RM) $(addsuffix .so, $(pyfiles))
# Remove files produced by running tests
clean_tests:
	$(addsuffix ;, ./$(shell find tests/ -type f -name 'clean'))
# Remove files generated by running the program
clean_auxiliary:
	$(RM) -r $(files_auxiliary)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) -r $(files_utilities)
# Restore all unnecessary files, leaving the program in a distribution ready state
distclean: clean clean_tests clean_auxiliary clean_utilities

