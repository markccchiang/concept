#!/usr/bin/env bash

# Copyright (C) 2015 Jeppe Mosgard Dakin
#
# This file is part of CONCEPT, the cosmological N-body code in Python
#
# CONCEPT is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CONCEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.



# Running this script after submitting a remote job will print out the output
# of the code as it is being run. If multiple jobs are running or in queue,
# the latest will be watched. Alternatively, the job ID can be passed as the
# first argument when calling this script.

# Source the run script
curr="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
while :; do
    if [ -f "${curr}/run" ]; then
        source "${curr}/run"
        break
    elif [ "${curr}" == "/" ]; then
        # Print out error message and exit
        esc="\x1b"
        esc_normal="${esc}[0m"
        esc_bold="${esc}[1m"
        esc_red="${esc}[91m"
        printf "${esc_bold}${esc_red}Could not find the run script!${esc_normal}\n" >&2
        exit 1
    fi
    curr="$(dirname "${curr}")"
done

# Exit if this script is not run remotely via ssh
if ([ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]); then
    colorprint "Cannot watch remote job as you are working on a local machine" "red"
    exit 1
fi

# Get the jobid
if [ "$#" -lt 1 ]; then
    # Find the current (latest) jobid
    jobid=$(mj | grep ".in1" | awk '{print $1}')
    Njobs=$(echo "${jobid}" | wc -w)
    if [ "${Njobs}" == "0" ]; then
        echo "You currently have no jobs submitted"
        exit 0
    elif [ "${Njobs}" -gt 1 ]; then
        echo "You currently have ${Njobs} jobs submitted. The latest will be watched"
        jobid=$(echo "${jobid}" | awk -F'.in1' '{ print $1 }' | awk '{if($1>max) {max=$1}; count+=1} END {print max}')
    fi
else
    # The jobid was supplied as an argument
    jobid="$1"
fi
jobid="${jobid%.in1}"

# Function for continuous printout of the tail of logs/jobid
function read_tail()
{
    echo "Job ${jobid} is running"
    # Wait for logs/jobid to be created
    if [ ! -f "${concept_dir}/logs/${jobid}" ]; then
        sleep 10
        while :; do
            if [ -f "${concept_dir}/logs/${jobid}" ]; then
                break
            fi
            sleep 300
        done
    fi
    # Continuously print out the tail of logs/jobid
    echo
    tail -n 1000 -f "${concept_dir}/logs/${jobid}" &
    tail_pid=$!
    # Trap possible future Ctrl-C and make it kill above tail commands before exiting this script
    trap 'kill -9 $tail_pid; echo ; exit 130; echo ' SIGINT
    # Continue script until jobid is not listed as one of my jobs
    while :; do
        if [[ -z $(mj | grep "${jobid}") ]]; then
            sleep 10
            # Kill above tail command silently
            exec 3>&2; exec 2> /dev/null; kill ${tail_pid} >/dev/null 2>&1; sleep 1; exec 2>&3; exec 3>&-
            break
        fi
        sleep 300
    done
}

# Wait for execution of job, then call read_tail
if [[ -z $(je | grep "${jobid}") ]]; then
    # Job not running
    if [[ -z $(js | grep "${jobid}") ]]; then
        # Job not in progress
        cat "${concept_dir}/logs/${jobid}"
        exit 0
    else
        # Job is in queue
        echo "Job ${jobid} is queued"
        # Some time will always be spend in the queue
        sleep 20
        while :; do
            if [[ -n $(je | grep "${jobid}") ]]; then
                break
            fi
            sleep 1
            if [[ -z $(mj | grep "${jobid}") ]]; then
                # Job already done
                cat "${concept_dir}/logs/${jobid}"
                exit 0
            fi
            sleep 300
        done
        # Job running
        read_tail
    fi
else
    # Job running
    read_tail
fi

