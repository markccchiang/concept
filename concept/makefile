# This file is part of CONCEPT, the cosmological N-body code in Python.
# Copyright (C) 2015 Jeppe Mosgard Dakin.
#
# CONCEPT is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CONCEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CONCEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of CONCEPT can be contacted at
# jeppe.mosgaard.dakin(at)post.au.dk
# The latest version of CONCEPT is available at
# https://github.com/jmd-dk/concept/



# This is the makefile for the CONCEPT code. Preferebly you should not
# interact with this file directly, but rather use the run script to
# build and run the code. It is expected that you call this makefile
# with the paramsfile=filename option.

# Use the bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles = analysis communication ewald graphics gravity integration IO main mesh special species units
# Compiled modules imported by the commons module
commons_imports = IO species units
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# List of files generated by running the code, which should be deleted by distclean
files_auxiliary = output/* logs/* __pycache__ jobscript .ewald_gridsize* .fftw_wisdom_gridsize*
# List of files generated by using the utilities in the utilities directory
files_utilities = $(addprefix utilities/, render.params.full generate_random_ICs.py)



################################################
# Environment information from the .paths file #
################################################
# Get the path to the .paths file
paths = $(shell this_dir="$$( cd "$$( dirname "$${BASH_SOURCE[0]}" )" && pwd )"; \
          curr="$${this_dir}"; \
          while :; do \
              if [ -f "$${curr}/.paths" ]; then \
                  paths="$${curr}/.paths"; \
                  break; \
              fi; \
              if [ "$${curr}" == "/" ]; then \
                  paths='fail'; \
                  break; \
              fi; \
              curr="`dirname \"$${curr}\"`"; \
          done; \
          echo "$${paths}")
ifeq ($(paths), fail)
    $(error Could not find the .paths file)
endif
# Source the .paths file for paths.
# Make some paths relative to this makefile (concept_dir), reducing screen clutter when making
concept_dir   = $(shell source $(paths); echo $${concept_dir})
python_abs    = $(shell source $(paths); echo $${python})
python        = $(shell ${python_abs} -c "from os.path import relpath; print(relpath('${python_abs}', '${concept_dir}'))")
fftw_dir      = $(shell source $(paths); echo $${fftw_dir})
gsl_dir       = $(shell source $(paths); echo $${gsl_dir})
mpi_dir       = $(shell source $(paths); echo $${mpi_dir})
python_dir    = $(shell source $(paths); echo $${python_dir})
mpicc_abs     = $(shell source $(paths); echo $${mpicc})
mpicc         = $(shell ${python} -c "from os.path import relpath; print(relpath('${mpicc_abs}', '${concept_dir}'))")
python_config = $(shell source $(paths); echo $${python_config})



########################################
# Settings for compilation and linking #
########################################
# Options passed when cynthonizing .pyx files
cythonflags = -3 -a
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_dir)/include
python_incl = $(shell $(python_config) --includes)
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC = $(mpicc)
python_cflags = $(shell $(python_config) --cflags)
other_cflags  = -pthread -std=c99 -fno-strict-aliasing -fPIC
CFLAGS_abs    = $(python_cflags) $(other_cflags) $(includes)
# Libraries to link
fftw_libs   = -L$(fftw_dir)/lib -Wl,"-rpath=$(fftw_dir)/lib" -lfftw3_mpi -lfftw3
gsl_libs    = -L$(gsl_dir)/lib -Wl,"-rpath=$(gsl_dir)/lib" -lgsl -lgslcblas -lm
mpi_libs    = -L$(mpi_dir)/lib -Wl,"-rpath=$(mpi_dir)/lib" -lmpi
python_libs = -L$(python_dir)/lib -Wl,"-rpath=$(python_dir)/lib" $(shell $(python_config) --libs)
LDLIBS_abs  = $(fftw_libs) $(gsl_libs) $(mpi_libs) $(python_libs)
# Linker options
python_ldflags = $(shell $(python_config) --ldflags)
other_ldflags  = -shared
LDFLAGS_abs    = $(python_ldflags) $(other_ldflags)
# Reduce screen clutter when making by using relative paths and removing duplicate linker options
CFLAGS  = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${CFLAGS_abs}';\
                                words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                         if word.startswith('-I') or word.startswith('-L')\
                                         else word for word in line.split(' ') if word];\
                                words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                         if word.startswith('-Wl,-rpath=') else word for word in words];\
                                words = [relpath(word, '${concept_dir}')\
                                         if word.startswith('/') else word for word in words];\
                                _, indices = np.unique([word.strip() for word in words], return_index=True);\
                                words = np.array(words)[indices];\
                                [print(word) for word in words]")
LDLIBS  = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${LDLIBS_abs}';\
                               words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                        if word.startswith('-I') or word.startswith('-L')\
                                        else word for word in line.split(' ') if word];\
                               words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                        if word.startswith('-Wl,-rpath=') else word for word in words];\
                               words = [relpath(word, '${concept_dir}')\
                                        if word.startswith('/') else word for word in words];\
                               _, indices = np.unique([word.strip() for word in words], return_index=True);\
                               words = np.array(words)[indices];\
                               [print(word) for word in words]")
LDFLAGS = $(shell ${python} -c "from os.path import relpath; import numpy as np; line = '${LDFLAGS_abs}';\
                                words = [word[:2] + relpath(word[2:], '${concept_dir}')\
                                         if word.startswith('-I') or word.startswith('-L')\
                                         else word for word in line.split(' ')\
                                         if (word and word not in '${LDLIBS_abs}'.split(' '))];\
                                words = [word[:11] + relpath(word[11:], '${concept_dir}')\
                                         if word.startswith('-Wl,-rpath=') else word for word in words];\
                                words = [relpath(word, '${concept_dir}')\
                                         if word.startswith('/') else word for word in words];\
                                _, indices = np.unique([word.strip() for word in words], return_index=True);\
                                words = np.array(words)[indices];\
                                [print(word) for word in words]")



###################
# Primary targets #
###################
# The below targets are responsible for the
# .py --> (.pyx --> .pxd) --> .c --> .o --> .so build chain. For each,
# module, a heading are printed at the beginning of its build process.
# The 'build_status' variable is used as a flag, controlling these
# headings.

# Make everything
all: $(addsuffix .so, $(pyfiles)) params.py
	@# This suppresses "make: Nothing to be done for `all'."

# Link object filed into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(CC) $< -o $@ $(LDFLAGS) $(LDLIBS)
	$(eval build_status = finsihed)

# Compile c source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into c source files
$(addsuffix .c, $(pyfiles)): %.c: %.pyx %.pxd
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(python) -m cython $(cythonflags) $<

# Write .pxd files from .pyx files using the pyxpp script
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx $(pyxpp)
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(python) $(pyxpp) $<

# Write .pyx files from .py files using the pyxpp script
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py $(pyxpp) $(MAKEFILE_LIST)
	@$(python) -c "from blessings import Terminal; t = Terminal(force_styling=True); print('\n' + t.bold_yellow('Building the $(basename $@) module')) if '$(build_status)' != 'running' else ''"
	$(eval build_status = running)
	$(python) $(pyxpp) $<


# Copy the specified parameterfile to params.py and inserts a header,
# telling which parameterfile it is a copy of. Also include imports of
# some useful numpy functions and constants and import everything from
# the units module. Import the paths from the .paths file and add
# 'params_dir' to the paths dict, enabling users to refer to the
# directory of a parameterfile from within the file itself.
params.py: $(paramsfile) $(MAKEFILE_LIST)
	@printf "\nProcessing parameterfile \"$(paramsfile_rel)\"\n"
	@cp $(paramsfile) $@
	@sed -i '1i$(copy_msg) $(paramsfile)\
	# Import useful numpy functions and constants\
	import numpy as np\
	from numpy import (pi, pi as π,\
	                   sin,  cos,  tan,  arcsin,  arccos,  arctan,\
	                   sinh, cosh, tanh, arcsinh, arccosh, arctanh,\
	                   e, exp, log, log2, log10,\
	                   abs, sqrt, sum, prod, mod,\
		               arange, linspace, loadtxt,\
		               )\
	# Get access to the absolute paths stored in the .paths file\
	import imp, os\
	top_dir = os.path.abspath(".")\
	while True:\
	    if ".paths" in os.listdir(top_dir):\
	        break\
	    elif top_dir == "/":\
	        raise Exception("Cannot find the .paths file!")\
	    top_dir = os.path.dirname(top_dir)\
	paths_module = imp.load_source("paths", top_dir + "/.paths")\
	paths = {key: value for key, value in paths_module.__dict__.items()\
	         if isinstance(key, str) and not key.startswith("__")}\
	# Include the directory of the parameter file as "params_dir"\
	paths["params_dir"] = os.path.dirname("$(paramsfile)")\
	# Import units from the non-compiled units.py file\
	units = imp.load_source("units", "units.py")\
	for key, value in units.__dict__.items():\
	    if isinstance(key, str):\
	        exec("{} = {}".format(key, "value"))\
	#Original parameter file below\n' $@
	@printf "\n#ASCII-versions of unicode parameters\n" >> $@
	@echo "GREEK_CAPITAL_LETTER_DELTAt_factor = Δt_factor" >> $@
	@echo "GREEK_CAPITAL_LETTER_OMEGAm = Ωm" >> $@
	@echo "GREEK_CAPITAL_LETTER_OMEGAGREEK_CAPITAL_LETTER_LAMDA = ΩΛ" >> $@
# The message to be inserted into params.py
copy_msg = \# The following is an exact copy of
# Relative path to the paramsfile, for clean printout
paramsfile_rel = $(shell $(python) -c "from os.path import relpath; rel = relpath('${paramsfile}', '${concept_dir}'); print(rel if not rel.startswith('../../') else '${paramsfile}')")
# If the current paramsfile is not the same as the one used last time,
# force the params.py target to be build by making it a .PHONY target.
.PHONY: $(shell [ -f params.py ] && [ "$$($(python) -c "print('$$(head -n 1 params.py 2> /dev/null)'.replace('$(copy_msg)', '').strip())")" != "$(paramsfile)" ] && echo params.py)



###########################
# Additional dependencies #
###########################
# Add any additional target dependencies here.
# - Many .pyx files get a copy of commons.py dumped into them, making
#   a .pyx: commons.py dependency.
# - The .c files of the .pyx files which get a copy of commons.py
#   inherist the dependencies of the would be commons.c. That is, we
#   have the a .c: $(addsuffix .pxd, $(commons_imports)) dependency.
# - Every cimport statement in a .pyx/.pxd leads to a dependency of the
#   form .c: imported_module.pxd
analysis.c:        $(addsuffix .pxd, $(commons_imports)) gravity.pxd
analysis.pyx:      commons.py
communication.c:   $(addsuffix .pxd, $(commons_imports))
communication.pyx: commons.py
ewald.c:           $(addsuffix .pxd, $(commons_imports)) mesh.pxd
ewald.pyx:         commons.py
graphics.c:        $(addsuffix .pxd, $(commons_imports))
graphics.pyx:      commons.py
gravity.c:         $(addsuffix .pxd, $(commons_imports)) fft.c ewald.pxd communication.pxd mesh.pxd
gravity.pyx:       commons.py
integration.c:     $(addsuffix .pxd, $(commons_imports))
integration.pyx:   commons.py
IO.c:              $(addsuffix .pxd, $(commons_imports)) communication.pxd species.pxd
IO.pyx:            commons.py
main.c:            $(addsuffix .pxd, $(commons_imports)) analysis.pxd graphics.pxd integration.pxd IO.pxd special.pxd species.pxd
main.pyx:          commons.py
mesh.c:            $(addsuffix .pxd, $(commons_imports)) communication.pxd
mesh.pyx:          commons.py
special.c:         $(addsuffix .pxd, $(commons_imports)) analysis.pxd graphics.pxd IO.pxd
special.pyx:       commons.py
species.c:         $(addsuffix .pxd, $(commons_imports)) gravity.pxd communication.pxd
species.pyx:       commons.py           



###################
# Cleanup targets #
###################
# Remove all compiled files
clean:
	$(RM) $(foreach ext, pyx pxd c o so html,$(addsuffix .$(ext), $(pyfiles))) params.py
# Remove compiled modules only
clean_so:
	$(RM) $(addsuffix .so, $(pyfiles))
# Remove files produced by running tests
clean_tests:
	$(addsuffix ;, $(shell find tests/ -type f -name 'clean'))
# Remove files generated by running the program
clean_auxiliary:
	$(RM) -r $(files_auxiliary)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) -r $(files_utilities)
# Restore all unnecessary files, leaving the program in a distribution ready state
distclean: clean clean_tests clean_auxiliary clean_utilities
