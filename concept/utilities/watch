#!/usr/bin/env bash

# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of CO𝘕CEPT can be contacted at
# jeppe.mosgaard.dakin(at)post.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# Running this script after submitting a remote job via PBS will print out the
# output of the code as it is being run. If multiple jobs are running or in
# queue, the latest will be watched. Alternatively, the job ID can be passed
# as the first argument when calling this script.
# You can run this script directly or by invoking the concept script with the
# --util watch
# option.

# Absolute paths to this file and its directory
this_file="$(readlink -f "${BASH_SOURCE[0]}")"
this_dir="$(dirname "${this_file}")"

# Set up error trapping
ctrl_c()
{
    # Kill the tail command silently before exiting
    if [ -n "${tail_pid}" ]; then
        exec 3>&2; exec 2> /dev/null; kill -SIGKILL ${tail_pid} >/dev/null 2>&1 || :; sleep 0.1; exec 2>&3; exec 3>&-
    fi
    trap : 0
    exit 2
}
abort()
{
    # Kill the tail command silently before exiting
    if [ -n "${tail_pid}" ]; then
        exec 3>&2; exec 2> /dev/null; kill -SIGKILL ${tail_pid} >/dev/null 2>&1 || :; sleep 0.1; exec 2>&3; exec 3>&-
    fi
    colorprint "An error occurred while using the \"$(basename ${this_file})\" utility!" "red"
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Source the concept script
source "${this_dir}/../concept"

# Exit if this script is not run remotely via ssh
if ([ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]); then
    colorprint "Error: Cannot watch remote job as you are working on a local machine" "red"
    exit 1
fi

# Check for unrequired positional arguments
if [ $# -gt 1 ]; then
    badvars=""
    for badvar in ${@:2}; do
        if [ -n "${badvar}" ]; then
            badvars="${badvars}, \"${badvar}\""
        fi
    done
    badvars="${badvars:2}"
    colorprint "Warning: The following arguments will be ignored by the $(basename ${this_file}) utility:" "red"
    colorprint "${badvars}" "red"
fi

# Check for the qstat command
qstat_path="$(which qstat 2> /dev/null || :)"
if [ -z "${qstat_path}" ]; then
    colorprint "Error: Could not find the 'qstat' command. Is PBS installed and on the PATH?" "red"
    exit 1
fi

# Get the username. As at least some PBS implementations enforce a maximum
# username length of 15 characters, truncate the username to 15 characters.
my_username="$(whoami)"
my_username="${my_username:0:15}"

# Aquire information about submitted jobs.
# Revert the output of qstat, so that the newest jobs are in the top.
qstat_info="$(qstat | tac)"

# Function that update the state variable by running the qstat command
update_job_info()
{
    # Remove possible suffix on jobid
    jobid="${jobid%.*}"
    # Aquire information about submitted jobs.
    # Revert the output of qstat, so that the newest jobs are in the top.
    qstat_info="$(qstat | tac)"
    # Reset the state variable
    state="None"
    # Iterate through qstat output
    while read -r line; do
        if [[ "$(echo "${line}" | awk '{print $1}')" == "${jobid}."* ]]; then
            # Submitted job with matching jobid found
            username="$(echo "${line}" | awk '{print $3}')"
            username="${username:0:15}"
            if [ "${username}" != "${my_username}" ]; then
                colorprint "Job ${jobid} does not belong to you" "red"
                exit 1
            fi
            state="$(echo "${line}" | awk '{print $5}')"
            queue="$(echo "${line}" | awk '{print $6}')"
            break
        fi
    done <<< "${qstat_info}"
}

# If no argument is given, find the last submitted job.
# If an argument (the jobid) is given, find information about the job.
if [ $# == 0 ]; then
    # Aquire information about all submitted jobs
    qstat_info="$(qstat)"
    # Find all jobs submitted by the user. Keep only the latest one
    Njobs=0
    while read -r line; do
        username="$(echo "${line}" | awk '{print $3}')"
        username="${username:0:15}"
        if [ "${username}" == "${my_username}" ]; then
            # Job submitted by the user found
            ((Njobs += 1))
            jobid="$(echo "${line}" | awk '{print $1}')"
            state="$(echo "${line}" | awk '{print $5}')"
            queue="$(echo "${line}" | awk '{print $6}')"
        fi
    done <<< "${qstat_info}"
    if [ ${Njobs} == 0 ]; then
        colorprint "Error: You currently have no jobs submitted" "red"
        exit 1
    elif [ ${Njobs} -gt 1 ]; then
        echo "You currently have ${Njobs} jobs submitted. The latest will be watched"
        sleep 1
    fi
    # Remove possible suffix on jobid
    jobid="${jobid%.*}"
else
    jobid="$1"
    # Remove possible suffix on jobid
    jobid="${jobid%.*}"
    update_job_info
    if [ "${state}" == "None" ]; then
        # Job not in progress
        if [ -f "${logs_dir}/${jobid}" ]; then
            cat "${logs_dir}/${jobid}"
            trap : 0
            exit 0
        else
            colorprint "Error: Job ${jobid} is not running and no matching log found" "red"
            exit 1
        fi
    fi
fi

# Functin for printing changes to the job state
state_last=""
inform_on_new_state()
{
    if [ "${state}" != "${state_last}" ]; then
        case "${state}" in
            "C"    ) echo "Job ${jobid} is completed after having run";;
            "E"    ) echo "Job ${jobid} is exiting after having run";;
            "H"    ) echo "Job ${jobid} is held";;
            "Q"    ) echo "Job ${jobid} is queued in ${queue}";;
            "R"    ) echo "Job ${jobid} is running in queue ${queue}";;
            "T"    ) echo "Job ${jobid} is being moved to new location";;
            "W"    ) echo "Job ${jobid} is waiting for its executing time to be reached";;
            "S"    ) echo "Job ${jobid} is suspend";;
            "None" ) echo "Job ${jobid} is finished running";;
            ""     ) echo "Job ${jobid} is in an unspecified state";;
            *      ) echo "Job ${jobid} is in the unknown state \"${state}\"";;
        esac
        state_last="${state}"
    fi
}

# Function for checking if the job suddenly finished.
# Do not call this function after beginning reading the logfile.
check_suddenly_finished()
{
    update_job_info
    inform_on_new_state
    # If the job is already finished, printout the entire log and exit
    if [ "${state}" == "None" ]; then
        if [ -f "${logs_dir}/${jobid}" ]; then
            cat "${logs_dir}/${jobid}"
        else
            echo "Job ${jobid} is finished running, but no logfile is to be found. Curious ..."
        fi
        trap : 0
        exit 0
    fi
}

# Sleep durations in seconds
sleep_little=30
sleep_much=300

# Wait until job is running
if [ "${state}" != "R" ]; then
    # Wait a small time before calling qstat again
    sleep ${sleep_little}
    check_suddenly_finished
    while [ "${state}" != "R" ] ; do   
        # Wait a long time before calling qstat again
        sleep ${sleep_much}
        check_suddenly_finished
    done
fi
state_last="R"

# Job running. Wait for logfile to be created
slept=0
while [ ! -f "${logs_dir}/${jobid}" ]; do
    sleep ${sleep_little}
    # After having slept for a long time, check that the job
    # has not just finished without producing a log file.
    ((slept += ${sleep_little}))
    if [ ${slept} -ge ${sleep_much} ]; then
        check_suddenly_finished
        slept=0
    fi
done

# Logfile created. Continuously print out its tail until end of job
echo
tail -n 1000 -f "${logs_dir}/${jobid}" &
tail_pid=$!
update_job_info
inform_on_new_state
if [ "${state}" != "None" ]; then
    # Wait a small time before calling qstat again
    sleep ${sleep_little}
    update_job_info
    inform_on_new_state
    while [ "${state}" != "None" ]; do
        # Wait a long time before calling qstat again
        sleep ${sleep_much}
        update_job_info
        inform_on_new_state
    done
fi

# Kill the tail command silently before exiting
if [ -n "${tail_pid}" ]; then
    exec 3>&2; exec 2> /dev/null; kill -SIGKILL ${tail_pid} >/dev/null 2>&1 || :; sleep 0.1; exec 2>&3; exec 3>&-
fi

# Exit gracefully
trap : 0

