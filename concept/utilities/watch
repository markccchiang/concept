#!/bin/bash

# Running this script after submitting a remote job will print out the output
# of the code as it is being run. If multiple jobs are running or in queue,
# the latest will be watched. Alternatively, the job ID can be passed as the
# first argument when calling this script.

# Exit if this script is not run remotely via ssh
if ([ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]); then
    printf "\e[1m\e[91mCannot watch remote job as you are working on a local machine\e[0m\n" >&2
    exit 1
fi

# Load paths from the .paths file
this_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
curr="${this_dir}"
while [ 1 ]; do
    if [ -f "${curr}/.paths" ]; then
        source "${curr}/.paths"
        break
    fi
    if [ "${curr}" == "/" ]; then
        printf "\e[1m\e[91mCould not find the .paths file!\e[0m\n" >&2
        exit 1
    fi
    curr="`dirname \"${curr}\"`"
done

# Get the jobid
if [ "$#" -lt 1 ]; then
    # Find the current (latest) jobid
    jobid=$(mj | grep ".in1" | awk '{print $1}')
    Njobs=$(echo "${jobid}" | wc -w)
    if [ "${Njobs}" == 0 ]; then
        echo "You currently have no jobs submitted"
        exit 0
    fi
    if [ "${Njobs}" -gt 1 ]; then
        echo "You currently have ${Njobs} jobs submitted. The latest will be watched"
        jobid=$(echo "${jobid}" | awk '{print $NF}')
    fi
else
    # The jobid was supplied as an argument
    jobid="$1"
fi
jobid="${jobid%.in1}"

# Function for continuous printout of the tail of logs/remote_jobid
function read_tail {
    echo "Job ${jobid} is running"
    # Wait for logs/remote_jobid to be created
    if [ ! -f "${concept_dir}/logs/remote_${jobid}" ]; then
        sleep 10
        while :; do
            if [ -f "${concept_dir}/logs/remote_${jobid}" ]; then
                break
            fi
            sleep 300
        done
    fi
    # Continuously print out the tail of subdir/log/jobid.output
    echo
    tail -n 1000 -f "${concept_dir}/logs/remote_${jobid}" &
    # Trap possible future Ctrl-C and make it kill above tail command before exiting this script
    tail_pid=$!
    trap 'kill -9 $tail_pid; echo ; exit 130; echo ' SIGINT
    # Continue script until jobid is not listed as one of my jobs
    while :; do
        if [[ -z $(mj | grep "${jobid}") ]]; then
            sleep 10
            # Kill above tail command silently
            exec 3>&2; exec 2> /dev/null; kill ${tail_pid} >/dev/null 2>&1; sleep 1; exec 2>&3; exec 3>&-
            break
        fi
        sleep 300
    done
}

# Wait for execution of job, then call read_tail
if [[ -z $(je | grep "${jobid}") ]]; then
    # Job not running
    if [[ -z $(js | grep "${jobid}") ]]; then
        # Job not in progress
        cat "${concept_dir}/logs/remote_${jobid}"
        exit 0
    else
        # Job is in queue
        echo "Job ${jobid} is queued"
        # Some time will always be spend in the queue
        sleep 20
        while :; do
            if [[ -n $(je | grep "${jobid}") ]]; then
                break
            fi
            sleep 1
            if [[ -z $(mj | grep "${jobid}") ]]; then
                # Job already done
                cat "${concept_dir}/logs/remote_${jobid}"
                exit 0
            fi
            sleep 300
        done
        # Job running
        read_tail
    fi
else
    # Job running
    read_tail
fi

