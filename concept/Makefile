# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015-2017 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The author of CO𝘕CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# This is the makefile for the CO𝘕CEPT code. Preferebly you should not
# interact with this file directly, but rather use the concept script to
# build and run the code.

# Use the bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles = analysis      \
          commons       \
          communication \
          ewald         \
          fluid         \
          graphics      \
          gravity       \
          ic            \
          integration   \
          interactions  \
          main          \
          mesh          \
          snapshot      \
          species       \
          utilities
# Filename of the module holding common definitions
commons = commons.py
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# Filename of the temporary .pyx file storing the custom types
types = .types.pyx
# List of files generated in the concept directory by running the code,
# which should be removed by the distclean target
# (the types file is removed by the clean target).
files_auxiliary = jobscript              \
                  .exit_code             \
                  .ewald_gridsize*       \
                  .fftw_wisdom_gridsize*
# List of files and directories in the utilities directory
# generated by using the utilities.
files_utilities = params     \
                  update_new



################################################
# Environment information from the .paths file #
################################################
# Get the path to the .paths file
paths_filename = $(shell this_dir="$(CURDIR)";                     \
				         path="$${this_dir}";                      \
				         while :; do                               \
				             if [ -f "$${path}/.paths" ]; then     \
				                 paths_filename="$${path}/.paths"; \
				                 break;                            \
				             fi;                                   \
				             if [ "$${path}" == "/" ]; then        \
				                 paths_filename='fail';            \
				                 break;                            \
				             fi;                                   \
				             path="$$(dirname "$${path}")";        \
				         done;                                     \
				         echo "$${paths_filename}";                \
				   )
ifeq ($(paths_filename),fail)
    $(error Could not find the .paths file)
endif
# Include (absolute) paths from the .paths file
include $(paths_filename)
# Function which takes in a quoted argument. If this argument is
# a path (perhaps prefixed with e.g. -I) and it is located near this
# Makefile, the return value is the relative path. Otherwise, the
# return value is just the untouched argument.
# A backslash will be placed before spaces.
sensible_path = $(shell $(python) -c "import os;                                                  \
                                      path = $1;                                                  \
                                      prefix = ([''] + [prefix for prefix in                      \
                                                        ('-I', '-L', '-Wl,-rpath=')               \
                                                        if path.startswith(prefix)]               \
                                                )[-1];                                            \
                                      abspath = path[len(prefix):];                               \
                                      relpath = os.path.relpath(abspath, '.');                    \
                                      path = abspath if relpath.startswith('../..') else relpath; \
                                      path = prefix + path;                                       \
                                      path = path.replace(' ', chr(92) + ' ');                    \
                                      path = path.replace(2*chr(92), chr(92));                    \
                                      path = path.strip();                                        \
                                      print(path);                                                \
                                      "                                                           \
                  )
# Transform all the included paths to sensible paths
# to reduce screen clutter when making.
paths = $(shell grep -o '.*=' $(paths_filename) | sed 's/.$$//')
$(foreach path,$(paths),$(eval $(path)=$(call sensible_path,$($(path)))))



########################################
# Settings for compilation and linking #
########################################
# Function which eliminates duplicates
uniq = $(strip $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1))))
# The python configuration script
python_config = $(shell readlink -f $$(which $(python)))-config
# Options passed when cythonizing .pyx files
python_version_major = $(shell $(python) -c "import sys; print(sys.version_info.major)")
cythonflags = -$(python_version_major) -a
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_dir)/include
python_incl = $(shell $(python_config) --includes)
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC                = $(mpicc)
unwanted_warnings = unused-but-set-variable \
                    uninitialized
python_cflags     = $(filter-out $(addprefix -W,$(unwanted_warnings)), \
                                 $(shell $(python_config) --cflags))
other_cflags      = -Ofast               \
                    -pthread             \
                    -std=c99             \
                    -fno-strict-aliasing \
                    -fPIC                \
                    -Wall                \
                    -Wextra              \
                    $(addprefix -Wno-,$(unwanted_warnings))
CFLAGS            = $(call uniq, $(foreach flag, $(python_cflags)                \
                                                 $(other_cflags)                 \
                                                 $(includes)                     \
                                                 ,                               \
                                                 $(call sensible_path,'$(flag)') \
                                   )                                             \
                      )
# Libraries to link
fftw_libs     = -L$(fftw_dir)/lib -Wl,-rpath=$(fftw_dir)/lib -lfftw3_mpi -lfftw3
gsl_libs      = -L$(gsl_dir)/lib -Wl,-rpath=$(gsl_dir)/lib -lgsl -lgslcblas -lm
mpi_libs      = -L$(mpi_dir)/lib -Wl,-rpath=$(mpi_dir)/lib -lmpi
python_libdir = $(shell $(python) -c "import sysconfig;                          \
                                      print(sysconfig.get_config_var('LIBDIR')); \
                                      "                                          \
                  )
python_libs   = -L$(python_libdir) -Wl,-rpath=$(python_libdir) $(shell $(python_config) --libs)
other_libs    = -Wl,-O3
LDLIBS        = $(call uniq, $(foreach flag, $(fftw_libs)                     \
                                             $(gsl_libs)                      \
                                             $(mpi_libs)                      \
                                             $(python_libs)                   \
                                             $(other_libs)                    \
                                             ,                                \
                                              $(call sensible_path,'$(flag)') \
                               )                                              \
                  )
# Linker options
python_ldflags = $(shell $(python_config) --ldflags)
other_ldflags  = -shared
LDFLAGS        = $(call uniq, $(foreach flag, $(python_ldflags)               \
                                              $(other_ldflags)                \
                                              ,                               \
                                              $(call sensible_path,'$(flag)') \
                                )                                             \
                   )



###################
# Primary targets #
###################
# The below recipes are responsible for the
# .py --> (.pyx --> .pxd) --> (.c + .html) --> .o --> .so build chain.
# When building the modules in serial, a heading is printed at the
# beginning of the build process for each module. The 'current_module'
# variable is used as a flag, controlling these headings. When building
# the modules in parallel, a single, collective heading is shown.
define heading
    $(if $(findstring -j,-$(MAKEFLAGS)),
      # Parallel build
      $(python) -c "import blessings;                                                     \
                    terminal = blessings.Terminal(force_styling=True);                    \
                    print(terminal.bold_yellow('Building modules\n')                      \
                          if '$(last_module)' != 'all' else '', end='');                  \
                    "
      $(eval last_module = all),
      # Serial build
      $(python) -c "import blessings;                                                     \
                    terminal = blessings.Terminal(force_styling=True);                    \
                    new_module = '$(current_module)' != '$(last_module)';                 \
                    print('\n' if new_module and '$(last_module)' else '', end='');       \
                    print(terminal.bold_yellow('Building the $(current_module) module\n') \
                          if new_module else '', end='');                                 \
                    "
      $(eval last_module = $(current_module))
      )
endef
# Assign the name of the module being build to the 'current_module'
# variable at the start of a module build chain.
$(foreach pyfile,$(pyfiles),$(eval $(pyfile).so: current_module = $(pyfile)))

# Make all compiled python modules.
# When finished, update time stamps so that all dependencies are
# synchronized (this is needed because .pxd files are only updated
# when their contents actually change. That is, `make pyfile.pxd` does
# not necessarily update the timestamp of pyfile.pxd, even though its
# rule is run. This makes .c (and therefore .o and .so) files
# dependent on such .pxd files not up-to-date). The types file is also
# only updated when its content actually changes.
all: $(addsuffix .so, $(pyfiles))
ifeq ($(MAKELEVEL),0)
	@$(MAKE) -s -t $@
endif
.PHONY: all

# Link object files into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	@$(call heading)
	$(CC) $< -o $@ $(LDFLAGS) $(LDLIBS)

# Compile C source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	@$(call heading)
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into C source files
# (and also produce the annotated .html file).
$(addsuffix .c, $(pyfiles)): %.c: %.pyx %.pxd
	@$(call heading)
	$(python) -m cython $(cythonflags) $<
# Same as above (for explicit builds of html)
$(addsuffix .html, $(pyfiles)): %.html: %.pyx %.pxd
	$(python) -m cython $(cythonflags) $<

# Write .pxd files from .pyx files and the types file
# using the pyxpp script.
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx $(pyxpp) $(commons) $(types)
	@$(call heading)
	$(python) -B $(pyxpp) $< $(commons) $(types)

# Write the types file from the .pyx files using the pyxpp script
$(types): $(addsuffix .pyx, $(pyfiles)) $(pyxpp) $(commons)
	$(python) -B $(pyxpp) $@ $(commons) $(types) $(addsuffix .pyx, $(pyfiles))

# Write .pyx files from .py files using the pyxpp script
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py $(pyxpp) $(commons) $(MAKEFILE_LIST)
	@$(call heading)
	$(python) -B $(pyxpp) $< $(commons)



###########################
# Additional dependencies #
###########################
# Add any additional target dependencies here.
# - Every cimport statement in a .pyx leads to a dependency of the form
#   module.c: imported_module.pxd
# - An implicit cimport statement occur after 'from commons import *',
#   leading to a depdendency of the form
#   module.c: commons.pxd
# - Every module except commons implicitly cimports extension
#   types from the snapshot and species modules,
#   leading to dependencies of the form
#   module.c: snapshot.pxd species.pxd
analysis.c:                   commons.pxd communication.pxd                           graphics.pxd             integration.pxd                  mesh.pxd snapshot.pxd species.pxd
commons.c:
communication.c:              commons.pxd                                                                      integration.pxd                           snapshot.pxd species.pxd
ewald.c:                      commons.pxd                                                                      integration.pxd                  mesh.pxd snapshot.pxd species.pxd
fluid.c:                      commons.pxd                                                                      integration.pxd                           snapshot.pxd species.pxd
graphics.c:                   commons.pxd communication.pxd                                                    integration.pxd                           snapshot.pxd species.pxd
gravity.c:                    commons.pxd communication.pxd ewald.pxd                                          integration.pxd                  mesh.pxd snapshot.pxd species.pxd
ic.c:                         commons.pxd communication.pxd                                                    integration.pxd                  mesh.pxd snapshot.pxd species.pxd
integration.c:                commons.pxd                                                                      integration.pxd                           snapshot.pxd species.pxd
interactions.c:               commons.pxd                                                          gravity.pxd integration.pxd                           snapshot.pxd species.pxd
main.c:          analysis.pxd commons.pxd                                             graphics.pxd             integration.pxd interactions.pxd          snapshot.pxd species.pxd utilities.pxd
mesh.c:                       commons.pxd communication.pxd           fft.c                                    integration.pxd                           snapshot.pxd species.pxd
snapshot.c:                   commons.pxd communication.pxd                                                    integration.pxd                                        species.pxd
species.c:                    commons.pxd communication.pxd                 fluid.pxd                          integration.pxd                           snapshot.pxd
utilities.c:     analysis.pxd commons.pxd communication.pxd                           graphics.pxd             integration.pxd                  mesh.pxd snapshot.pxd species.pxd



###################
# Cleanup targets #
###################
.PHONY: clean clean_auxiliary clean_logs clean_output clean_tests clean_utilities distclean
# Remove all compile files
clean:
	$(RM) -r $(foreach ext,pyc pyx pxd c o so so_ html,$(addsuffix .$(ext), $(pyfiles))) $(types) __pycache__
# Remove files generated via autosave
clean_autosave:
	$(RM) $(output_dir)/autosave_*
	$(RM) $(params_dir)/autosave_*
# Remove files generated by running the program
clean_auxiliary:
	$(RM) $(files_auxiliary)
# Remove everything in the log directory
clean_logs:
	$(RM) -r $(logs_dir)/* $(logs_dir)/.[^.]*
# Remove everything in the output directory
clean_output:
	$(RM) -r $(output_dir)/* $(output_dir)/.[^.]*
# Remove files produced by running tests
clean_tests:
	$(foreach clean_file,$(wildcard $(tests_dir)/*/clean),$(clean_file);)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) -r $(addprefix $(utilities_dir)/,$(files_utilities))
	$(RM) -r $(top_dir)/concept_backup $(top_dir)/tmp
# Remove all unnecessary files,
# leaving CO𝘕CEPT in a distribution ready state.
distclean: clean clean_autosave clean_auxiliary clean_logs clean_output clean_tests clean_utilities
