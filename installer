#!/usr/bin/env bash

# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015-2016 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of CO𝘕CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# This script downloads and installs the CO𝘕CEPT code with all its
# dependencies. If run without an argument, it will prompt for an
# installation directory. Alternatively, this directory can be passed as
# an argument. Everything will be installed within this directory.
# All tests can be skipped by supplying --fast as an argument.
# You can also download and run the newest version of this script by
# executing the following command:
# bash <(wget -O- --no-ch bit.ly/concept_nbody)
# The above uses a URL shortener. If it does not work, use the full URL:
# bash <(wget -O- --no-ch https://raw.githubusercontent.com/jmd-dk/concept/master/installer)
#
# The following software will be installed in order:
# - zlib     (needed by libpng, HDF5 and Python)
# - libpng   (needed by matplotlib)
# - GSL
# - MPICH
# - HDF5
# - FFTW
# - FreeType (needed by matplotlib)
# - ncurses  (needed by _curses, which is needed by blessings)
# - OpenSSL  (needed by pip)
# - Python, with the following packages (together with their own Python
#   package dependencies):
#     - Blessings
#     - Cython
#     - Cython_GSL
#     - NumPy
#     - Matplotlib
#     - MPI4Py
#     - Pexpect
#     - H5Py
#     - Yolk3k and pip (if any of the above)
# - CO𝘕CEPT
# - FFTW 2 (needed by GADGET)
# - GADGET
#
# By default, any pre-installed versions of the above software will be
# ignored. Should you wish CO𝘕CEPT to use one such pre-installed
# component, you have to declare its directory path through the
# "programname_dir" environment variable. E.g. to use a pre-installed
# gsl library:
# gsl_dir=/path/to/gsl /path/to/installer
# The set of such environment variables correspond to the program names
# above (though using lowercase only), except for mpich,
# which are just mpi_dir.
# 
# Should you choose to use a pre-installed Python distribution
# (by setting the python_dir variable), any missing Python packages
# will be installed in this distribution. Pre-installed Python packages
# will not be touched; e.g. if the installer wishes to install NumPy
# 1.10.4, but 1.10.3 is already installed, the packages will not be
# updated. If you want such Python package updates (or downgrades),
# set the "pythonpackagename_install" environment variable to "yes".
# E.g. to overwrite a pre-installed NumPy package:
# numpy_install=yes python_dir=/path/to/python /path/to/installer

# If you choose to use a pre-installed Python distribution, it is your
# responsibility that pip is installed as part of this distribution.
# Also, if the blessings package is not pre-installed in the Python
# distribution, Python should at least be compiled with the ncurses
# library.
#
# Should you wish to install a specific version of some dependency
# program, simply set the environment variable "programname_version"
# when invoking the installer. This also works for Python packages.



##################
# Specifications #
##################
# This function sets the variables "name_dir" (if not set already)
# and "name_preinstalled".
set_dir()
{
    # Arguments: Program name, install directory.
    # Set "name_preinstalled" if "name_dir" is already set
    eval "${1}_preinstalled=yes"
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_preinstalled=no"
    # Set "name_dir" if "name_dir" is not already set
    # or "name" should be installed.
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_dir=\"${2}\""
    eval "(! (   [ \"\${${1}_install}\"      == \"no\" ] \
              && [ \"\${${1}_preinstalled}\" == \"no\" ])) || ${1}_dir=\"\""
}
# The install_explicit_only environment variable, when set to "yes",
# disables all implicit installations.
if [ "${install_explicit_only}" == "yes" ]; then
    for progname in "zlib"            \
                    "libpng"          \
                    "imagemagick"     \
                    "gsl"             \
                    "mpi"             \
                    "hdf5"            \
                    "fftw"            \
                    "freetype"        \
                    "ncurses"         \
                    "openssl"         \
                    "python"          \
                    "concept"         \
                    "fftw_for_gadget" \
                    "gadget"          \
                    "blessings"       \
                    "cython"          \
                    "cython_gsl"      \
                    "h5py"            \
                    "matplotlib"      \
                    "mpi4py"          \
                    "numpy"           \
                    "pexpect"; do
        eval "[ -n \"\${${progname}_install}\" ] || ${progname}_install=\"no\""
    done
fi
# Specification of paths. The substring "__top_dir__"
# will later be replaced with the top level directory.
set_dir "concept"         "__top_dir__/concept"
set_dir "fftw"            "__top_dir__/fftw"
set_dir "freetype"        "__top_dir__/freetype"
set_dir "gadget"          "__top_dir__/gadget"
set_dir "fftw_for_gadget" "${gadget_dir}/fftw"
set_dir "gsl"             "__top_dir__/gsl"
set_dir "hdf5"            "__top_dir__/hdf5"
set_dir "imagemagick"     "__top_dir__/imagemagick"
set_dir "libpng"          "__top_dir__/libpng"
set_dir "mpi"             "__top_dir__/mpich"
set_dir "python"          "__top_dir__/python"
set_dir "ncurses"         "${python_dir}"
set_dir "openssl"         "${python_dir}"
set_dir "zlib"            "__top_dir__/zlib"
log="__top_dir__/install_log"
dotpaths="__top_dir__/.paths"

# This function sets the variable "name_version" if not set already.
# For preinstalled software, set "name_version" to "pre-installed".
# If a third argument is given, this is the version to fall back to,
# in case the second argument is "newest" and the newest version
# cannot be determined.
set_version()
{
    # Arguments: Program name, version, [fallback version]
    eval "[ -z \"\${${1}_version}\" ] || ${1}_version_specifiedbyuser=\"true\""
    eval "[ -n \"\${${1}_version}\" ] || ${1}_version=\"${2}\""
    eval "[ \"\${${1}_preinstalled}\" != \"yes\" ] || ${1}_version=\"pre-installed\""
    if [ -n "${3}" ]; then
        eval "${1}_version_fallback=\"${3}\""
    fi
}
# Specification of software versions. A specification of
# "newest" will be replaced with the latest stable version. The right
# column are fallbacks, which will be used if the middle column is
# "newest" and the installer fails to find the newest version.
# If you specify a version in the middle column and this version
# cannot be found, it will again fall back to the right column.
set_version "concept"         "newest"  # only newest work
set_version "freetype"        "2.7"     "2.6.5"
set_version "python"          "3.5.2"
set_version "libpng"          "1.6.25"  "1.6.23"
set_version "ncurses"         "6.0"     "6.0"
set_version "openssl"         "1.0.2j"  "1.0.2i"  # Python 3.5.2 seems incompatible with 1.1.0b
set_version "fftw"            "3.3.5"   "3.3.5"
set_version "gadget"          "2.0.7"
set_version "fftw_for_gadget" "2.1.5"   "2.1.5"
set_version "gsl"             "2.2"     "2.2"
set_version "hdf5"            "1.8.17"  "1.8.17"
set_version "mpi"             "3.2"     "3.2"
set_version "zlib"            "1.2.8"   "1.2.8"
# Python packages
set_version "blessings"       "1.6"
set_version "cython"          "0.24.1"    # 0.23 does not work
set_version "cython_gsl"      "0.2.1"
set_version "matplotlib"      "1.5.1"
set_version "numpy"           "1.11.1"
set_version "pexpect"         "4.2.0"
set_version "mpi4py"          "2.0.0"   # 2.0.0 breaks h5py 2.5.0
set_version "h5py"            "2.6.0"
# No longer installed by default
set_version "imagemagick"     "6.9.3-3" "6.9.1-10"
# Note that the versions may be changed further down due to known
# compatibility issues between specific versions of the above programs
# and specific versions of system dependencies.



#################
# Initial setup #
#################
# Set up error trapping
ctrl_c()
{
    current_step="aborting"
    sleep 0.5
    kill -- -$$ > /dev/null 2>&1 || :
    exit 2
}
abort()
{
    sleep 0.5
    kill -- -$$ > /dev/null 2>&1 || :
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# For the terminal to be able to print Unicode characters correctly,
# the terminal charset need to be compatible.
export LC_CTYPE="en_US.UTF-8"
# Set the terminal if unset or broken
if [ -z "${TERM}" ] || [ "${TERM}" == "dumb" ]; then
    export TERM="linux"
fi

# ANSI/VT100 escape sequences
esc="\x1b"
# Text formatting
esc_normal="${esc}[0m"
esc_bold="${esc}[1m"
esc_italic="${esc}[3m"
esc_reverted="${esc}[7m"
esc_no_italic="${esc}[23m"
# The name of the program, nicely typesat
if [ -z "${esc_concept}" ]; then
    esc_concept="CO${esc_italic}N${esc_no_italic}CEPT"
else
    esc_concept="${esc_concept//\$\{esc_italic\}/${esc_italic}}"
    esc_concept="${esc_concept//\$\{esc_no_italic\}/${esc_no_italic}}"
fi
esc_concept_double_backslashes="$(echo "${esc_concept}" | sed 's,\\,\\\\,g')"
# Text colors
esc_red="${esc}[91m"
esc_green="${esc}[92m"
esc_yellow="${esc}[93m"
# Cursor movement
esc_up="${esc}[1A"
esc_erase="${esc}[K"
# Special characters
en_quad="\xE2\x80\x80"
# Functions for pretty printing text
heading()
{
    printf "\n${esc_bold}${esc_yellow}${1}${esc_normal}\n"
}
error()
{
    printf "\n${esc_bold}${esc_red}${1}${esc_normal}\n" >&2
}

# Print out welcome message
sleep 1  # Needed if invoked directly from the web via wget
if [ "${say_welcome}" != "no" ]; then
    heading "${esc_bold}${esc_yellow}This is the installation script for ${esc_concept},
the cosmological ${esc_italic}N${esc_no_italic}-body code in Python${esc_normal}"
    echo
fi

# Status control sequenses
status="initialization"
status_prefix="__new_status__="
status_prefix_length=${#status_prefix}
status_disable="disable"
status_enable="enable"
status_on="on"
status_off="off"
status_visible="${status_on}"
status_finish="finish_successfully"

# Backup of initial environment variables
CC_backup="${CC}"
CFLAGS_backup="${CFLAGS}"
CPPFLAGS_backup="${CPPFLAGS}"
LD_LIBRARY_PATH_backup="${LD_LIBRARY_PATH}"
LDFLAGS_backup="${LDFLAGS}"
LIBS_backup="${LIBS}"
MPICC_backup="${MPICC}"
MPILIBS_backup="${MPILIBS}"
PATH_backup="${PATH}"
PKG_CONFIG_PATH_backup="${PKG_CONFIG_PATH}"
PNG_CFLAGS_backup="${PNG_CFLAGS}"
PNG_LIBS_backup="${PNG_LIBS}"
ZLIB_CFLAGS_backup="${ZLIB_CFLAGS}"
ZLIB_LIBS_backup="${ZLIB_LIBS}"
ZLIBLIB_backup="${ZLIBLIB}"
ZLIBINC_backup="${ZLIBINC}"
# Function that resets all above environment
# variables to their initial state.
reset_environment()
{
    for var in "CC"              \
               "CFLAGS"          \
               "CPPFLAGS"        \
               "LD_LIBRARY_PATH" \
               "LDFLAGS"         \
               "LIBS"            \
               "MPICC"           \
               "MPILIBS"         \
               "PATH"            \
               "PKG_CONFIG_PATH" \
               "PNG_CFLAGS"      \
               "PNG_LIBS"        \
               "ZLIB_CFLAGS"     \
               "ZLIB_LIBS"       \
               "ZLIBLIB"         \
               "ZLIBINC"; do
        if [ -z "$(eval "echo \"\${${var}_backup}\"")" ]; then
            unset "${var}"
        else
            eval "export ${var}=\"\${${var}_backup}\""
        fi
    done
}

# Set test_success variables
concept_test_success="yes"
fftw_test_success="yes"
fftw_for_gadget_test_success="yes"
freetype_test_success="yes"
gadget_test_success="yes"
gsl_test_success="yes"
hdf5_test_success="yes"
imagemagick_test_success="yes"
libpng_test_success="yes"
mpi_test_success="yes"
ncurses_test_success="yes"
openssl_test_success="yes"
python_test_success="yes"
zlib_test_success="yes"

# Read in command line arguments
if [ -z "${fast_install}" ]; then
    fast_install="no"
fi
if [ -z "${top_dir_specified}" ]; then
    top_dir_specified="no"
fi
for var in "$@"; do
    if [ "${var}" == "--fast" ]; then
        fast_install="yes"
    elif [ "${top_dir_specified}" == "no" ]; then
        top_dir="${var}"
        top_dir_specified="yes"
    else
        if [ "${var}" != "${top_dir}" ]; then
            error "Got command line argument \"${var}\", "\
"but the installation path is already set to \"${top_dir}\""
            exit 1
        fi
    fi    
done
sleep_time=10
if [ "${fast_install}" == "yes" ]; then
    sleep_time=0
fi

# Check whether system dependencies are installed and located on PATH
current_step="check for preinstalled system dependencies"
# Check for package manager and set package names
set_package_names()
{
    # Arguments: Package name for awk, gcc, g++, gfortran, gzip, make,
    # perl, sed, tar, wget.
    i=0
    for package in "awk" "gcc" "gxx" "gfortran" "gzip" "make" "perl" "sed" "tar" "wget"; do
        ((i += 1))
        eval "${package}_package=\${${i}}"
    done
}
set_package_manager_and_names()
{
    # This function takes no arguments
    package_manager=""
    for pmanager in "apt-get" "dnf" "yum" "zypper" "urpmi"; do
        path="$(which "${pmanager}" 2> /dev/null || :)"
        if [ -n "${path}" ]; then
            # Package manager found
            package_manager="${pmanager}"
            # Package names
            case "${package_manager}" in
                "apt-get" ) install_command="sudo ${package_manager} -y install"
                            set_package_names "gawk"     \
                                              "gcc"      \
                                              "g++"      \
                                              "gfortran" \
                                              "gzip"     \
                                              "make"     \
                                              "perl"     \
                                              "sed"      \
                                              "tar"      \
                                              "wget"
                            break
                            ;;
                "dnf"     ) install_command="sudo ${package_manager} -y install"
                            set_package_names "gawk"         \
                                              "gcc"          \
                                              "gcc-c++"      \
                                              "gcc-gfortran" \
                                              "gzip"         \
                                              "make"         \
                                              "perl"         \
                                              "sed"          \
                                              "tar"          \
                                              "wget"
                            break
                            ;;
                "yum"     ) install_command="sudo ${package_manager} -y install"
                            set_package_names "gawk"         \
                                              "gcc"          \
                                              "gcc-c++"      \
                                              "gcc-gfortran" \
                                              "gzip"         \
                                              "make"         \
                                              "perl"         \
                                              "sed"          \
                                              "tar"          \
                                              "wget"
                            break
                            ;;
                "zypper"  ) install_command="sudo ${package_manager} -n install"
                            set_package_names "gawk"        \
                                              "gcc"         \
                                              "gcc-c++"     \
                                              "gcc-fortran" \
                                              "gzip"        \
                                              "make"        \
                                              "perl"        \
                                              "sed"         \
                                              "tar"         \
                                              "wget"
                            break
                            ;;
                "urpmi"   ) install_command="sudo ${package_manager} --auto"
                            set_package_names "gawk"         \
                                              "gcc"          \
                                              "gcc-c++"      \
                                              "gcc-gfortran" \
                                              "gzip"         \
                                              "make"         \
                                              "perl"         \
                                              "sed"          \
                                              "tar"          \
                                              "wget"
                            break
                            ;;
            esac
        fi
    done
}
set_package_manager_and_names
# Function for testing whether system dependencies are installed and
# located on PATH. For missing system dependencies, it will attempt to
# figure out the command to install it.
check_system_dependency()
{
    # Arguments: Command, package name
    path="$(which "${1}" 2> /dev/null || :)"
    if [ -z "${path}" ]; then
        # Package not installed
        if [ -n "${package_manager}" ]; then
            # Package manager found
            echo "Could not find '${1}'"
            echo "You can install it by typing:"
            echo "${install_command} ${2}"
            while :; do
                read -p "Run above command now? [Y/n] " yn
                case "${yn}" in
                    [Yy]* ) ${install_command} ${2}
                            printf "${1} successfully installed\n\n"
                            return
                            ;;
                    [Nn]* ) error "Terminated install due to missing component '${1}'"
                            exit 1
                            ;;
                    ""    ) ${install_command} ${2}
                            printf "${1} successfully installed\n\n"
                            return
                            ;;
                    *     ) error "Terminated install due to missing component '${1}'"
                            exit 1
                            ;;
                esac
            done
            exit 1
        else
            # No package manager found
            error "Error: Could not find '${1}'"
            exit 1
        fi
    fi
}
check_system_dependency "awk"      "${awk_package}"
check_system_dependency "gcc"      "${gcc_package}"
check_system_dependency "g++"      "${gxx_package}"
check_system_dependency "gfortran" "${gfortran_package}"
check_system_dependency "gzip"     "${gzip_package}"
check_system_dependency "make"     "${make_package}"
check_system_dependency "perl"     "${perl_package}"  # Needed by OpenSSL
check_system_dependency "sed"      "${sed_package}"
check_system_dependency "tar"      "${tar_package}"
check_system_dependency "wget"     "${wget_package}"

# Change default versions if they are known not to work
# with the present versions of the system dependencies.
if [ "${ncurses_version_specifiedbyuser}" != "true" ] \
   && [ "${ncurses_version}" != "pre-installed" ]; then
    # ncurses 6.0, 5.9, and 5.8 does not compile under gcc 5,
    # but ncurses 5.7 does.
    gcc_version="$(gcc -v 2>&1 | tail -n 1 | awk '{print $3}')"
    if [[ "${gcc_version}" == 5* ]]; then
        ncurses_version="5.7"
    fi
fi

# Creating top level directory (top_dir)
current_step="setup of top level directory"
if [ "${top_dir_specified}" == "no" ]; then
    printf "Where should the ${esc_concept} code be installed?"
    read -p "$(echo $'\n> ')" -e top_dir
    if [ -z "${top_dir}" ]; then
        # The user hit enter without writing a path.
        # Install in current directory.
        top_dir="."
    fi
fi
initial_dir="$(pwd)"  # It is crucial that this line is before any cd
convert_to_abs_path()
{
    # Arguments: path
    current_dir="$(pwd)"
    cd "${initial_dir}"
    # Places backslashes before spaces.
    # These are needed when expanding tilde, but they will not persist.
    abs_path="${1//[ ]/\\ }"
    # Expand tilde
    eval abs_path="${abs_path}"
    # Convert to absolute path
    abs_path=$(readlink -m "${abs_path}")
    cd "${current_dir}"
    echo "${abs_path}"
}
top_dir="$(convert_to_abs_path "${top_dir}")"
echo "The code will be installed in \"${top_dir}\""
mkdir -p "${top_dir}"
cd "${top_dir}"

# Replace "__top_dir__" in paths with the user specified top_dir.
# Also convert to absolute path and check that this path exist for
# pre-installed libraries.
fix_path()
{
    # Arguments: Program name
    progname="${1// /_}"
    progname="${progname,,}"
    # Replace "__top_dir__"
    eval "[ \"\${${progname=}_preinstalled}\" == \"yes\" ] \
          || ${progname=}_dir=\"\${${progname=}_dir/__top_dir__/${top_dir}}\""
    # Convert to absolute path
    eval "${progname=}_dir=\"\$(convert_to_abs_path \"\${${progname=}_dir}\")\""
    # Check path to pre-installed libraries
    if eval "[ \"\${${progname}_preinstalled}\" == \"yes\" ] \
             && [ ! -d \"\${${progname}_dir}\" ]"; then
        error "The specified directory\n\"$(eval "echo \${${progname}_dir}")\"\n\
for ${1/CONCEPT/$esc_concept} does not exist!"
        exit 1
    fi
}
fix_path "CONCEPT"
fix_path "FreeType"
fix_path "zlib"
fix_path "libpng"
fix_path "ImageMagick"
fix_path "ncurses"
fix_path "OpenSSL"
fix_path "Python"
fix_path "FFTW"
fix_path "GADGET"
fix_path "FFTW for GADGET"
fix_path "GSL"
fix_path "HDF5"
fix_path "MPI"
log="${log/__top_dir__/${top_dir}}"
dotpaths="${dotpaths/__top_dir__/${top_dir}}"



###########################
# Beginning of subprocess #
(
# Set up error trapping
ctrl_c_subprocess()
{
    trap : 0
    ctrl_c
    exit 0
}
abort_subprocess()
{
    trap : 0
    if [ "${current_step}" != "aborting" ]; then
        error "An error occurred during ${current_step}!"
    fi
    abort
    exit 0
}
trap 'ctrl_c_subprocess' SIGINT
trap 'abort_subprocess' EXIT
set -e

# Functions for controlling the current status
set_status()
{
    echo "${status_prefix}${1}"
}
disable_status()
{
    echo "${status_prefix}${status_disable}"
}
enable_status()
{
    echo "${status_prefix}${status_enable}"
}
successfully_finish_status()
{
    echo "${status_prefix}${status_finish_successfully}"
}



##########################
# Dependency discovering #
##########################
current_step="discovery of dependencies"
set_status "Discovering dependencies"
# Flags specifying whether or not any Python packages,
# software (meaning anything but Python packages) or any of those
# should be installed.
install_any_pypackages="no"
install_any_software="no"
install_anything="no"
# If Python is pre-installed, assume that OpenSSL
# and ncurses are also pre-installed.
assume_preinstalled()
{
    # Arguments: Program name (lowercase)
    eval "name_preinstalled=\"\${${1}_preinstalled}\""
    if [ "${name_preinstalled}" == "no" ]; then
        eval "${1}_preinstalled=\"yes\""
        eval "${1}_dir=\"\""
        eval "${1}_version=\"pre-installed\""
    fi    
}
if [ "${python_preinstalled}" == "yes" ]; then
    assume_preinstalled openssl
    assume_preinstalled ncurses
fi

# Set "pypackage"_preinstalled variables
blessings_preinstalled="no"
cython_preinstalled="no"
cython_gsl_preinstalled="no"
h5py_preinstalled="no"
matplotlib_preinstalled="no"
mpi4py_preinstalled="no"
numpy_preinstalled="no"
pexpect_preinstalled="no"
pip_preinstalled="no"
if [ "${python_preinstalled}" == "yes" ]; then
    python=$(ls -1 "${python_dir}/bin/python"* | head -n 1)
    for pypackage in blessings cython cython_gsl h5py matplotlib mpi4py numpy pexpect pip; do
        pypackage_preinstalled=$("${python}" -c "
try:
    import ${pypackage}
    print('yes')
except:
    print('no')
"
        )
        eval "${pypackage}_preinstalled=\"${pypackage_preinstalled}\""
    done
fi

# Variables telling whether or not a program needs to be installed.
# CO𝘕CEPT (install by default)
if [ -z "${concept_install}" ]; then
    concept_install="no"
    if [ "${concept_preinstalled}" == "no" ]; then
        concept_install="yes"
        install_any_software="yes"
    fi
fi
# GADGET (needed by CO𝘕CEPT)
if [ -z "${gadget_install}" ]; then
    gadget_install="no"
    if [ "${gadget_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        gadget_install="yes"
        install_any_software="yes"
    fi
fi
# FFTW for GADGET (needed by GADGET)
if [ -z "${fftw_for_gadget_install}" ]; then
    fftw_for_gadget_install="no"
    if [ "${fftw_for_gadget_preinstalled}" == "no" ] && [ "${gadget_install}" == "yes" ]; then
        fftw_for_gadget_install="yes"
        install_any_software="yes"
    fi
fi
# Python (needed by CO𝘕CEPT)
if [ -z "${python_install}" ]; then
    python_install="no"
    if [ "${python_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        python_install="yes"
        install_any_software="yes"
    fi
fi
# Python packages (needed by CO𝘕CEPT)
if [ -z "${pip_install}" ]; then
    # Always install pip if Python is to be installed
    pip_install="no"
    if [ "${python_install}" == "yes" ]; then
        pip_install="yes"
    fi
fi
for pypackage in blessings cython cython_gsl h5py matplotlib mpi4py numpy pexpect; do
    eval "pypackage_install=\"\${${pypackage}_install}\""
    if [ -z "${pypackage_install}" ]; then
        eval "${pypackage}_install=\"no\""
        eval "pypackage_preinstalled=\"\${${pypackage}_preinstalled}\""
        if [ "${pypackage_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
            eval "${pypackage}_install=\"yes\""
        fi
    fi
    eval "pypackage_install=\"\${${pypackage}_install}\""
    if [ "${pypackage_install}" == "yes" ]; then
        install_any_pypackages="yes"
        install_any_software="yes"
    fi
done
# FFTW (needed by CO𝘕CEPT)
if [ -z "${fftw_install}" ]; then
    fftw_install="no"
    if [ "${fftw_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        fftw_install="yes"
        install_any_software="yes"
    fi
fi
# HDF5 (needed by CO𝘕CEPT)
if [ -z "${hdf5_install}" ]; then
    hdf5_install="no"
    if [ "${hdf5_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        hdf5_install="yes"
        install_any_software="yes"
    fi
fi
# MPI (needed by CO𝘕CEPT)
if [ -z "${mpi_install}" ]; then
    mpi_install="no"
    if [ "${mpi_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        mpi_install="yes"
        install_any_software="yes"
    fi
fi
# GSL (needed by CO𝘕CEPT)
if [ -z "${gsl_install}" ]; then
    gsl_install="no"
    if [ "${gsl_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        gsl_install="yes"
        install_any_software="yes"
    fi
fi
# ImageMagick (no longer needed by CO𝘕CEPT)
if [ -z "${imagemagick_install}" ]; then
    imagemagick_install="no"
elif [ "${imagemagick_install}" == "yes" ]; then
    install_any_software="yes"
fi
# libpng (needed by ImageMagick and matplotlib)
if [ -z "${libpng_install}" ]; then
    libpng_install="no"
    if [ "${libpng_preinstalled}" == "no" ] && (   [ "${imagemagick_install}" == "yes" ] \
                                                || [ "${matplotlib_install}"  == "yes" ]); then
        libpng_install="yes"
        install_any_software="yes"
    fi
fi
# zlib (needed by HDF5, ImageMagick, libpng and Python)
if [ -z "${zlib_install}" ]; then
    zlib_install="no"
    if [ "${zlib_preinstalled}" == "no" ] && (   [ "${hdf5_install}"        == "yes" ] \
                                              || [ "${imagemagick_install}" == "yes" ] \
                                              || [ "${libpng_install}"      == "yes" ] \
                                              || [ "${python_install}"      == "yes" ]); then
        zlib_install="yes"
        install_any_software="yes"
    fi
fi
# FreeType (needed by matplotlib)
if [ -z "${freetype_install}" ]; then
    freetype_install="no"
    if [ "${freetype_preinstalled}" == "no" ] && [ "${matplotlib_install}" == "yes" ]; then
        freetype_install="yes"
        install_any_software="yes"
    fi
fi
# ncurses (needed by Python, if Python is needed by CO𝘕CEPT)
if [ -z "${ncurses_install}" ]; then
    ncurses_install="no"
    if [ "${ncurses_preinstalled}" == "no" ] && [ "${python_install}"  == "yes" ] \
                                             && [ "${concept_install}" == "yes" ]; then
        ncurses_install="yes"
        install_any_software="yes"
    fi
fi
# OpenSSL (needed by pip)
if [ -z "${openssl_install}" ]; then
    openssl_install="no"
    if [ "${openssl_preinstalled}" == "no" ] && [ "${pip_install}"    == "yes" ]; then
        openssl_install="yes"
        install_any_software="yes"
    fi
fi
# The "install_anything" variable
if [ "${install_any_software}" == "yes" ] || [ "${install_any_software}" == "yes" ]; then
    install_anything="yes"
fi



#############################
# URL's to all the software #
#############################
# In this section, ${progame_url} are defined for each program.
# In order for the rest of this script to work, these URLs must point
# to archives containing a single top-level directory.

# Function for checking that a given url actually exists
validate_url()
{
    # Arguments: Program name, [exit on error ("true" or "false")]
    progname="${1,,}"
    progname="${progname// /_}"
    exit_on_error="true"
    if [ -n "$2" ]; then
        exit_on_error="$2"
    fi
    if [ "${progname}" == "mpi" ]; then
        # Specifically, "MPI" is "MPICH"
        current_step="validation of MPICH link"
        set_status "Validating MPICH link"
    else
        current_step="validation of ${1/CONCEPT/$esc_concept} link"
        set_status "Validating ${1/CONCEPT/$esc_concept_double_backslashes} link"
    fi
    url="$(eval "echo \"\${${progname}_url}\"")"
    filename="$(basename "${url}")"
    for n in {1..10}; do
        wget_status="success"
        if [[ "${url}" == "ftp://"* ]]; then
            # wget do not always return with a non-zero status on
            # failure when using ftp.
            mkdir -p "${top_dir}/tmp"
            (cd "${top_dir}/tmp"
             wget -t 1 --timeout 15 --no-check-certificate -q --spider --no-remove-listing \
                  "${url}" || :)
            grep "${filename}" "${top_dir}/tmp/.listing" > /dev/null 2>&1 || wget_status="error"
            rm -f "${top_dir}/tmp/.listing"
        else
            wget -t 1 --timeout 15 --no-check-certificate -q --spider \
                 "${url}" || wget_status="error"
        fi
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep 1
    done
    validate_url_status="${wget_status}"
    if [ "${exit_on_error}" == "true" ]; then
        if [ "${wget_status}" != "success" ]; then
            error "Error: The ${1} link is broken: ${url}"
            exit 1
        fi
    fi
}

# Function for letting versions fall back to their fallback values,
# in case of unsuccessful retrievel of primary or newest version.
fallback()
{
    # Arguments: Program name
    progname="${1,,}"
    progname="${progname// /_}"
    eval "progname_version=\"\${${progname}_version}\""
    eval "progname_version_fallback=\"\${${progname}_version_fallback}\""
    # Specifically, "MPI" is "MPICH"
    if [ "${progname}" == "mpi" ]; then
        realname="MPICH"
    else
        realname="${1}"
    fi
    if [ -z "${progname_version}" ]; then
        # Could not identify newest version
        if [ -z "${progname_version_fallback}" ]; then
            exit 1
        fi
        error "Warning: Could not identify the version number of the latest ${realname}!" 2>&1
        echo "Falling back to ${realname} version ${progname_version_fallback}"
        progname_version="${progname_version_fallback}"
        eval "${progname}_version=\"\${progname_version}\""
        eval "${progname}_version_fallback=\"\${progname_version_fallback}\""
    else
        # Broken link
        if [ "${progname_version}" != "${progname_version_fallback}" ]; then
            echo "Falling back to ${realname} version ${progname_version_fallback}"
        fi
        progname_version="${progname_version_fallback}"
        eval "${progname}_version=\"\${progname_version}\""
        eval "${progname}_version_fallback=\"\${progname_version_fallback}\""
    fi
}

# Function which checks the download and installation progress
# of all the programs based on helper files created by previous
# invocations of this script. The function is called with the program
# name (progname) as the argument and it will set the variables
# progname_downloaded and progname_installed to either "yes" or "no".
check_progress()
{
    # Arguments: Program name
    progname="${1// /_}"
    progname="${progname,,}"
    # The program installation directory
    eval "progdir=\"\${${progname}_dir}\""
    # CO𝘕CEPT itself will not have a .installation_finished file in its
    # directory. Instead it uses the .installation_finished in the 
    # GADGET directory.
    if [ "${progname}" == "concept" ]; then
        progdir="${gadget_dir}"
    fi
    # The program version
    eval "progversion=\"\${${progname}_version}\""
    # If the program has already been fully installed, a file called
    # .installation_finished will be placed in the program installation
    # directory. Note that some programs share a common installation
    # directory and thefore also a common .installation_finished file.
    eval "${progname}_installed=\"no\""
    if [ -f "${progdir}/.installation_finished" ]; then
        while read line; do
            prog_prev="$(echo "${line}" | grep '^Program:*' | sed 's/^Program:\s//g' | sed 's/^ *//')"
            if [ -n "${prog_prev}" ]; then
                prog_prev_real="${prog_prev// /_}"
                prog_prev_real="${prog_prev_real,,}"
            fi
            version_prev="$(echo "${line}" | grep '^Version:*' | sed 's/^Version:\s//g' | sed 's/^ *//')"
            if [ "${version_prev}" == "${progversion}" ] && [ "${prog_prev_real}" == "${progname}" ]; then
                eval "${progname}_installed=\"yes\""
                # Installed programs should always count as downloaded
                eval "${progname}_downloaded=\"yes\""
                return
            fi
        done <"${progdir}/.installation_finished"
    fi
    # If the program is not yet installed fully, remove its directory,
    # cleaning up after any previous failed installation attempts.
    if [ "${progname}" == "gadget" ]; then
        # FFTW for GADGET is placed inside the GADGET directory
        if [ -d "${gadget_dir}/fftw" ]; then
            mv "${gadget_dir}/fftw" "${gadget_dir}/.fftw"
        fi
        rm -rf "${gadget_dir}/"*
        if [ -d "${gadget_dir}/.fftw" ]; then
            mv "${gadget_dir}/.fftw" "${gadget_dir}/fftw"
        fi
        if [ -d "${gadget_dir}" ] && [ ! "$(ls -A "${gadget_dir}")" ]; then
            rm -rf "${gadget_dir}"
        fi
    elif [ "${progname}" == "python" ]; then
        # Files from ncurses and OpenSSL are places all around in
        # ${python_dir}, so we cannot just delete this directory.
        :
    elif [ "${progname}" == "ncurses" ]; then
        rm -rf "${python_dir}/include/ncurses"
    elif [ "${progname}" == "openssl" ]; then
        rm -rf "${python_dir}/include/openssl"
    elif [ "${progname}" == "concept" ]; then
        # In the case of CO𝘕CEPT, ${progdir} is set to
        # the GADGET directory.
        rm -rf "${concept_dir}"
    else
        rm -rf "${progdir}"
    fi
    # The url to the installation file for this program
    eval "url=\"\${${progname}_url}\""
    # The directory for the downloaded file
    download_dir="${top_dir}/tmp/${progname}"
    # If the source file has already been downloaded fully, a file
    # called .download_finished will be placed in the download_dir with
    # information about this file.
    eval "${progname}_downloaded=\"no\""
    if [ -f "${download_dir}/.download_finished" ]; then
        file_prev="$(grep "^File:*" "${download_dir}/.download_finished" | sed 's/^File:\s//g' | sed 's/^ *//')"
        url_prev="$( grep "^URL:*"  "${download_dir}/.download_finished" | sed 's/^URL:\s//g'  | sed 's/^ *//')"
        if [ -f "${download_dir}/${file_prev}" ] && [ "${url_prev}" == "${url}" ]; then
            eval "${progname}_downloaded=\"yes\""
        fi
    fi
}

# zlib
if [ "${zlib_install}" == "yes" ]; then
    if [ "${zlib_version}" == "newest" ]; then
        current_step="search for latest version of zlib"
        set_status "Searching for latest version of zlib"
        zlib_url="http://sourceforge.net/projects/libpng/files/zlib/"
        zlib_version=$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${zlib_url} \
                       | grep -o "zlib/[0-9.]*"                                          \
                       | grep -o "[0-9.]*"                                               \
                       | sort -u                                                         \
                       | tail -n 1 || :)
    fi
    zlib_url="http://sourceforge.net/projects/libpng/files/zlib/${zlib_version}/\
zlib-${zlib_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "zlib"
    # If not yet downloaded, validate the URL
    if [ "${zlib_downloaded}" != "yes" ]; then
        validate_url "zlib" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary zlib link broken: ${zlib_url}"
            fallback "zlib"
            zlib_url="http://zlib.net/zlib-${zlib_version}.tar.gz"
            echo "Using secondary zlib link: ${zlib_url}"
            # Check if already installed and/or downloaded
            check_progress "zlib"
            # If not yet downloaded, validate the URL
            if [ "${zlib_downloaded}" != "yes" ]; then
                validate_url "zlib"
            fi
        fi
    fi
fi

# libpng
if [ "${libpng_install}" == "yes" ] ; then
    # For e.g. libpng_version 1.6.18, libpng_version_majors is 16
    if [ "${libpng_version}" == "newest" ]; then
        current_step="search for latest version of libpng"
        set_status "Searching for latest version of libpng"
        libpng_url="ftp://ftp.simplesystems.org/pub/png/src/"
        libpng_version_majors="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate \
                                 ${libpng_url} | grep -o "libpng[0-9]*"                \
                                               | grep -o "[0-9]*"                      \
                                               | sort -u                               \
                                               | tail -n 1 || :)"
        libpng_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate \
                          ${libpng_url}libpng${libpng_version_majors}/          \
                          | grep -o "libpng-[0-9\.]*.tar.gz"                    \
                          | sort -u                                             \
                          | tail -n 1                                           \
                          | grep -o "[0-9\.]*"                                  \
                          | head -n 1 || :)"
        libpng_version="${libpng_version:0:${#libpng_version}-1}"
    else
        libpng_version_majors="$(echo "${libpng_version}" | grep -m 1 -o -P "[0-9]*\.[0-9]*" \
                                                          | head -n 1)"
        libpng_version_majors="$(echo "${libpng_version_majors//./}")"
    fi
    libpng_url="ftp://ftp.simplesystems.org/pub/png/src/libpng${libpng_version_majors}/\
libpng-${libpng_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "libpng"
    # If not yet downloaded, validate the URL
    if [ "${libpng_downloaded}" != "yes" ]; then
        validate_url "libpng" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary libpng link broken: ${libpng_url}"
            fallback "libpng"
            libpng_url="http://sourceforge.net/projects/libpng/files/libpng${libpng_version_majors}/\
older-releases/${libpng_version}/libpng-${libpng_version}.tar.gz"
            echo "Using secondary libpng link: ${libpng_url}"
            # Check if already installed and/or downloaded
            check_progress "libpng"
            # If not yet downloaded, validate the URL
            if [ "${libpng_downloaded}" != "yes" ]; then
                validate_url "libpng"
            fi
        fi
    fi
fi

# GSL
if [ "${gsl_install}" == "yes" ]; then
    if [ "${gsl_version}" == "newest" ]; then
        current_step="search for latest version of GSL"
        set_status "Searching for latest version of GSL"
        gsl_url="ftp://ftp.gnu.org/gnu/gsl/"
        gsl_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${gsl_url} \
                       | grep "gsl-latest.tar.gz"                                       \
                       | grep -o "gsl-[0-9.]*.tar.gz"                                   \
                       | grep -o "[0-9][0-9.]*[0-9]" || :)"
    fi
    gsl_url="ftp://ftp.gnu.org/gnu/gsl/gsl-${gsl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "GSL"
    # If not yet downloaded, validate the URL
    if [ "${gsl_downloaded}" != "yes" ]; then
        validate_url "GSL" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GSL link broken: ${gsl_url}"
            fallback "GSL"
            gsl_url="http://ftpmirror.gnu.org/gsl/gsl-${gsl_version}.tar.gz"
            echo "Using secondary gsl link: ${gsl_url}"
            # Check if already installed and/or downloaded
            check_progress "GSL"
            # If not yet downloaded, validate the URL
            if [ "${gsl_downloaded}" != "yes" ]; then
                validate_url "GSL"
            fi
        fi
    fi
fi

# MPICH
if [ "${mpi_install}" == "yes" ]; then
    if [ "${mpi_version}" == "newest" ]; then
        current_step="search for latest version of MPICH"
        set_status "Searching for latest version of MPICH"
        mpi_url="http://www.mpich.org/downloads"
        mpi_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${mpi_url} \
                       | grep -m 1 -o -P "(?<=mpich-).*(?=stable)"                      \
                       | awk '{print $1}' || :)"
    fi
    mpi_url="http://www.mpich.org/static/downloads/${mpi_version}/mpich-${mpi_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "MPI"
    # If not yet downloaded, validate the URL
    if [ "${mpi_downloaded}" != "yes" ]; then
        validate_url "MPI" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary MPICH link broken: ${mpi_url}"
            fallback "MPI"
            mpi_url="http://fossies.org/linux/misc/mpich-${mpi_version}.tar.gz"
            echo "Using secondary MPICH link: ${mpi_url}"
            # Check if already installed and/or downloaded
            check_progress "MPI"
            # If not yet downloaded, validate the URL
            if [ "${mpi_downloaded}" != "yes" ]; then
                validate_url "MPI"
            fi
        fi
    fi
fi

# HDF5
if [ "${hdf5_install}" == "yes" ]; then
    if [ "${hdf5_version}" == "newest" ]; then
        current_step="search for latest version of HDF5"
        set_status "Searching for latest version of HDF5"
        hdf5_url="ftp://ftp.hdfgroup.org/HDF5/current/src/"
        hdf5_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${hdf5_url} \
                        | grep -m 1 -o -P "(?<=hdf5-).*(?=.tar\")" || :)"
    fi
    hdf5_url="ftp://ftp.hdfgroup.org/HDF5/releases/hdf5-${hdf5_version}/src/\
hdf5-${hdf5_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "HDF5"
    # If not yet downloaded, validate the URL
    if [ "${hdf5_downloaded}" != "yes" ]; then
        validate_url "HDF5" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary HDF5 link broken: ${hdf5_url}"
            fallback "HDF5"
            hdf5_url="https://www.hdfgroup.org/ftp/HDF5/releases/hdf5-${hdf5_version}/src/\
hdf5-${hdf5_version}.tar.gz"
            echo "Using secondary HDF5 link: ${hdf5_url}"
            # Check if already installed and/or downloaded
            check_progress "HDF5"
            # If not yet downloaded, validate the URL
            if [ "${hdf5_downloaded}" != "yes" ]; then
                validate_url "HDF5"
            fi
        fi
    fi
fi

# FFTW
if [ "${fftw_install}" == "yes" ]; then
    if [ "${fftw_version}" == "newest" ]; then
        current_step="search for latest version of FFTW"
        set_status "Searching for latest version of FFTW"
        fftw_url="http://www.fftw.org/download.html"
        fftw_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${fftw_url} \
                        | grep -m 1 -o -P "(?<=fftw-).*(?=.tar.gz\")" || :)"
    fi
    fftw_url="http://www.fftw.org/fftw-${fftw_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW"
    # If not yet downloaded, validate the URL
    if [ "${fftw_downloaded}" != "yes" ]; then
        validate_url "FFTW" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW link broken: ${fftw_url}"
            fallback "FFTW"
            fftw_url="ftp://ftp.fftw.org/pub/fftw/fftw-${fftw_version}.tar.gz"
            echo "Using secondary FFTW link: ${fftw_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW"
            # If not yet downloaded, validate the URL
            if [ "${fftw_downloaded}" != "yes" ]; then
                validate_url "FFTW"
            fi
        fi
    fi
fi

# FreeType
if [ "${freetype_install}" == "yes" ]; then
    if [ "${freetype_version}" == "newest" ]; then
        current_step="search for latest version of FreeType"
        set_status "Searching for latest version of FreeType"
        freetype_url="http://download.savannah.gnu.org/releases/freetype/"
        freetype_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${freetype_url} \
                            | grep -o "freetype-[0-9.]*tar"                                       \
                            | sort -u                                                             \
                            | tail -n 1                                                           \
                            | grep -o [0-9.]* || :)"
        freetype_version="${freetype_version%?}"
    fi
    freetype_url="http://download.savannah.gnu.org/releases/freetype/\
freetype-${freetype_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FreeType"
    # If not yet downloaded, validate the URL
    if [ "${freetype_downloaded}" != "yes" ]; then
        validate_url "FreeType" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FreeType link broken: ${freetype_url}"
            fallback "freetype"
            freetype_url="http://sourceforge.net/projects/freetype/files/freetype2/\
${freetype_version}/freetype-${freetype_version}.tar.gz"
            echo "Using secondary FreeType link: ${freetype_url}"
            # Check if already installed and/or downloaded
            check_progress "FreeType"
            # If not yet downloaded, validate the URL
            if [ "${freetype_downloaded}" != "yes" ]; then
                validate_url "FreeType"
            fi
        fi
    fi
fi

# ncurses
if [ "${ncurses_install}" == "yes" ]; then
    if [ "${ncurses_version}" == "newest" ]; then
        current_step="search for latest version of ncurses"
        set_status "Searching for latest version of ncurses"
        ncurses_url="http://ftp.gnu.org/pub/gnu/ncurses/"
        ncurses_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${ncurses_url} \
                           | grep -o "ncurses-[0-9.]*tar"                                       \
                           | sort -u                                                            \
                           | tail -n 1                                                          \
                           | grep -o [0-9.]* || :)"
        ncurses_version="${ncurses_version%?}"
    fi
    ncurses_url="http://ftp.gnu.org/pub/gnu/ncurses/ncurses-${ncurses_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "ncurses"
    # If not yet downloaded, validate the URL
    if [ "${ncurses_downloaded}" != "yes" ]; then
        validate_url "ncurses" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary ncurses link broken: ${ncurses_url}"
            fallback "ncurses"
            ncurses_url="ftp://invisible-island.net/ncurses/ncurses-${ncurses_version}.tar.gz"
            echo "Using secondary ncurses link: ${ncurses_url}"
            # Check if already installed and/or downloaded
            check_progress "ncurses"
            # If not yet downloaded, validate the URL
            if [ "${ncurses_downloaded}" != "yes" ]; then
                validate_url "ncurses"
            fi
        fi
    fi
fi

# OpenSSL
if [ "${openssl_install}" == "yes" ]; then
    if [ "${openssl_version}" == "newest" ]; then
        current_step="search for latest version of OpenSSL"
        set_status "Searching for latest version of OpenSSL"
        openssl_url="ftp://ftp.openssl.org/source/"
        openssl_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${openssl} \
                           | grep "openssl-[0-9].*.tar.gz"                                  \
                           | tail -n 1                                                      \
                           | grep -o -P "(?<=openssl-).*(?=.tar.gz)"                        \
                           | grep -o -P "(?=[0-9]).*(?=.tar.gz)" || :)"
        openssl_version="$(sed 's/.tar.gz.*//' <<< "${openssl_version}")"
    fi
    openssl_url="ftp://ftp.openssl.org/source/openssl-${openssl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "OpenSSL"
    # If not yet downloaded, validate the URL
    if [ "${openssl_downloaded}" != "yes" ]; then
        validate_url "OpenSSL" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary OpenSSL link broken: ${openssl_url}"
            fallback "openssl"
            openssl_version_without_letter="$(echo ${openssl_version} | grep -o "[[:digit:].]*")"
            openssl_url="http://openssl.skazkaforyou.com/source/old/${openssl_version_without_letter}/\
openssl-${openssl_version}.tar.gz"
            echo "Using secondary OpenSSL link: ${openssl_url}"
            # Check if already installed and/or downloaded
            check_progress "OpenSSL"
            # If not yet downloaded, validate the URL
            if [ "${openssl_downloaded}" != "yes" ]; then
                validate_url "OpenSSL"
            fi
        fi
    fi
fi

# Python (note that python_version will be overwritten later!)
if [ "${python_install}" == "yes" ]; then
    if [ "${python_version}" == "newest" ]; then
        current_step="search for latest version of Python"
        set_status "Searching for latest version of Python"
        python_url="https://www.python.org/downloads/"
        python_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${python_url} \
                          | grep -o -P "(?<=Python-).*(?=.tar)"                               \
                          | head -1  || :)"
    fi
    python_url="https://www.python.org/ftp/python/${python_version}/Python-${python_version}.tgz"
    # Check if already installed and/or downloaded
    check_progress "Python"
    # If not yet downloaded, validate the URL
    if [ "${python_downloaded}" != "yes" ]; then
        validate_url "Python"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary Python link broken: ${python_url}"
            error "Error: The installer does not know of a secondary Python link"
            exit 1
        fi
    fi
fi

# CO𝘕CEPT
if [ "${concept_install}" == "yes" ]; then
    concept_repo_url="https://github.com/jmd-dk/concept"
    if [ "${concept_version}" == "newest" ]; then
        current_step="search for latest version of ${esc_concept}"
        set_status "Searching for latest version of ${esc_concept_double_backslashes}"
        # The version of CO𝘕CEPT is set to the commit number
        repo_text=$(wget -t 50 --timeout 15 -q -O- --no-check-certificate ${concept_repo_url})
        line_nr=$(echo "${repo_text}" | grep -n "  commits" | awk '{print $1}')
        line_nr="${line_nr:0:${#line_nr}-1}"
        ((line_nr -= 2))
        commit_nr=$(echo "${repo_text}" | sed -n -e "${line_nr}p" | sed -e 's/^[[:space:]]*//')
        concept_version="commit ${commit_nr}"
    else
        error "Error: The installer does not know how to \
find a specific version of ${esc_concept}!"
        exit 1
    fi
    concept_url="${concept_repo_url}/archive/master.tar.gz"
    # Check if already downloaded/installed
    check_progress "CONCEPT"
    # If not yet downloaded, validate the URL
    if [ "${concept_downloaded}" != "yes" ]; then
        validate_url "CONCEPT"
    fi
fi

# FFTW for GADGET
if [ "${fftw_for_gadget_install}" == "yes" ]; then
    if [ "${fftw_for_gadget_version}" == "newest" ]; then
        current_step="search for latest version of FFTW for GADGET"
        set_status "Searching for latest version of FFTW for GADGET"
        fftw_for_gadget_url="http://www.fftw.org/download.html"
        fftw_for_gadget_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate \
                                   ${fftw_for_gadget_url} | grep -m 1 -o -P              \
                                                                 "(?<=fftw-).*(?=.tar.gz\")" || :)"
    fi
    fftw_for_gadget_url="http://www.fftw.org/fftw-${fftw_for_gadget_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW for GADGET"
    # If not yet downloaded, validate the URL
    if [ "${fftw_for_gadget_downloaded}" != "yes" ]; then
        validate_url "FFTW for GADGET" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW 2 link broken: ${fftw_for_gadget_url}"
            fallback "FFTW for GADGET"
            fftw_for_gadget_url="ftp://ftp.fftw.org/pub/fftw/fftw-${fftw_for_gadget_version}.tar.gz"
            echo "Using secondary FFTW 2 link: ${fftw_for_gadget_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW for GADGET"
            # If not yet downloaded, validate the URL
            if [ "${fftw_for_gadget_downloaded}" != "yes" ]; then
                validate_url "FFTW for GADGET"
            fi
        fi
    fi
fi

# GADGET
if [ "${gadget_install}" == "yes" ]; then
    if [ "${gadget_version}" == "newest" ]; then
        error "Error: The installer does not know how to search for the newest version of GADGET!"
        exit 1
    fi
    gadget_url="http://www.mpa-garching.mpg.de/gadget/gadget-${gadget_version}.tar.gz"
    # Check if already installed/downloaded
    check_progress "GADGET"
    # If not yet downloaded, validate the URL
    if [ "${gadget_downloaded}" != "yes" ]; then
        validate_url "GADGET" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GADGET link broken: ${gadget_url}"
            error "Error: The installer does not know of a secondary GADGET link"
            exit 1
        fi
    fi
fi

# ImageMagick
if [ "${imagemagick_install}" == "yes" ]; then
    if [ "${imagemagick_version}" == "newest" ]; then
        current_step="search for latest version of ImageMagick"
        set_status "Searching for latest version of ImageMagick"
        imagemagick_url="http://www.imagemagick.org/download/releases/"
        imagemagick_version="$(wget -t 50 --timeout 15 -q -O- --no-check-certificate    \
                               ${imagemagick_url} | grep -o "ImageMagick[0-9\.\-]*.tar" \
                                                  | grep -o "[0-9\.\-]*"                \
                                                  | sort -u                             \
                                                  | tail -n 1 || :)"
        imagemagick_version="$(echo "${imagemagick_version}" | head -c -2)"
        imagemagick_version="${imagemagick_version:1}"
    fi
    imagemagick_url="http://www.imagemagick.org/download/ImageMagick-${imagemagick_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "ImageMagick"
    # If not yet downloaded, validate the URL
    if [ "${imagemagick_downloaded}" != "yes" ]; then
        validate_url "ImageMagick" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary ImageMagick link broken: ${imagemagick_url}"
            fallback "ImageMagick"
            imagemagick_version_major="$(echo "${imagemagick_version}" | grep -m 1 -o -P "[0-9]*" \
                                                                       | head -n 1)"
            imagemagick_version_major_dot_minor="$(echo "${imagemagick_version}" | grep -m 1 -o -P \
                                                        "${imagemagick_version_major}\.[0-9]*")"
            imagemagick_url="http://sourceforge.net/projects/imagemagick/files/old-sources/\
${imagemagick_version_major}.x/${imagemagick_version_major_dot_minor}/\
ImageMagick-${imagemagick_version}.tar.gz"
            echo "Using secondary ImageMagick link: ${imagemagick_url}"
            # Check if already installed and/or downloaded
            check_progress "ImageMagick"
            # If not yet downloaded, validate the URL
            if [ "${imagemagick_downloaded}" != "yes" ]; then
                validate_url "ImageMagick"
            fi
        fi
    fi
fi

# Set "pypackage"_installed variables
if [ -n "${python_dir}" ]; then
    python_version_major=${python_version:0:1}
    if [ -f "${python_dir}/bin/python${python_version_major}" ]; then
        python_version=$("${python_dir}/bin/python${python_version_major}" -c \
                         "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
        python="${python_dir}/bin/python${python_version}"
    fi
fi
blessings_installed="no"
cython_installed="no"
cython_gsl_installed="no"
h5py_installed="no"
matplotlib_installed="no"
mpi4py_installed="no"
numpy_installed="no"
pexpect_installed="no"
pip_installed="no"
if [ -n "${python}" ] && [ "${python_installed}" == "yes" ]; then
    for pypackage in blessings cython cython_gsl h5py matplotlib mpi4py numpy pexpect pip; do
        pypackage_installed=$("${python}" -c "
try:
    import ${pypackage}
    print('yes')
except:
    print('no')
"
        )
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi



# Function for printing out nice tables (this is superior to the
# "column" command on older systems, as this does not handle
# formatted output very well).
print_table()
{
    # Arguments: Array to be printed (passed as array[@]),
    #            number of columns.
    local table=("${!1}")
    nelements=${#table[@]}
    nc=${2}

    # Replace spaces with tildes
    modify_element()
    {
        for ((i = 0; i < nelements; i += 1)); do
            element="${table[i]}"
            table[i]="${element//$1/$2}"
        done
    }
    modify_element " " "~"

    # ASCII-fy the table
    modify_element "─" ">"
    modify_element "┌" "^"
    modify_element "│" "|"
    modify_element "└" "<"
    modify_element "├" "&"

    # Backup of table
    table_with_esc=("${table[@]}")

    # Remove escape sequences in table
    esc_normal_double_backslashes=$(echo "${esc_normal}" | sed 's,\\,\\\\,g')
    esc_bold_double_backslashes=$(echo "${esc_bold}" | sed 's,\\,\\\\,g')
    esc_italic_double_backslashes=$(echo "${esc_italic}" | sed 's,\\,\\\\,g')
    esc_no_italic_double_backslashes=$(echo "${esc_no_italic}" | sed 's,\\,\\\\,g')
    modify_element "${esc_normal_double_backslashes}" ""
    modify_element "${esc_bold_double_backslashes}" ""
    modify_element "${esc_italic_double_backslashes}" ""
    modify_element "${esc_no_italic_double_backslashes}" ""

    # Determine largest length of each column
    maxlengths=($(for i in $(eval "echo {1..${nc}}"); do echo 0; done))
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        length=${#table[i]}
        [ ${length} -gt ${maxlengths[c]} ] && maxlengths[c]=${length}
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done

    # Count number of missing right spaces for each element
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        element="${table[i]}"
        nspaces[i]=$((${maxlengths[${c}]} - ${#element}))
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done

    # Reinsert spaces and Unicode characters
    table=("${table_with_esc[@]}")
    modify_element "~" "\ "
    modify_element "^" "┌"
    modify_element ">" "─"
    modify_element "|" "│"
    modify_element "<" "└"
    modify_element "&" "├"

    # Print the table
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        printf "${table[i]}"  # Print element
        [ ${nspaces[i]} -gt 0 ] && printf ' %.0s' $(eval "echo {1..${nspaces[i]}}")  # Print spaces
        ((c += 1))
        [ ${c} == ${nc} ] || printf "  "  # Print extra spaces
        [ ${c} == ${nc} ] && c=0 && printf "\n"  # Print newline
    done
}

# Write out installation overview.
# This overview take the form of the following tables.
# Programs which should not be installed will not be shown.
#
# Name           Version  Installation path
# CO𝘕CEPT        ...      "/..."
# ├─Python       ...      "/..."
# │ ├─FreeType   ...      "/..."
# │ ├─ncurses    ...      "/..."
# │ ├─OpenSSL    ...      "/..."
# │ └─zlib       ...      "/..."
# ├─GSL          ...      "/..."
# ├─MPICH        ...      "/..."
# ├─HDF5         ...      "/..."
# ├─FFTW         ...      "/..."
# ├─GADGET       ...      "/..."
# │  └─FFTW      ...      "/..."
# └─ImageMagick  ...      "/..."
#    └─libpng    ...      "/..."
#
# Name        Version
# blessings   ...
# cython      ...
# cython_gsl  ...
# h5py        ...
# matplotlib  ...
# mpi4py      ...
# numpy       ...
# pexpect     ...
tree_beginning()
{
    item_level=${1}
    hang_type='├'
    if [ "${2}" == "end" ]; then
        hang_type='└'
    fi
    if [ ${item_level} == 0 ]; then
        # Root of tree: "X"
        echo ""
    elif [ ${item_level} == 1 ]; then
        # Level 1 of tree: "├─X" or "└─X"
        echo "${hang_type}─"
    elif [ ${item_level} == 2 ]; then
        # Level 2 of tree: "│ ├─X" or "│ └─X" or "  ├─X" or  "  └─X"
        vertical_line="│"
        if [ "${last_branch}" == "yes" ]; then
            vertical_line=" "
        fi
        echo "${vertical_line} ${hang_type}─"
    fi
}
if [ "${install_anything}" == "yes" ]; then
    disable_status
    heading "Installation overview"
fi
if [ "${install_any_software}" == "yes" ]; then
    # Title
    table=("${esc_bold}Name${esc_normal}"    \
           "${esc_bold}Version${esc_normal}" \
           "${esc_bold}Installation path${esc_normal}")
    # CO𝘕CEPT
    concept_level=0
    if [ "${concept_install}" == "yes" ]; then
        hang="$(tree_beginning ${concept_level})"
        table+=("${hang}${esc_concept}$([ "${concept_installed}" == "yes" ] && echo '*' || :)" \
                "${concept_version}" "\"${concept_dir}\"")
        ((concept_level += 1))
    fi
    # Python
    python_level=${concept_level}
    if [ "${python_install}" == "yes" ]; then
        hang_end="end"
        if [ "${gsl_install}" == "yes" ] || [ "${mpi_install}"             == "yes" ] \
                                         || [ "${hdf5_install}"            == "yes" ] \
                                         || [ "${fftw_install}"            == "yes" ] \
                                         || [ "${gadget_install}"          == "yes" ] \
                                         || [ "${fftw_for_gadget_install}" == "yes" ] \
                                         || [ "${imagemagick_install}"     == "yes" ] \
                                         || [ "${libpng_install}"          == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${python_level} ${hang_end})"

        table+=("${hang}Python$([ "${python_installed}" == "yes" ] && echo '*' || :)" \
                "${python_version}" "\"${python_dir}\"")
        ((python_level += 1))
    fi
    last_branch="yes"
    if [ "${gsl_install}" == "yes" ] || [ "${mpi_install}"             == "yes" ] \
                                     || [ "${hdf5_install}"            == "yes" ] \
                                     || [ "${fftw_install}"            == "yes" ] \
                                     || [ "${gadget_install}"          == "yes" ] \
                                     || [ "${fftw_for_gadget_install}" == "yes" ] \
                                     || [ "${imagemagick_install}"     == "yes" ] \
                                     || [ "${imagemagick_install}"     == "yes" ] \
                                     || [ "${libpng_install}"          == "yes" ]; then
        last_branch="no"
    fi
    # FreeType
    if [ "${freetype_install}" == "yes" ]; then
        hang_end="end"
        if [ ${python_level} == ${concept_level} ] && [ "${last_branch}" == "no" ]; then
            hang_end=""
        fi
        if [ "${libpng_install}" == "yes" ] || [ "${ncurses_install}" == "yes" ] \
                                            || [ "${openssl_install}" == "yes" ] \
                                            || [ "${zlib_install}"    == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${python_level} ${hang_end})"
        table+=("${hang}FreeType$([ "${freetype_installed}" == "yes" ] && echo '*' || :)" \
                "${freetype_version}" "\"${freetype_dir}\"")
    fi
    # libpng
    if [ "${freetype_install}" == "yes" ]; then
        hang_end="end"
        if [ ${python_level} == ${concept_level} ] && [ "${last_branch}" == "no" ]; then
            hang_end=""
        fi
        if [ "${ncurses_install}" == "yes" ] || [ "${openssl_install}" == "yes" ] \
                                             || [ "${zlib_install}"    == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${python_level} ${hang_end})"
        table+=("${hang}libpng$([ "${libpng_installed}" == "yes" ] && echo '*' || :)" \
                "${libpng_version}" "\"${libpng_dir}\"")
    fi
    # ncurses
    if [ "${ncurses_install}" == "yes" ]; then
        hang_end="end"
        if [ ${python_level} == ${concept_level} ] && [ "${last_branch}" == "no" ]; then
            hang_end=""
        fi
        if [ "${openssl_install}" == "yes" ] || [ "${zlib_install}" == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${python_level} ${hang_end})"
        table+=("${hang}ncurses$([ "${ncurses_installed}" == "yes" ] && echo '*' || :)" \
                "${ncurses_version}" "\"${ncurses_dir}\"")
    fi
    # OpenSSL
    if [ "${openssl_install}" == "yes" ]; then
        hang_end="end"
        if [ ${python_level} == ${concept_level} ] && [ "${last_branch}" == "no" ]; then
            hang_end=""
        fi
        if [ "${zlib_install}" == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${python_level} ${hang_end})"
        table+=("${hang}OpenSSL$([ "${openssl_installed}" == "yes" ] && echo '*' || :)" \
                "${openssl_version}" "\"${openssl_dir}\"")
    fi
    # zlib
    if [ "${zlib_install}" == "yes" ]; then
        hang_end="end"
        if [ ${python_level} == ${concept_level} ] && [ "${last_branch}" == "no" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${python_level} ${hang_end})"
        table+=("${hang}zlib$([ "${zlib_installed}" == "yes" ] && echo '*' || :)" \
                "${zlib_version}" "\"${zlib_dir}\"")
    fi
    # GSL
    if [ "${gsl_install}" == "yes" ]; then
        hang_end="end"
        if [ "${mpi_install}" == "yes" ] || [ "${hdf5_install}"            == "yes" ] \
                                         || [ "${fftw_install}"            == "yes" ] \
                                         || [ "${gadget_install}"          == "yes" ] \
                                         || [ "${fftw_for_gadget_install}" == "yes" ] \
                                         || [ "${imagemagick_install}"     == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${concept_level} ${hang_end})"
        table+=("${hang}GSL$([ "${gsl_installed}" == "yes" ] && echo '*' || :)" \
                "${gsl_version}" "\"${gsl_dir}\"")
    fi
    # MPI
    if [ "${mpi_install}" == "yes" ]; then
        hang_end="end"
        if [ "${hdf5_install}" == "yes" ] || [ "${fftw_install}"            == "yes" ] \
                                          || [ "${gadget_install}"          == "yes" ] \
                                          || [ "${fftw_for_gadget_install}" == "yes" ] \
                                          || [ "${imagemagick_install}"     == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${concept_level} ${hang_end})"
        table+=("${hang}MPICH$([ "${mpi_installed}" == "yes" ] && echo '*' || :)" \
                "${mpi_version}" "\"${mpi_dir}\"")
    fi
    # HDF5
    if [ "${hdf5_install}" == "yes" ]; then
        hang_end="end"
        if [ "${fftw_install}" == "yes" ] || [ "${gadget_install}"          == "yes" ] \
                                          || [ "${fftw_for_gadget_install}" == "yes" ] \
                                          || [ "${imagemagick_install}"     == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${concept_level} ${hang_end})"
        table+=("${hang}HDF5$([ "${hdf5_installed}" == "yes" ] && echo '*' || :)" \
                "${hdf5_version}" "\"${hdf5_dir}\"")
    fi
    # FFTW
    if [ "${fftw_install}" == "yes" ]; then
        hang_end="end"
        if [ "${gadget_install}" == "yes" ] || [ "${fftw_for_gadget_install}" == "yes" ] \
                                            || [ "${imagemagick_install}"     == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${concept_level} ${hang_end})"
        table+=("${hang}FFTW$([ "${fftw_installed}" == "yes" ] && echo '*' || :)" \
                "${fftw_version}" "\"${fftw_dir}\"")
    fi
    # GADGET
    gadget_level=${concept_level}
    if [ "${gadget_install}" == "yes" ]; then
        hang_end="end"
        if [ "${imagemagick_install}" == "yes" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${gadget_level} ${hang_end})"
        table+=("${hang}GADGET$([ "${gadget_installed}" == "yes" ] && echo '*' || :)" \
                "${gadget_version}" "\"${gadget_dir}\"")
        ((gadget_level += 1))
    fi
    last_branch="yes"
    if [ "${imagemagick_install}" == "yes" ]; then
        last_branch="no"
    fi
    # FFTW for GADGET
    if [ "${fftw_for_gadget_install}" == "yes" ]; then
        hang_end="end"
        if [ ${gadget_level} == ${concept_level} ] && [ "${last_branch}" == "no" ]; then
            hang_end=""
        fi
        hang="$(tree_beginning ${gadget_level} ${hang_end})"
        table+=("${hang}FFTW$([ "${fftw_for_gadget_installed}" == "yes" ] && echo '*' || :)" \
                "${fftw_for_gadget_version}" "\"${fftw_for_gadget_dir}\"")
    fi
    # ImageMagick
    last_branch="yes"
    if [ "${imagemagick_install}" == "yes" ]; then
        hang_end="end"
        hang="$(tree_beginning ${concept_level} ${hang_end})"
        table+=("${hang}ImageMagick$([ "${imagemagick_installed}" == "yes" ] && echo '*' || :)" \
                "${imagemagick_version}" "\"${imagemagick_dir}\"")
    fi
    echo "The following software will be installed"
    print_table table[@] 3
    N_installed=0
    for (( i=6; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"*" ]]; then
            ((N_installed += 1))
        fi
    done
fi
# Print out Python package installation overview
if [ "${install_any_pypackages}" == "yes" ]; then
    table=("${esc_bold}Name${esc_normal}" "${esc_bold}Version${esc_normal}" "")
    if [ "${blessings_install}"  == "yes" ]; then
        table+=("Blessings$([ "${blessings_installed}" == "yes" ] && echo '*' || :)" \
                "${blessings_version}"  "")
    fi
    if [ "${cython_install}"     == "yes" ]; then
           table+=("Cython$([ "${cython_installed}" == "yes" ] && echo '*' || :)" \
                   "${cython_version}"     "")
    fi
    if [ "${cython_gsl_install}" == "yes" ]; then
           table+=("Cython_GSL$([ "${cython_gsl_installed}" == "yes" ] && echo '*' || :)" \
                   "${cython_gsl_version}" "")
    fi
    if [ "${h5py_install}"       == "yes" ]; then
           table+=("H5Py$([ "${h5py_installed}" == "yes" ] && echo '*' || :)" \
                   "${h5py_version}"       "")
    fi
    if [ "${matplotlib_install}" == "yes" ]; then
           table+=("Matplotlib$([ "${matplotlib_installed}" == "yes" ] && echo '*' || :)" \
                   "${matplotlib_version}" "")
    fi
    if [ "${mpi4py_install}"     == "yes" ]; then
           table+=("MPI4Py$([ "${mpi4py_installed}" == "yes" ] && echo '*' || :)" \
                   "${mpi4py_version}"     "")
    fi
    if [ "${numpy_install}"      == "yes" ]; then
           table+=("NumPy$([ "${numpy_installed}" == "yes" ] && echo '*' || :)" \
                   "${numpy_version}"      "")
    fi
    if [ "${pexpect_install}"    == "yes" ]; then
           table+=("Pexpect$([ "${pexpect_installed}" == "yes" ] && echo '*' || :)" \
                   "${pexpect_version}"    "")
    fi
    if [ "${install_any_software}" ]; then
        echo
    fi
    echo "The following Python packages will be installed"
    print_table table[@] 3
    for (( i=3; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *"*" ]]; then
            ((N_installed += 1))
        fi
    done
fi
if [ ${N_installed} == 1 ]; then
    echo
    echo "    *This is already installed and will not be reinstalled"
elif [ ${N_installed} -gt 1 ]; then
    echo
    echo "    *These are already installed and will not be reinstalled"
fi
if [ "${install_anything}" == "yes" ]; then
    sleep ${sleep_time}
    enable_status
fi



#################################
# Download CO𝘕CEPT dependencies #
#################################
# Function for downloading compressed archives
download()
{
    # Arguments: Program name
    progname="${1// /_}"
    progname="${progname,,}"
    # Do not download if already fully downloaded
    eval "prog_downloaded=\"\${${progname}_downloaded}\""
    if [ "${prog_downloaded}" == "yes" ]; then
        return
    fi
    eval "progversion=\"\${${progname}_version}\""
    if [ "${progname}" == "fftw_for_gadget" ]; then
        # When downloading FFTW for GADGET, the version number should
        # be printed together with FFTW, not GADGET.
        current_step="the downloading of FFTW ${progversion} for GADGET"
        heading "Downloading FFTW ${progversion} for GADGET"
    elif [ "${progname}" == "mpi" ]; then
        # Specifically, "MPI" is "MPICH"
        current_step="the downloading of MPICH ${progversion}"
        heading "Downloading MPICH ${progversion}"
    else
        current_step="the downloading of ${1/CONCEPT/$esc_concept} ${progversion}"
        heading "Downloading ${1/CONCEPT/$esc_concept} ${progversion}"
    fi
    eval "url=\"\${${progname}_url}\""
    # Download
    mkdir -p "${top_dir}/tmp/${progname}"
    cd "${top_dir}/tmp/${progname}"
    for n in {1..50}; do
        wget_status="success"
        wget -t 1 --timeout 15 -c --no-check-certificate "${url}" || wget_status="error"
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep ${sleep_time}
    done
    if [ "${wget_status}" == "error" ]; then
        error "Error downloading \"${url}\""
        exit 1
    fi
    # Write out success notice
    echo "The following has been fully downloaded:
File:    $(ls -t -1 | head -n 1)
URL:     ${url}
Program: ${progname}
Version: ${progversion}
Date:    $(date)
" > ".download_finished"
    cd "${top_dir}"
}

# Make the directory in which to dump all downloaded archives
mkdir -p "${top_dir}/tmp"
# Download the source code for all programs that should be installed
disable_status
if [ "${zlib_install}"            == "yes" ] && [ "${zlib_downloaded}"            == "no" ]; then
    download "zlib"
fi
if [ "${libpng_install}"          == "yes" ] && [ "${libpng_downloaded}"          == "no" ]; then
    download "libpng"
fi
if [ "${gsl_install}"             == "yes" ] && [ "${gsl_downloaded}"             == "no" ]; then
    download "GSL"
fi
if [ "${mpi_install}"             == "yes" ] && [ "${mpi_downloaded}"             == "no" ]; then
    download "MPI"
fi
if [ "${hdf5_install}"            == "yes" ] && [ "${hdf5_downloaded}"            == "no" ]; then
    download "HDF5"
fi
if [ "${fftw_install}"            == "yes" ] && [ "${fftw_downloaded}"            == "no" ]; then
    download "FFTW"
fi
if [ "${freetype_install}"        == "yes" ] && [ "${freetype_downloaded}"        == "no" ]; then
    download "FreeType"
fi
if [ "${ncurses_install}"         == "yes" ] && [ "${ncurses_downloaded}"         == "no" ]; then
    download "ncurses"
fi
if [ "${openssl_install}"         == "yes" ] && [ "${openssl_downloaded}"         == "no" ]; then
    download "OpenSSL"
fi
if [ "${python_install}"          == "yes" ] && [ "${python_downloaded}"          == "no" ]; then
    download "Python"
fi
if [ "${concept_install}"         == "yes" ] && [ "${concept_downloaded}"         == "no" ]; then
    download "CONCEPT"
fi
if [ "${fftw_for_gadget_install}" == "yes" ] && [ "${fftw_for_gadget_downloaded}" == "no" ]; then
    download "FFTW for GADGET"
fi
if [ "${gadget_install}"          == "yes" ] && [ "${gadget_downloaded}"          == "no" ]; then
    download "GADGET"
fi
if [ "${imagemagick_install}"     == "yes" ] && [ "${imagemagick_downloaded}"     == "no" ]; then
    download "ImageMagick"
fi
enable_status



###################################
# Installing CO𝘕CEPT dependencies #
###################################
# Function for extracting compressed files. After extraction,
# the compressed file will be deleted.
extract()
{
    # Arguments: Program name, [is_file]
    # Here, the optional is_file argument can be set to "yes" if
    # the first argument is a filename rather than a program name.
    # In that case, the working directory will not be changed.
    if [ "$2" == "yes" ]; then
        archive="$1"
    else
        progname="${1// /_}"
        progname="${progname,,}"
        cd "${top_dir}/tmp/${progname}"
        archive="$(ls -p -1 | grep -v /)"
        n_files=$(echo "${archive}" | wc -l)
        if [ -z "${archive}" ]; then
            error "Did not find any files in \"${top_dir}/tmp/${progname}\""
            exit 1
        elif [ ${n_files} -gt 1 ]; then
            error "Found multiple files in \"${top_dir}/tmp/${progname}\"."
            error "I am confused about which to extract. Exiting."
            exit 1
        fi
    fi
    case "${archive}" in
        # 7zip
        *.tar.7zip)  7z       -so  x   "${archive}" | tar -ixvf -;;
        *.tar.7z)    7z       -so  x   "${archive}" | tar -ixvf -;;
        *.t7zip)     7z       -so  x   "${archive}" | tar -ixvf -;;
        *.t7z)       7z       -so  x   "${archive}" | tar -ixvf -;;
        *.7zip)      7z            x   "${archive}"              ;;
        *.7z)        7z            x   "${archive}"              ;;
        # ar
        *.ar)        ar       -xv      "${archive}"              ;;
        *.a)         ar       -xv      "${archive}"              ;;
        # bzip2
        *.tar.bzip2) bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tar.bz2)   bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbzip2)    bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbz2)      bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.bzip2)     bzip2    -d       "${archive}"              ;;
        *.bz2)       bzip2    -d       "${archive}"              ;;
        *.tar.bzip)  bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tar.bz)    bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbzip)     bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbz)       bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.bzip)      bzip2    -d       "${archive}"              ;;
        *.bz)        bzip2    -d       "${archive}"              ;;
        # cbz
        *.cbz)       unzip             "${archive}"              ;;
        # compress
        *.tar.Z)     compress -d     < "${archive}" | tar -ixvf -;;
        *.tZ)        compress -d     < "${archive}" | tar -ixvf -;;
        *.Z)         compress -d       "${archive}"              ;;
        # cpio
        *.cpio)      cpio     -idv     "${archive}"              ;;
        # exe
        *.exe)       "$(readlink -f    "${archive}")"            ;;
        # gzip
        *.tar.gzip)  gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.gz)    gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.z)     gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tgzip)     gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tgz)       gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tz)        gzip     -d     < "${archive}" | tar -ixvf -;;
        *.gzip)      gzip     -d       "${archive}"              ;;
        *.gz)        gzip     -d       "${archive}"              ;;
        # iso
        *.7z)        7z            x   "${archive}"              ;;
        # jar
        *.jar)       jar      -xvf     "${archive}"              ;;
        # lzip
        *.tar.lzip)  lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.lz)    lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tlzip)     lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tlz)       lzip     -d     < "${archive}" | tar -ixvf -;;
        *.lzip)      lzip     -d       "${archive}"              ;;
        *.lz)        lzip     -d       "${archive}"              ;;
        # lzma
        *.tar.lzma)  lzma     -d     < "${archive}" | tar -ixvf -;;
        *.tlzma)     lzma     -d     < "${archive}" | tar -ixvf -;;
        *.lzma)      lzma     -d       "${archive}"              ;;
        # lzop
        *.tar.lzop)  lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tar.lzo)   lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tlzop)     lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tlzo)      lzop     -d     < "${archive}" | tar -ixvf -;;
        *.lzop)      lzop     -d       "${archive}"              ;;
        *.lzo)       lzop     -d       "${archive}"              ;;
        # pack
        *.z)         pack          u   "${archive}" out          ;;
        # rar
        *.rar)       unrar         x   "${archive}"              ;;
        # rzip
        *.tar.rzip)  rzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.rz)    rzip     -d     < "${archive}" | tar -ixvf -;;
        *.trzip)     rzip     -d     < "${archive}" | tar -ixvf -;;
        *.trz)       rzip     -d     < "${archive}" | tar -ixvf -;;
        *.rzip)      rzip     -d       "${archive}"              ;;
        *.rz)        rzip     -d       "${archive}"              ;;
        # shar
        *.shar)      unshar            "${archive}"              ;;
        # snappy
        *.sz)        snzip    -d       "${archive}"              ;;
        # tar
        *.tar)       cat               "${archive}" | tar -ixvf -;;
        # xz
        *.tar.xz)    xz       -d     < "${archive}" | tar -ixvf -;;
        *.txz)       xz       -d     < "${archive}" | tar -ixvf -;;
        *.xz)        xz       -d       "${archive}"              ;;
        # zip
        *tar.zip)    unzip    -p       "${archive}" | tar -ixvf -;;
        *tzip)       unzip    -p       "${archive}" | tar -ixvf -;;
        *.zip)       unzip             "${archive}"              ;;
        # unknown
        *) error "Could not understand the compression format of \"${archive}\""
           exit 1
           ;;
    esac
    #rm -f "${archive}"
    if [ "$2" != "yes" ]; then
        cd "${top_dir}"
    fi
}

# Function which initializes installations (extracts the pre-
# downloaded archive and change to the extracted directory).
init_install()
{
    # Arguments: Program name
    progname="${1// /_}"
    progname="${progname,,}"
    eval "progversion=\"\${${progname}_version}\""
    if [ "${progname}" == "fftw_for_gadget" ]; then
        # When installing FFTW for GADGET, the version number should
        # be printed together with FFTW, not GADGET.
        current_step="the installation of FFTW ${progversion} for GADGET"
        heading "Installing FFTW ${progversion} for GADGET"
        set_status "Installing FFTW ${progversion} for GADGET"
    elif [ "${progname}" == "mpi" ]; then
        # Specifically, "MPI" is "MPICH"
        current_step="the installation of MPICH ${progversion}"
        heading "Installing MPICH ${progversion}"
        set_status "Installing MPICH ${progversion}"
    else
        current_step="the installation of ${1/CONCEPT/$esc_concept} ${progversion}"
        heading "Installing ${1/CONCEPT/$esc_concept} ${progversion}"
        set_status "Installing ${1/CONCEPT/$esc_concept_double_backslashes} ${progversion}"
    fi
    extract "${progname}"
    cd "${top_dir}/tmp/${progname}/"*
}

# zlib
if [ "${zlib_install}" == "yes" ] && [ "${zlib_installed}" == "no" ]; then
    init_install "zlib"
    ./configure --shared --prefix="${zlib_dir}" 2>&1
    if [ "${fast_install}" == "no" ]; then
        make test 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && zlib_test_success="no"
    fi
    zlib_test_log="${zlib_dir}/test_log"
    if [ "${zlib_test_success}" == "no" ]; then
        mkdir -p "${zlib_dir}"
        cp "test_log" "${zlib_test_log}"
    fi
    make install 2>&1
    cp "README" "${zlib_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/zlib"
    # Write out success notice
    echo "The following has been fully installed:
Program: zlib
Version: ${zlib_version}
Date:    $(date)
" >> "${zlib_dir}/.installation_finished"
fi

# libpng
if [ "${libpng_install}" == "yes" ] && [ "${libpng_installed}" == "no" ]; then
    init_install "libpng"
    export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
    export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
    export LDFLAGS="-L${zlib_dir}/lib ${LDFLAGS}"
    export ZLIBLIB="${zlib_dir}/lib"
    export ZLIBINC="${zlib_dir}/include"
    ./configure --prefix="${libpng_dir}" 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && libpng_test_success="no"
    fi
    libpng_test_log="${libpng_dir}/test_log"
    if [ "${libpng_test_success}" == "no" ]; then
        mkdir -p "${libpng_dir}"
        cp "test_log" "${libpng_test_log}"
    fi
    make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" install 2>&1
    reset_environment
    cp "LICENSE" "${libpng_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/libpng"
    # Write out success notice
    echo "The following has been fully installed:
Program: libpng
Version: ${libpng_version}
Date:    $(date)
" >> "${libpng_dir}/.installation_finished"
fi

# ImageMagick (as ImageMagick has a hard time finding libpng,
# some hacks are needed).
if [ "${imagemagick_install}" == "yes" ] && [ "${imagemagick_installed}" == "no" ]; then
    init_install "ImageMagick"  
    # Delete the lines in the configure file where PNG_CFLAGS, PNG_LIBS,
    # ZLIB_CFLAGS and ZLIB_LIBS, are set to empty strings.
    sed -i '/PNG_CFLAGS=""/d' ./configure
    sed -i '/PNG_LIBS=""/d' ./configure
    sed -i '/ZLIB_CFLAGS=""/d' ./configure
    sed -i '/ZLIB_LIBS=""/d' ./configure
    export LD_LIBRARY_PATH="${libpng_dir}/lib:${zlib_dir}/lib:${LD_LIBRARY_PATH}"
    export PNG_CFLAGS="-I${libpng_dir}/include/libpng${libpng_version_majors} ${PNG_CFLAGS}"
    export PNG_LIBS="-lpng${libpng_version_majors} -L${libpng_dir}/lib, \
-Wl,-rpath=${libpng_dir}/lib ${PNG_LIBS}"
    export ZLIB_CFLAGS="-I${zlib_dir}/include ${ZLIB_CFLAGS}"
    export ZLIB_LIBS="-lz -L${zlib_dir}/lib, -Wl,-rpath=${zlib_dir}/lib ${ZLIB_LIBS}"
    ./configure --prefix="${imagemagick_dir}" \
                --disable-openmp              \
                --with-png=yes                \
                --with-zlib=yes               \
                --with-bzlib=no               \
                --with-autotrace=no           \
                --with-djvu=no                \
                --with-dps=no                 \
                --with-fftw=no                \
                --with-fpx=no                 \
                --with-fontconfig=no          \
                --with-freetype=no            \
                --with-gslib=no               \
                --with-gvc=no                 \
                --with-jbig=no                \
                --with-jpeg=no                \
                --with-lcms=no                \
                --with-lqr=no                 \
                --with-lzma=no                \
                --with-magick-plus-plus=no    \
                --with-openexr=no             \
                --with-openjp2=no             \
                --with-pango=no               \
                --with-perl=no                \
                --with-rsvg=no                \
                --with-tiff=no                \
                --with-webp=no                \
                --with-wmf=no                 \
                --with-x=no                   \
                --with-xml=no 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        make check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && imagemagick_test_success="no"
    fi
    imagemagick_test_log="${imagemagick_dir}/test_log"
    if [ "${imagemagick_test_success}" == "no" ]; then
        mkdir -p "${imagemagick_dir}"
        cp "test_log" "${imagemagick_test_log}"
    fi
    make install 2>&1
    reset_environment
    cp "AUTHORS.txt" "LICENSE" "NOTICE" "${imagemagick_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/imagemagick"
    # Write out success notice
    echo "The following has been fully installed:
Program: ImageMagick
Version: ${imagemagick_version}
Date:    $(date)
" >> "${imagemagick_dir}/.installation_finished"
fi

# GSL
if [ "${gsl_install}" == "yes" ] && [ "${gsl_installed}" == "no" ]; then
    init_install "GSL"
    ./configure --prefix="${gsl_dir}" 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        make check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && gsl_test_success="no"
    fi
    gsl_test_log="${gsl_dir}/test_log"
    if [ "${gsl_test_success}" == "no" ]; then
        mkdir -p "${gsl_dir}"
        cp "test_log" "${gsl_test_log}"
    fi
    make install 2>&1
    cp "COPYING" "README" "${gsl_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gsl"
    # Write out success notice
    echo "The following has been fully installed:
Program: GSL
Version: ${gsl_version}
Date:    $(date)
" >> "${gsl_dir}/.installation_finished"
fi

# MPICH
if [ "${mpi_install}" == "yes" ] && [ "${mpi_installed}" == "no" ]; then
    init_install "MPI"
    ./configure --enable-shared --prefix="${mpi_dir}" 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        make testing 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && mpi_test_success="no"
    fi
    mpi_test_log="${mpi_dir}/test_log"
    if [ "${mpi_test_success}" == "no" ]; then
        mkdir -p "${mpi_dir}"
        cp "test_log" "${mpi_test_log}"
    fi
    make install 2>&1
    cp "COPYRIGHT" "${mpi_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/mpi"
    # Write out success notice
    echo "The following has been fully installed:
Program: MPI
Version: ${mpi_version}
Date:    $(date)
" >> "${mpi_dir}/.installation_finished"
fi

# HDF5
if [ "${hdf5_install}" == "yes" ] && [ "${hdf5_installed}" == "no" ]; then
    init_install "HDF5"
    # Set environment variables and configure options used
    # when building againts MPI and zlib.
    enable_parallel=""
    if [ -n "${mpi_dir}" ]; then
        export CC="${mpi_dir}/bin/mpicc"
        export LD_LIBRARY_PATH="${mpi_dir}/lib:${LD_LIBRARY_PATH}"
        export PATH="${mpi_dir}/bin:${PATH}"
        enable_parallel="--enable-parallel"
    fi
    if [ -n "${zlib_dir}" ]; then
        ./configure --enable-shared                                     \
                    ${enable_parallel}                                  \
                    --with-zlib="${zlib_dir}/include","${zlib_dir}/lib" \
                    --prefix="${hdf5_dir}" 2>&1
    else
        ./configure --enable-shared ${enable_parallel} --prefix="${hdf5_dir}" 2>&1
    fi
    make 2>&1
    # On some systems, the HDF5 test (make check) hangs indefinitely.
    # To counteract this, kill the process if it still runs after an
    # hour. Count the test as failed if the last line in test_log is not
    # "make[1]: Leaving directory".
    if [ "${fast_install}" == "no" ]; then
        # Perform serial + parallel tests if build against MPI
        # or normal tests otherwise.
        if [ -n "${mpi_dir}" ]; then
            # Serial tests
            (make check-s 2>&1 & echo $! >&3) 3> "hdf5_test_pid" | tee "test_log" & tee_pid=$!
            sleep 1
            hdf5_test_pid="$(cat 'hdf5_test_pid')"
            rm -f "hdf5_test_pid"
            (sleep 3600; kill -9 ${hdf5_test_pid}; kill -9 ${tee_pid}) & hdf5_test_killer_pid=$!
            wait ${tee_pid} || :
            kill -9 ${hdf5_test_killer_pid} || :
            # Measure success based on the last line of "test_log"
            if [ -z "$(tail -n 1 test_log \
                       | grep 'make\[1\]: Leaving directory' 2> /dev/null)" ]; then
                hdf5_test_success="no"
            fi
            # Parallel tests
            (make check-p 2>&1 & echo $! >&3) 3> "hdf5_test_pid" | tee -a "test_log" & tee_pid=$!
            sleep 1
            hdf5_test_pid="$(cat 'hdf5_test_pid')"
            rm -f "hdf5_test_pid"
            (sleep 3600; kill -9 ${hdf5_test_pid}; kill -9 ${tee_pid}) & hdf5_test_killer_pid=$!
            wait ${tee_pid} || :
            kill -9 ${hdf5_test_killer_pid} || :
            # Measure success based on the last line of "test_log"
            if [ -z "$(tail -n 1 test_log \
                       | grep 'make\[1\]: Leaving directory' 2> /dev/null)" ]; then
                hdf5_test_success="no"
            fi
        else
            (make check 2>&1 & echo $! >&3) 3> "hdf5_test_pid" | tee "test_log" & tee_pid=$!
            sleep 1
            hdf5_test_pid="$(cat 'hdf5_test_pid')"
            rm -f "hdf5_test_pid"
            (sleep 3600; kill -9 ${hdf5_test_pid}; kill -9 ${tee_pid}) & hdf5_test_killer_pid=$!
            wait ${tee_pid} || :
            kill -9 ${hdf5_test_killer_pid} || :
            # Measure success based on the last line of "test_log"
            if [ -z "$(tail -n 1 test_log \
                       | grep 'make\[1\]: ' 2> /dev/null)" ]; then
                hdf5_test_success="no"
            fi
        fi
    fi
    make install 2>&1
    if [ "${fast_install}" == "no" ]; then
        make check-install 2>&1 | tee -a "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && hdf5_test_success="no"
    fi
    hdf5_test_log="${hdf5_dir}/test_log"
    if [ "${hdf5_test_success}" == "no" ]; then
        mkdir -p "${hdf5_dir}"
        cp "test_log" "${hdf5_test_log}"
    fi
    reset_environment
    cp "COPYING" "README.txt" "${hdf5_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/hdf5"
    # Write out success notice
    echo "The following has been fully installed:
Program: HDF5
Version: ${hdf5_version}
Date:    $(date)
" >> "${hdf5_dir}/.installation_finished"
fi

# FFTW
if [ "${fftw_install}" == "yes" ] && [ "${fftw_installed}" == "no" ]; then
    init_install "FFTW"
    # Set environment variables and configure options used
    # when building againts MPI.
    enable_mpi=""
    if [ -n "${mpi_dir}" ]; then
        export CC="${mpi_dir}/bin/mpicc"
        export CFLAGS="-O3 -fPIC ${CFLAGS}"
        export CPPFLAGS="-I/${mpi_dir}/include ${CPPFLAGS}"
        export LDFLAGS="-L${mpi_dir}/lib ${LDFLAGS}"
        export MPICC="${mpi_dir}/bin/mpicc"
        export MPILIBS="-lmpi ${MPILIBS}"
        export PATH="${mpi_dir}/bin:${PATH}"
        enable_mpi="--enable-mpi"
    fi    
    # Double-precision
    ./configure --enable-shared  \
                ${enable_mpi}    \
                --enable-openmp  \
                --enable-threads \
                --prefix="${fftw_dir}" 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        make check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && fftw_test_success="no"
    fi
    fftw_test_log="${fftw_dir}/test_log"
    if [ "${fftw_test_success}" == "no" ]; then
        mkdir -p "${fftw_dir}"
        cp "test_log" "${fftw_test_log}"
    fi
    make install 2>&1
    # Single-precision
    ./configure --enable-shared        \
                ${enable_mpi}          \
                --enable-openmp        \
                --enable-threads       \
                --prefix="${fftw_dir}" \
                --enable-float 2>&1
    make 2>&1
    make install 2>&1
    reset_environment
    cp "COPYING" "README" "${fftw_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw"
    # Write out success notice
    echo "The following has been fully installed:
Program: FFTW
Version: ${fftw_version}
Date:    $(date)
" >> "${fftw_dir}/.installation_finished"
fi

# FreeType
if [ "${freetype_install}" == "yes" ] && [ "${freetype_installed}" == "no" ]; then
    init_install "FreeType"
    ./configure --prefix="${freetype_dir}" \
                --with-zlib=no             \
                --with-bzip2=no            \
                --with-png=no              \
                --with-harfbuzz=no 2>&1
    make 2>&1
    # FreeType does not come with a test suite
    make install 2>&1
    (cd docs; cp "FTL.TXT" "GPLv2.TXT" "LICENSE.TXT" "${freetype_dir}/" || :)
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/freetype"
    # Write out success notice
    echo "The following has been fully installed:
Program: FreeType
Version: ${freetype_version}
Date:    $(date)
" >> "${freetype_dir}/.installation_finished"
fi

# ncurses
if [ "${ncurses_install}" == "yes" ] && [ "${ncurses_installed}" == "no" ]; then
    init_install "ncurses"
    ./configure --with-shared --prefix="${ncurses_dir}" 2>&1
    make 2>&1
    make install 2>&1
    if [ "${fast_install}" == "no" ]; then
        disable_status
        set +e
        (sleep ${sleep_time}; echo "q") | "test/worm" -number 7 > /dev/tty 2>&1
        ncurses_test_exitcode=$?
        set -e
        enable_status
        if [ ${ncurses_test_exitcode} != 0 ]; then
            ncurses_test_success="no"
        fi
    fi
    # Additional test run needed (if the first failed), as the one 
    # above do not use tee (as it ruins the display).
    if [ "${fast_install}" == "no" ] && [ "${ncurses_test_success}" == "no" ]; then
        disable_status
        (sleep ${sleep_time}; echo "q") | "test/worm" -number 7 > "test_log" 2>&1 || :
        enable_status
    fi
    ncurses_test_log="${ncurses_dir}/include/ncurses/test_log"
    if [ "${ncurses_test_success}" == "no" ]; then
        mkdir -p "${ncurses_dir}"
        cp "test_log" "${ncurses_test_log}"
    fi
    cp "AUTHORS" "COPYING" "${ncurses_dir}/include/ncurses/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/ncurses"
    # Write out success notice
    echo "The following has been fully installed:
Program: ncurses
Version: ${ncurses_version}
Date:    $(date)
" >> "${ncurses_dir}/.installation_finished"
fi

# OpenSSL
if [ "${openssl_install}" == "yes" ] && [ "${openssl_installed}" == "no" ]; then
    init_install "OpenSSL"
    ./config shared --prefix="${openssl_dir}" --openssldir="${openssl_dir}/openssl" 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        make test 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && openssl_test_success="no"
    fi
    openssl_test_log="${openssl_dir}/include/openssl/test_log"
    if [ "${openssl_test_success}" == "no" ]; then
        mkdir -p "${openssl_dir}"
        cp "test_log" "${openssl_test_log}"
    fi
    make install 2>&1
    cp "LICENSE" "README" "${openssl_dir}/include/openssl/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/openssl"
    # Write out success notice
    echo "The following has been fully installed:
Program: OpenSSL
Version: ${openssl_version}
Date:    $(date)
" >> "${openssl_dir}/.installation_finished"
fi

# Python
python_version_major=${python_version:0:1}
if [ "${python_install}" == "yes" ] && [ "${python_installed}" == "no" ]; then
    init_install "Python"
    # Set environment variables and configure options used
    # when building againts other libraries.
    with_ensurepip_install=""
    if [ -n "${openssl_dir}" ] && [ -n "${zlib_dir}" ]; then
        with_ensurepip_install="--with-ensurepip=install"
    fi
    if [ -n "${ncurses_dir}" ]; then
        export CPPFLAGS="-I${ncurses_dir}/include/ncurses ${CPPFLAGS}"
        export LD_LIBRARY_PATH="${ncurses_dir}/lib:${LD_LIBRARY_PATH}"
        export LDFLAGS="-L${ncurses_dir}/lib -Wl,-rpath=${ncurses_dir}/lib ${LDFLAGS}"
    fi
    if [ -n "${openssl_dir}" ]; then
        export CPPFLAGS="-I${openssl_dir}/include/openssl ${CPPFLAGS}"
        export LD_LIBRARY_PATH="${openssl_dir}/lib:${LD_LIBRARY_PATH}"
        export LDFLAGS="-L${openssl_dir}/lib -Wl,-rpath=${openssl_dir}/lib ${LDFLAGS}"
        # Modify Modules/Setup.dist in order for Python to use the
        # custom SSL library.
        first_line="$(grep -n 'SSL=' 'Modules/Setup.dist')"
        first_line=${first_line%:*}
        ((last_line = first_line + 3))
        sed -i "${first_line},${last_line}s/.//" "Modules/Setup.dist"
        sed -i "${first_line}s/.*/SSL=${openssl_dir//\//\\\/}/" "Modules/Setup.dist"
    fi
    if [ -n "${zlib_dir}" ]; then
        export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
        export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
        export LDFLAGS="-L${zlib_dir}/lib -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
    fi
    ./configure --enable-shared --prefix="${python_dir}" ${with_ensurepip_install} 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        # Skip tests if using Python 2.x, as they may hang
        if [ ${python_version_major} != 2 ]; then
            make test 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} != 0 ] && python_test_success="no"
        fi
    fi
    python_test_log="${python_dir}/test_log"
    if [ "${python_test_success}" == "no" ]; then
        mkdir -p "${python_dir}"
        cp "test_log" "${python_test_log}"
    fi
    make install 2>&1
    reset_environment
    cp "LICENSE" "README" "${python_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/python"
    # Write out success notice
    echo "The following has been fully installed:
Program: Python
Version: ${python_version}
Date:    $(date)
" >> "${python_dir}/.installation_finished"
fi
# Overwrite the 'python_version' variable with the major.minor version
# and create a python variable, storing the path to the newly installed
# Python interpreter.
if [ -n "${python_dir}" ]; then
    python_version=$("${python_dir}/bin/python${python_version_major}" -c \
                     "from sys import version_info as v; print(str(v.major) + '.' + str(v.minor))")
    python="${python_dir}/bin/python${python_version}"
fi



##############################
# Installing Python packages #
##############################
# Set "pypackage"_installed variables
blessings_installed="no"
cython_installed="no"
cython_gsl_installed="no"
h5py_installed="no"
matplotlib_installed="no"
mpi4py_installed="no"
numpy_installed="no"
pexpect_installed="no"
pip_installed="no"
if [ -n "${python}" ]; then
    for pypackage in blessings cython cython_gsl h5py matplotlib mpi4py numpy pexpect pip; do
        pypackage_installed=$("${python}" -c "
try:
    import ${pypackage}
    print('yes')
except:
    print('no')
"
        )
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi

# Function for downloading Python packages, utilizing pip
pip_download()
{
    # Arguments: Python package name, version. No or blank second
    # argument signifies newest version. The same is if second argument
    # is "upgrade". The second argument can also be a version string
    # that pip understands, e.g. ">=1.4".
    local command_end=""
    if [ -n "${2}" ] && [ "${2}" != "upgrade" ]; then
        if [[ "${2}" == [0-9]* ]]; then
            # Second argument is a specific version
            command_end="==${2}"
        else
            # Second argument is a version string that pip understands
            command_end="${2}"
        fi
    fi
    pip_name="${1//_/}"       # Remove underscores from name
    pip_name="${pip_name,,}"  # Ensure lowercase
    mkdir -p "${top_dir}/tmp/pip"
    # Downloading the Python package
    for n in {1..50}; do
        pip_status="error"
        "${python}" -m pip download -v -v -v                   \
                                   --no-cache-dir              \
                                   --no-binary=:all:           \
                                   --dest="${top_dir}/tmp/pip" \
                                   "${pip_name}${command_end}" 2>&1 || :
        # If the archive exists in the tmp/pip dir,
        # the download completed successfully.
        if ls "${top_dir}/tmp/pip" | grep -i "${pip_name}" > /dev/null 2>&1; then
            pip_status="success"
        fi
        if [ "${pip_status}" == "error" ]; then
            # Pip may be too old to support "download".
            # Try with the (now depricated) "install --download".
            "${python}" -m pip install -v -v -v             \
                                       --no-cache-dir       \
                                       --no-binary=:all:    \
                                       --download           \
                                       "${top_dir}/tmp/pip" \
                                       "${pip_name}${command_end}" 2>&1 || :
            # If the archive exists in the tmp/pip dir,
            # the download completed successfully.
            if ls "${top_dir}/tmp/pip" | grep -i "${pip_name}" > /dev/null 2>&1; then
                pip_status="success"
            fi
        fi
        if [ "${pip_status}" == "error" ]; then
            # Pip may be too old to support "--no-binary".
            # Try with the (now depricated) "--no-use-wheel".
            pip_status="error"
            "${python}" -m pip install -v -v -v             \
                                       --no-cache-dir       \
                                       --no-use-wheel       \
                                       --download           \
                                       "${top_dir}/tmp/pip" \
                                       "${pip_name}${command_end}" 2>&1 || :
            # If the archive exists in the tmp/pip dir,
            # the download completed successfully.
            if ls "${top_dir}/tmp/pip" | grep -i "${pip_name}" > /dev/null 2>&1; then
                pip_status="success"
            fi
        fi
        if [ "${pip_status}" == "error" ]; then
            # Pip may be too old to support "--no-cache-dir".
            # Try without.
            pip_status="error"
            "${python}" -m pip install -v -v -v             \
                                       --no-use-wheel       \
                                       --download           \
                                       "${top_dir}/tmp/pip" \
                                       "${pip_name}${command_end}" 2>&1 || :
            # If the archive exists in the tmp/pip dir,
            # the download completed successfully.
            if ls "${top_dir}/tmp/pip" | grep -i "${pip_name}" > /dev/null 2>&1; then
                pip_status="success"
            fi
        fi
        if [ "${pip_status}" == "success" ]; then
            break
        fi
        sleep ${sleep_time}
    done
    if [ "${pip_status}" == "error" ]; then
        error "Error downloading ${1}"
        exit 1
    fi
}

# Function for installing and upgrading Python packages, utilizing pip
pip_install_pypackage()
{
    # Arguments: Python package name, [version or "upgrade"]
    # (install specific version or update existing version to newest).
    # If second argument is not provided, the newest version
    # will be installed.
    local command_end=""
    if [ "${2}" == "upgrade" ]; then
        current_step="upgradation of ${1}"
        heading "Upgrading ${1}"
        set_status "Upgrading ${1}"
    else
        if [ -n "${2}" ]; then
            current_step="installation of ${1} ${2}"
            heading "Installing ${1} ${2}"
            set_status "Installing ${1} ${2}"
        else
            current_step="installation of ${1}"
            heading "Installing ${1}"
            set_status "Installing ${1}"
        fi
        if [ -n "${2}" ]; then
            command_end="==${2}"
        fi
    fi
    pip_name="${1//_/}"  # Remove underscores from name
    # Download Python package source
    pip_download "${1}" "${2}"
    # Install Python package from source
    if [ "${2}" == "upgrade" ]; then
        "${python}" -m pip install -v -v -v                          \
                                   -b                                \
                                   "${top_dir}/tmp/pip/build"        \
                                   --upgrade                         \
                                   --no-index                        \
                                   --find-links="${top_dir}/tmp/pip" \
                                   "${pip_name}${command_end}" 2>&1
    else
        "${python}" -m pip install -v -v -v                          \
                                   -b                                \
                                   "${top_dir}/tmp/pip/build"        \
                                   --no-index                        \
                                   --find-links="${top_dir}/tmp/pip" \
                                   "${pip_name}${command_end}" 2>&1
    fi
    rm -rf "${top_dir}/tmp/pip"
}

# Upgrade pip
if [ "${pip_install}" == "yes" ] && [ "${python_installed}" == "no" ]; then
    pip_install_pypackage "pip" "upgrade"
fi

# Upgrade all packages pre-installed
# with the newly installed Python distribution.
if [ "${python_install}" == "yes" ] && [ "${python_installed}" == "no" ]; then
    installed_packages="$("${python}" -c "
import pip
print('\n'.join([i.key for i in pip.get_installed_distributions()]))
")"
    while read package; do
        for n in {1..50}; do
            pip_success="yes"
            pip_install_pypackage "${package}" "upgrade" || pip_success="no"
            if [ "${pip_success}" == "yes" ]; then
                break
            fi
        done
    done <<< "${installed_packages}"
fi

# Install Python packages from PyPI

# Blessings
if [ "${blessings_install}" == "yes" ] && [ "${blessings_installed}" == "no" ]; then
    pip_install_pypackage "Blessings" "${blessings_version}"
fi

# Cython
if [ "${cython_install}" == "yes" ] && [ "${cython_installed}" == "no" ]; then
    pip_install_pypackage "Cython" "${cython_version}"
fi

# The Cython_GSL Python package
if [ "${cython_gsl_install}" == "yes" ] && [ "${cython_gsl_installed}" == "no" ]; then
    export LD_LIBRARY_PATH="${gsl_dir}/lib:${LD_LIBRARY_PATH}"
    pip_install_pypackage "Cython_GSL" "${cython_gsl_version}"
    reset_environment
fi

# NumPy
if [ "${numpy_install}" == "yes" ] && [ "${numpy_installed}" == "no" ]; then
    pip_install_pypackage "NumPy" "${numpy_version}"
fi

# Matplotlib (as Matplotlib has a hard time finding FreeType,
# some hacks are needed).
if [ "${matplotlib_install}" == "yes" ] && [ "${matplotlib_installed}" == "no" ]; then
    current_step="installation of Matplotlib ${matplotlib_version}"
    heading "Installing Matplotlib ${matplotlib_version}"
    set_status "Installing Matplotlib ${matplotlib_version}"
    # Download matplotlib itself
    pip_download "matplotlib" "${matplotlib_version}"
    # Matplot is the only Python package needed by CO𝘕CEPT, which
    # depends on other Python packages not directly used by CO𝘕CEPT.
    # Most often these dependencies are downloaded automatically by the
    # previous command. In case of failure, we do it manually.
    if [ "${numpy_preinstalled}" == "yes" ] || [ "${numpy_install}" == "yes" ]; then
        # NumPy already installed
        deps=(        "pyparsing"                 "python-dateutil" "pytz" "cycler")
        # From http://matplotlib.org/users/installing.html, except for pyparsing,
        # where !=2.0.0,>=1.5.6 is taken from setupext.py of the matplotlib source.
        dep_versions=(">=1.5.6,!=2.0.0,!=2.0.4"   ">=1.1,!=2.1"     ""     ">=0.9")
    else
        # NumPy not installed. Add it as a matplotlib dependency
        deps=(        "numpy" "pyparsing"                 "python-dateutil" "pytz" "cycler")
        # From http://matplotlib.org/users/installing.html, except for pyparsing,
        # where !=2.0.0,>=1.5.6 is taken from setupext.py of the matplotlib source.
        dep_versions=(">=1.6" ">=1.5.6,!=2.0.0,!=2.0.4"   ">=1.1,!=2.1"     ""     ">=0.9")
    fi
    # An illegal version of pyparsing may be downloaded by Matplotlib!
    pyparsing_downloaded="$(ls "${top_dir}/tmp/pip" | grep -i "pyparsing" || :)"
    illegal_pyparsings=("2.0.0" "2.0.4")
    for ((i=0; i<${#illegal_pyparsings[@]}; i+=1)); do
        ((j = i + 1))
        if [[ "${pyparsing_downloaded}" == "pyparsing-${illegal_pyparsings[i]}"* ]]; then
            # Illegal pyparsing downloaded!
            rm -f "${top_dir}/tmp/pip/pyparsing"*
            break
        fi
    done
    for ((i=0; i<${#deps[@]}; i+=1)); do
        if ! ls "${top_dir}/tmp/pip" | grep -i "${deps[i]}" > /dev/null 2>&1; then
            pip_download "${deps[i]}" "${dep_versions[i]}"
        fi
    done
    # Install matplotlib
    cd "${top_dir}/tmp/pip"
    extract "matplotlib"* "yes"
    cd "matplotlib"*
    cp "setup.cfg.template" "setup.cfg"
    sed -i "/basedirlist/c\basedirlist = ${freetype_dir}" "setup.cfg"
    cp -r "${freetype_dir}/include/freetype"*/* "${freetype_dir}/include"
    export CPPFLAGS="-I${freetype_dir}/include                              \
                     -I${freetype_dir}/include/freetype"*"                  \
                     -I${libpng_dir}/include                                \
                     -I${libpng_dir}/include/libpng${libpng_version_majors} \
                     -I${zlib_dir}/include ${CPPFLAGS}"
    export LDFLAGS="-L${freetype_dir}/lib          \
                    -Wl,-rpath=${freetype_dir}/lib \
                    -L${libpng_dir}/lib            \
                    -Wl,-rpath=${libpng_dir}/lib   \
                    -L${zlib_dir}/lib              \
                    -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
    export PATH="${freetype_dir}/bin:${libpng_dir}/bin:${PATH}"
    export LD_LIBRARY_PATH="${libpng_dir}/lib:${zlib_dir}/lib:${LD_LIBRARY_PATH}"
    export PKG_CONFIG_PATH="${libpng_dir}/lib/pkgconfig:${zlib_dir}/lib/pkgconfig:\
${PKG_CONFIG_PATH}"
    "${python}" -m pip install -v -v -v                          \
                               -b                                \
                               "${top_dir}/tmp/pip/build"        \
                               --no-index                        \
                               --find-links="${top_dir}/tmp/pip" \
                               . 2>&1
    reset_environment
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/pip"
fi

# MPI4Py
if [ "${mpi4py_install}" == "yes" ] && [ "${mpi4py_installed}" == "no" ]; then
    export PATH="${mpi_dir}/bin:${PATH}"
    pip_install_pypackage "MPI4Py" "${mpi4py_version}"
    reset_environment
fi

# Pexpect (this has to be before H5Py, for whatever reason)
if [ "${pexpect_install}" == "yes" ] && [ "${pexpect_installed}" == "no" ]; then
    pip_install_pypackage "Pexpect" "${pexpect_version}"
fi

# H5Py (manual invocation of setup.py is needed
# as --mpi needs to be supplied).
if [ "${h5py_install}" == "yes" ] && [ "${h5py_installed}" == "no" ]; then
    # Note that the Python package dependencies NumPy, Cython and six
    # (ships with matplotlib) are already installed.
    current_step="installation of H5Py ${h5py_version}"
    heading "Installing H5Py ${h5py_version}"
    set_status "Installing H5Py ${h5py_version}"
    pip_download "h5py" "${h5py_version}"
    cd "${top_dir}/tmp/pip"
    extract "h5py"* "yes"
    cd "h5py"*
    export CC="${mpi_dir}/bin/mpicc"
    "${python}" setup.py configure --mpi --hdf5="${hdf5_dir}" 2>&1
    "${python}" setup.py install 2>&1
    reset_environment
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/pip"
fi



###########################
# The CO𝘕CEPT code itself #
###########################
# The CO𝘕CEPT code
concept="${concept_dir}/concept"
logs_dir="${concept_dir}/logs"
output_dir="${concept_dir}/output"
params_dir="${concept_dir}/params"
tests_dir="${concept_dir}/tests"
utilities_dir="${concept_dir}/utilities"
Gadget2_dir="${gadget_dir}/Gadget2"
installer="${top_dir}/installer"
mpicc="${mpi_dir}/bin/mpicc"
mpiexec="${mpi_dir}/bin/mpiexec"
if [ "${concept_install}" == "yes" ] && [ "${concept_installed}" == "no" ]; then
    init_install "CONCEPT"
    # Move everything (but the .paths file) from the concept-master 
    # directory to "top_dir".
    mv ./* "${top_dir}"
    cd "${top_dir}"; rm -rf "${top_dir}/tmp/concept"
    # Create directories
    mkdir -p "${logs_dir}"
    mkdir -p "${output_dir}"
    mkdir -p "${params_dir}"
    # Create the .paths file, 
    # storing important paths used by the program.
    current_step="creation of the .paths file"
    printf "\nWriting paths to .paths\n"
    set_status "Writing paths to .paths"
    echo "# This file contains absolute paths to directories and files used by the
# program. You must manually edit the paths below. All other files rely on
# these paths, as they are not given anywhere else.

###############
# Directories #
###############
# Directory containing the CO𝘕CEPT source code
concept_dir='${concept_dir}'
# Directory of FFTW
fftw_dir='${fftw_dir}'
# Directory of FFTW2, used by GADGET
fftw_for_gadget_dir='${fftw_for_gadget_dir}'
# Directory of Gadget2
gadget_dir='${gadget_dir}'
# Directory containing the GADGET2 source code
Gadget2_dir='${Gadget2_dir}'
# Directory of GSL
gsl_dir='${gsl_dir}'
# Directory of HDF5
hdf5_dir='${hdf5_dir}'
# Directory of ImageMagick
imagemagick_dir='${imagemagick_dir}'
# Directory of libpng
libpng_dir='${libpng_dir}'
# Directory containing CO𝘕CEPT log files
logs_dir='${logs_dir}'
# Directory of MPI
mpi_dir='${mpi_dir}'
# Directory containing CO𝘕CEPT output
output_dir='${output_dir}'
# Directory containing CO𝘕CEPT parameter files
params_dir='${params_dir}'
# Directory of Python
python_dir='${python_dir}'
# Directory containing tests for the CO𝘕CEPT code
tests_dir='${tests_dir}'
# Top level directory, containing e.g. README.md
top_dir='${top_dir}'
# Directory containing utilities for the CO𝘕CEPT code
utilities_dir='${utilities_dir}'
# Directory of zlib
zlib_dir='${zlib_dir}'

#########
# Files #
#########
# The executable script of the CO𝘕CEPT code
concept='${concept}'
# The installer script
installer='${installer}'
# The MPI C compiler
mpicc='${mpicc}'
# The MPI executable
mpiexec='${mpiexec}'
# The Python interpreter
python='${python}'
" > "${dotpaths}"
    # CO𝘕CEPT will be tested later
fi



#####################################################
# Install GADGET, used for testing the CO𝘕CEPT code #
#####################################################
# FFTW 2.x (GADGET2 is incompatible with FFTW 3.x)
if [ "${fftw_for_gadget_install}" == "yes" ] && [ "${fftw_for_gadget_installed}" == "no" ]; then
    init_install "FFTW for GADGET"
    export CC="${mpi_dir}/bin/mpicc"
    export MPICC="${mpi_dir}/bin/mpicc"
    export CFLAGS="-O3 -fPIC"
    export CPPFLAGS="-I${mpi_dir}/include"
    export LDFLAGS="-L${mpi_dir}/lib"
    export MPILIBS="-lmpi"
    export PATH="${mpi_dir}/bin:${PATH}"
    # Double-precision
    ./configure --enable-shared      \
                --enable-mpi         \
                --enable-openmp      \
                --enable-threads     \
                --enable-type-prefix \
                --prefix="${fftw_for_gadget_dir}" 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        make check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && fftw_for_gadget_test_success="no"
    fi
    make install 2>&1
    # Single-precision
    make clean
    ./configure --enable-shared      \
                --enable-mpi         \
                --enable-openmp      \
                --enable-threads     \
                --enable-float       \
                --enable-type-prefix \
                --prefix="${fftw_for_gadget_dir}" 2>&1
    make 2>&1
    if [ "${fast_install}" == "no" ]; then
        make check 2>&1 | tee -a "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && fftw_for_gadget_test_success="no"
    fi
    fftw_for_gadget_test_log="${fftw_for_gadget_dir}/test_log"
    if [ "${fftw_for_gadget_test_success}" == "no" ]; then
        mkdir -p "${fftw_for_gadget_dir}"
        cp "test_log" "${fftw_for_gadget_test_log}"
    fi
    make install 2>&1
    reset_environment
    cp "COPYING" "README" "${fftw_for_gadget_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw_for_gadget"
    # Write out success notice
    echo "The following has been fully installed:
Program: FFTW for GADGET
Version: ${fftw_for_gadget_version}
Date:    $(date)
" >> "${fftw_for_gadget_dir}/.installation_finished"
fi

# GADGET
if [ "${gadget_install}" == "yes" ] && [ "${gadget_installed}" == "no" ]; then
    init_install "GADGET"
    mkdir -p "${gadget_dir}"
    mv ./* "${gadget_dir}"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gadget"
    # GADGET will be tested as part of the CO𝘕CEPT test suite.
    # Write out success notice.
    echo "The following has been fully installed:
Program: GADGET
Version: ${gadget_version}
Date:    $(date)
" >> "${gadget_dir}/.installation_finished"
fi

# All installation done
rm -rf "${top_dir}/tmp"


##############################
# Testing GADGET and CO𝘕CEPT #
##############################
if [ "${fast_install}" == "no" ] && [ "${concept_install}" == "yes" ] && [ "${concept_installed}" == "no" ]; then
    # Run basic CO𝘕CEPT test to test the environment
    current_step="basic test of ${esc_concept}"
    heading "Basic test of ${esc_concept}"
    set_status "Basic test of ${esc_concept_double_backslashes}"
    cd "${concept_dir}"
    concept_test_log="${concept_dir}/test_log"
    "${concept}" -t "basic" 2>&1 | tee "${concept_test_log}"
    [ ${PIPESTATUS[0]} != 0 ] && concept_test_success="no"
    if  [ "${gadget_install}" == "yes" ]; then
        # Run GADGET test if basic CO𝘕CEPT test finished successfully
        if [ "${concept_test_success}" == "yes" ]; then
            current_step="testing GADGET"
            heading "Testing GADGET"
            set_status "Testing GADGET"
            gadget_test_log="${gadget_dir}/test_log"
            "${concept}" -t "gadget" 2>&1 | tee "${gadget_test_log}"
            [ ${PIPESTATUS[0]} != 0 ] && gadget_test_success="no"
            # Clean test_log if test is successfull
            if [ "${gadget_test_success}" == "yes" ]; then
                rm -f "${gadget_test_log}"
            fi
        fi
        # Run complete CO𝘕CEPT test suite if basic CO𝘕CEPT test
        # finished successfully.
        if [ "${concept_test_success}" == "yes" ]; then
            current_step="testing ${esc_concept}"
            heading "Testing ${esc_concept}"
            set_status "Testing ${esc_concept_double_backslashes}"
            "${concept}" -t "all" 2>&1 | tee "${concept_test_log}"
            [ ${PIPESTATUS[0]} != 0 ] && concept_test_success="no"
            # Clean test_log if test is successfull
            if [ "${concept_test_success}" == "yes" ]; then
                rm -f "${concept_test_log}"
                make distclean
            fi
        fi
    fi
    cd "${top_dir}"
    # Write out success notice. Place it in the GADGET directory
    # in order to minimize the number of files in the CO𝘕CEPT directory.
    echo "The following has been fully installed:
Program: CONCEPT
Version: ${concept_version}
Date:    $(date)
" >> "${gadget_dir}/.installation_finished"
fi



#################
# Final notices #
#################
# Copyright notice
disable_status
copyright_notice()
{
    # Arguments: Program/package name, text if installed by this script
    if eval "[ \"\${${1}_install}\" == \"yes\" ]"; then
        printf "${2}\n"
    fi
}
if [ "${install_anything}" == "yes" ]; then
    current_step="copyright notice"
    heading "Copyright notice"
    if [ "${concept_install}" == "yes" ]; then
        printf "${esc_concept} has been installed along with the following dependencies:\n"
    else
        printf "The following software have been installed:\n"
    fi
    copyright_notice "fftw_for_gadget" "FFTW 2"
    copyright_notice "fftw"            "FFTW 3"
    copyright_notice "freetype"        "FreeType"
    copyright_notice "gadget"          "GADGET"
    copyright_notice "gsl"             "GSL"
    copyright_notice "hdf5"            "HDF5"
    copyright_notice "imagemagick"     "ImageMagick"
    copyright_notice "libpng"          "libpng"
    copyright_notice "mpi"             "MPICH"
    copyright_notice "ncurses"         "ncurses"
    copyright_notice "openssl"         "OpenSSL"
    copyright_notice "zlib"            "zlib"
    copyright_notice "python"          "Python"
    copyright_notice "blessings"       "$(printf ${en_quad}%.s {1..4})Blessings"
    copyright_notice "cython"          "$(printf ${en_quad}%.s {1..4})Cython"
    copyright_notice "cython_gsl"      "$(printf ${en_quad}%.s {1..4})Cython_GSL"
    copyright_notice "h5py"            "$(printf ${en_quad}%.s {1..4})H5Py"
    copyright_notice "matplotlib"      "$(printf ${en_quad}%.s {1..4})Matplotlib"
    copyright_notice "mpi4py"          "$(printf ${en_quad}%.s {1..4})MPI4Py"
    copyright_notice "numpy"           "$(printf ${en_quad}%.s {1..4})NumPy"
    copyright_notice "pexpect"         "$(printf ${en_quad}%.s {1..4})Pexpect"
    printf "\nThese have been installed into separate directories in
\"${top_dir}\"
Any use of ${esc_concept} must conform to the license terms of the above
software in addition to its own. These can be found in the separate
installation directories.\n"
fi
# Notice about test errors
current_step="erroneous tests notice"
any_test_error_notices="no"
erroneous_test_notice()
{
    # Arguments: Program name, [alternative message]
    progname="${1// /_}"
    progname="${progname,,}"
    test_success="yes"
    eval "test_success=\"\${${progname}_test_success}\""
    if [ "${test_success}" == "no" ]; then
        if [ "${any_test_error_notices}" == "no" ]; then
            # First test error notice
            heading "Erroneous tests notice"
            any_test_error_notices="yes"
        else
            # Add newline between notices
            echo
        fi
        eval "test_log_path=\"\${${progname}_test_log}\""
        printf "${esc_bold}${esc_red}Warning: ${esc_normal}"
        real_name="${1/CONCEPT/$esc_concept}"
        if [ "${real_name}" == "MPI" ]; then
            real_name="MPICH"
        fi
        printf "Some tests of ${real_name} did not pass successfully.\n"
        if [ -n "${2}" ]; then
            printf "${2}\n"
        else
            printf "As ${real_name} did seem to install correctly, "
            printf "this is usually not of any concern.\n"
        fi
        printf "The logged output of the tests can be found in\n"
        printf "\"${test_log_path}\"\n"
    fi
}
erroneous_test_notice "FFTW for GADGET"
erroneous_test_notice "FFTW"
erroneous_test_notice "FreeType"
erroneous_test_notice "GADGET"
erroneous_test_notice "GSL"
erroneous_test_notice "HDF5"
erroneous_test_notice "ImageMagick"
erroneous_test_notice "libpng"
erroneous_test_notice "MPI"
erroneous_test_notice "ncurses"
erroneous_test_notice "OpenSSL"
erroneous_test_notice "Python"
erroneous_test_notice "zlib"
erroneous_test_notice "CONCEPT" \
                      "${esc_italic}This should usually be taken seriously!${esc_no_italic}"
if [ "${any_test_error_notices}" == "yes" ]; then
    printf "The logged output of the entire installation process can be found in\n"
    printf "\"${log}\"\n"
fi

# Subprocess complete
printf "\n\n\n"
disable_status
if [ "${any_test_error_notices}" == "no" ]; then
    successfully_finish_status
fi
# Deactivate trap before exiting
trap : 0
) > "${log}" &
log_pid=$!
# End of subprocess #
#####################



################
# Display loop #
################
# Wait for the install log to be created
slept=0
while [ ! -f "${log}" ]; do
    sleep 1
    # After having slept for a long time, check that the job
    # has not just finished without producing a log file.
    ((slept += 1))
    if [ ${slept} == 30 ]; then
        error "Could not create the log file \"${log}\""
        exit 1
    fi
done

# Continuously print the tail of the install log
printf "\n\n"
tail -f "${log}" --pid ${log_pid} | while read line; do
    if [[ "${line}" == "${status_prefix}"* ]]; then
        status_backup_="${status}"
        status=${line:${status_prefix_length}}
        if [ "${status}" == "${status_disable}" ]; then
            # Disable status
            status_visible="${status_off}"
            status_backup="${status_backup_}"
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
        elif [ "${status}" == "${status_enable}" ]; then
            # Enable status
            status_visible="${status_on}"
            status="${status_backup}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        elif [ "${status}" == "${status_finish}" ]; then
            # Display loop complete. Do nothing
            :
        elif [ "${status_visible}" == "${status_on}" ]; then
            # Normal status update
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        fi
    else
        if [ "${status_visible}" == "${status_on}" ]; then
            # Line with status enabled
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
            printf "%s\n" "${line}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        else
            # Line with status disabled
            printf "%s\n" "${line}"
        fi
    fi
done

# Remove the log file if no errors occured
if [ "$(tail -n 1 "${log}")" == "${status_prefix}${status_finish_successfully}" ]; then
    rm -f "${log}"
fi

# Installation complete. Deactivate trap before exiting.
if [ "${say_goodbye}" != "no" ]; then
    printf "${esc_bold}${esc_green}${esc_concept} installation finished${esc_normal}\n"
fi
trap : 0
