# This file is part of CO𝘕CEPT, the cosmological 𝘕-body code in Python.
# Copyright © 2015-2016 Jeppe Mosgaard Dakin.
#
# CO𝘕CEPT is free software: You can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CO𝘕CEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CO𝘕CEPT. If not, see http://www.gnu.org/licenses/
#
# The auther of CO𝘕CEPT can be contacted at dakin(at)phys.au.dk
# The latest version of CO𝘕CEPT is available at
# https://github.com/jmd-dk/concept/



# This is the makefile for the CO𝘕CEPT code. Preferebly you should not
# interact with this file directly, but rather use the concept script to
# build and run the code.

# Use the bash shell
SHELL = /usr/bin/env bash



##############################
# Specification of filenames #
##############################
# Modules which should be cythonized and compiled
pyfiles = analysis      \
          commons       \
          communication \
          ewald         \
          graphics      \
          gravity       \
          integration   \
          main          \
          mesh          \
          snapshot      \
          species       \
          utilities
# Filename of the .pyx preprocessor script
pyxpp = pyxpp.py
# List of files generated in the concept directory by running the code,
# which should be deleted by distclean.
files_auxiliary = jobscript .ewald_gridsize* .fftw_wisdom_gridsize*
# List of files in the utilities directory
# generated by using the utilities.
files_utilities = convert.params.full   \
                  info.params.full      \
                  powerspec.params.full \
                  render.params.full    \
                  update_new



################################################
# Environment information from the .paths file #
################################################
# Get the path to the .paths file
paths_filename = $(shell this_dir="$$( cd "$$( dirname "$${BASH_SOURCE[0]}" )" && pwd )"; \
				         path="$${this_dir}";                                             \
				         while :; do                                                      \
				             if [ -f "$${path}/.paths" ]; then                            \
				                 paths_filename="$${path}/.paths";                        \
				                 break;                                                   \
				             fi;                                                          \
				             if [ "$${path}" == "/" ]; then                               \
				                 paths_filename='fail';                                   \
				                 break;                                                   \
				             fi;                                                          \
				             path="$$(dirname "$${path}")";                               \
				         done;                                                            \
				         echo "$${paths_filename}";                                       \
				   )
ifeq ($(paths_filename), fail)
    $(error Could not find the .paths file)
endif
# Include (absolute) paths from the .paths file
include $(paths_filename)
# Function which takes in a quoted argument. If this argument is
# a path (perhaps prefixed with e.g. -I) and it is located near this
# Makefile, the return value is the relative path. Otherwise, the
# return value is just the untouched argument.
# A backslash will be placed before spaces.
sensible_path = $(shell $(python) -c "import os;                                                  \
                                      path = $1;                                                  \
                                      prefix = ([''] + [prefix for prefix in                      \
                                                        ('-I', '-L', '-Wl,-rpath=')               \
                                                        if path.startswith(prefix)]               \
                                                )[-1];                                            \
                                      abspath = path[len(prefix):];                               \
                                      relpath = os.path.relpath(abspath, '.');                    \
                                      path = abspath if relpath.startswith('../..') else relpath; \
                                      path = prefix + path;                                       \
                                      path = path.replace(' ', chr(92) + ' ');                    \
                                      path = path.replace(2*chr(92), chr(92));                    \
                                      path = path.strip();                                        \
                                      print(path);                                                \
                                      "                                                           \
                  )
# Transform all the included paths to sensible paths
# to reduce screen clutter when making.
paths = $(shell grep -o '.*=' $(paths_filename) | sed 's/.$$//')
$(foreach path,$(paths),$(eval $(path)=$(call sensible_path,$($(path)))))



########################################
# Settings for compilation and linking #
########################################
# Function which eliminates duplicates
uniq = $(strip $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1))))
# The python configuration script
python_config = $(shell readlink -f $$(which $(python)))-config
# Options passed when cythonizing .pyx files
python_version_major = $(shell $(python) -c "import sys; print(sys.version_info.major)")
cythonflags = -$(python_version_major) -a
# Includes
fftw_incl   = -I$(fftw_dir)/include
gsl_incl    = -I$(gsl_dir)/include
mpi_incl    = -I$(mpi_dir)/include
python_incl = $(shell $(python_config) --includes)
includes    = $(fftw_incl) $(gsl_incl) $(mpi_incl) $(python_incl)
# Compiler options
CC                = $(mpicc)
unwanted_warnings = unreachable-code \
                    uninitialized    \
                    unused-result    \
                    unused-but-set-variable
python_cflags     = $(filter-out $(addprefix -W,$(unwanted_warnings)), \
                                 $(shell $(python_config) --cflags))
other_cflags      = -O3                  \
                    -pthread             \
                    -std=c99             \
                    -fno-strict-aliasing \
                    -fPIC                \
                    -Wall                \
                    -Wextra              \
                    $(addprefix -Wno-,$(unwanted_warnings))
CFLAGS            = $(call uniq, $(foreach flag, $(python_cflags)                \
                                                 $(other_cflags)                 \
                                                 $(includes)                     \
                                                 ,                               \
                                                 $(call sensible_path,'$(flag)') \
                                   )                                             \
                      )
# Libraries to link
fftw_libs     = -L$(fftw_dir)/lib -Wl,-rpath=$(fftw_dir)/lib -lfftw3_mpi -lfftw3
gsl_libs      = -L$(gsl_dir)/lib -Wl,-rpath=$(gsl_dir)/lib -lgsl -lgslcblas -lm
mpi_libs      = -L$(mpi_dir)/lib -Wl,-rpath=$(mpi_dir)/lib -lmpi
python_libdir = $(shell $(python) -c "import sysconfig;                          \
                                      print(sysconfig.get_config_var('LIBDIR')); \
                                      "                                          \
                  )
python_libs   = -L$(python_libdir) -Wl,-rpath=$(python_libdir) $(shell $(python_config) --libs)
other_libs    = -Wl,-O3
LDLIBS        = $(call uniq, $(foreach flag, $(fftw_libs)                     \
                                             $(gsl_libs)                      \
                                             $(mpi_libs)                      \
                                             $(python_libs)                   \
                                             $(other_libs)                    \
                                             ,                                \
                                              $(call sensible_path,'$(flag)') \
                               )                                              \
                  )
# Linker options
python_ldflags = $(shell $(python_config) --ldflags)
other_ldflags  = -shared
LDFLAGS        = $(call uniq, $(foreach flag, $(python_ldflags)               \
                                              $(other_ldflags)                \
                                              ,                               \
                                              $(call sensible_path,'$(flag)') \
                                )                                             \
                   )



###################
# Primary targets #
###################
# The below recipes are responsible for the
# .py --> (.pyx --> .pxd) --> (.c + .html) --> .o --> .so build chain.
# For each module, a heading are printed at the beginning of its
# build process. The 'build_status' variable is used as a flag,
# controlling these headings.
define heading
$(python) -c "from blessings import Terminal;                                       \
              terminal = Terminal(force_styling=True);                              \
              new_module = '$(current_module)' != '$(last_module)';                 \
              print('\n' if new_module and '$(last_module)' else '', end='');       \
              print(terminal.bold_yellow('Building the $(current_module) module\n') \
                    if new_module else '', end='');                                 \
              "
$(eval last_module = $(current_module))
endef
analysis.so:      current_module=analysis
commons.so:       current_module=commons
communication.so: current_module=communication
ewald.so:         current_module=ewald
graphics.so:      current_module=graphics
gravity.so:       current_module=gravity
integration.so:   current_module=integration
main.so:          current_module=main
mesh.so:          current_module=mesh
snapshot.so:      current_module=snapshot
species.so:       current_module=species
utilities.so:     current_module=utilities

# Make all compiled python modules.
# When finished, update time stamps so that all dependencies are
# synchronized (this is needed because .pxd files are only updated
# when their contents actually change. That is, `make pyfile.pxd` does
# not necessarily update the timestamp of pyfile.pxd, even though its
# rule is run. This makes .c (and therefore .o
# and .so) files dependent on such .pxd files not up-to-date).
all: $(addsuffix .so, $(pyfiles))
	@# This suppresses "make: Nothing to be done for `all'."
ifeq ($(MAKELEVEL),0)
	@$(MAKE) -s -t $@
endif
.PHONY: all

# Link object files into shared object Python modules
$(addsuffix .so, $(pyfiles)): %.so: %.o
	@$(call heading)
	$(CC) $< -o $@ $(LDFLAGS) $(LDLIBS)

# Compile C source files into object files
$(addsuffix .o, $(pyfiles)): %.o: %.c
	@$(call heading)
	$(CC) $(CFLAGS) -c -o $@ $<

# Cythonize .pyx and .pxd files into C source files
# (and also produce the annotated .html file).
$(addsuffix .c, $(pyfiles)): %.c: %.pyx %.pxd
	@$(call heading)
	$(python) -m cython $(cythonflags) $<
# Same as above (for explicit builds of html)
$(addsuffix .html, $(pyfiles)): %.html: %.pyx %.pxd
	$(python) -m cython $(cythonflags) $<

# Write .pxd files from .pyx files using the pyxpp script
$(addsuffix .pxd, $(pyfiles)): %.pxd: %.pyx $(pyxpp)
	@$(call heading)
	$(python) -B $(pyxpp) $<

# Write .pyx files from .py files using the pyxpp script
$(addsuffix .pyx, $(pyfiles)): %.pyx: %.py $(pyxpp) $(MAKEFILE_LIST)
	@$(call heading)
	$(python) -B $(pyxpp) $<



###########################
# Additional dependencies #
###########################
# Add any additional target dependencies here.
# - Every cimport statement in a .pyx/.pxd leads to a dependency of the
#   form .c: imported_module.pxd
# - Implicit cimport statements occur after 'from commons import *'.
#   Also, every module except commons implicitly cimport cclasses
#   from the snapshot and species modules.
analysis.c:                   commons.pxd                                   graphics.pxd                             mesh.pxd snapshot.pxd species.pxd
commons.c:
communication.c:              commons.pxd                                                                                     snapshot.pxd species.pxd
ewald.c:                      commons.pxd                                                                            mesh.pxd snapshot.pxd species.pxd
graphics.c:                   commons.pxd communication.pxd                                                                   snapshot.pxd species.pxd
gravity.c:                    commons.pxd communication.pxd ewald.pxd                                                mesh.pxd snapshot.pxd species.pxd
integration.c:                commons.pxd                                                                                     snapshot.pxd species.pxd
main.c:          analysis.pxd commons.pxd                                   graphics.pxd             integration.pxd          snapshot.pxd species.pxd utilities.pxd
mesh.c:                       commons.pxd communication.pxd           fft.c                                                   snapshot.pxd species.pxd
snapshot.c:                   commons.pxd communication.pxd                                                                                species.pxd
species.c:                    commons.pxd communication.pxd                              gravity.pxd                 mesh.pxd snapshot.pxd
utilities.c:     analysis.pxd commons.pxd communication.pxd                 graphics.pxd                                      snapshot.pxd species.pxd



###################
# Cleanup targets #
###################
.PHONY: clean clean_auxiliary clean_logs clean_output clean_tests clean_utilities distclean
# Remove all compiled files
clean:
	$(RM) $(foreach ext,pyc pyx pxd c o so so_ html,$(addsuffix .$(ext), $(pyfiles)))
	$(RM) -r __pycache__
# Remove files generated by running the program
clean_auxiliary:
	$(RM) $(files_auxiliary)
# Remove log files
clean_logs:
	$(RM) $(logs_dir)/* $(logs_dir)/.[^.]*
# Remove output files
clean_output:
	$(RM) -r $(output_dir)/* $(output_dir)/.[^.]*
# Remove parameter files in the params dir ending with .params
clean_params:
	$(RM) -r $(params_dir)/*.params* $(params_dir)/.[^.]*.params*
# Remove files produced by running tests
clean_tests:
	$(foreach clean_file,$(wildcard $(tests_dir)/*/clean),$(clean_file);)
# Remove files produced by the utilities in the utilities directory
clean_utilities:
	$(RM) $(addprefix $(utilities_dir)/,$(files_utilities))
	$(RM) -r $(top_dir)/concept_backup $(top_dir)/tmp
# Remove all unnecessary files,
# leaving CO𝘕CEPT in a distribution ready state.
distclean: clean clean_auxiliary clean_logs clean_output clean_params clean_tests clean_utilities

