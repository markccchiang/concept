#!/bin/bash

# This script runs the Nbody code.
# Run the script with the -h option to get help

# Filenames
this_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
top_dir=$(dirname ${this_dir})
this_file=$(readlink -f "$0")
python=${top_dir}/anaconda/bin/python
mpiexec=${top_dir}/openmpi/bin/mpiexec

# Default values of command-line arguments
nprocs=1
params=${this_dir}/params/default
main=${this_dir}/main.py
pure_python=0

# Use Python's argparse module to handle command-line arguments
args=(`${python} -c "
import argparse
import sys
from os.path import basename, dirname
# Enables Python to write directly to screen when asked for help
if any(h in sys.argv for h in ['-h', '--he', '--hel', '--help']):
    sys.stdout = sys.stderr
# Set the filename of the script
sys.argv[0] = '${this_file}'
# Setup command-line arguments
parser = argparse.ArgumentParser(description='Run the N-body code.')
parser.add_argument('-n', '--nprocs',
                    help='Number of processes.',
                    type=int,
                    default=${nprocs},
                    )
parser.add_argument('-p', '--params',
                    help='Parameterfile to use',
                    default='${params}',
                    )
parser.add_argument('-m', '--main',
                    help='Entry point of the code',
                    default='${main}',
                    )
parser.add_argument('--pure-python',
                    help='Run in pure Python mode',
                    default=${pure_python},
                    action='store_true',
                    )
args = parser.parse_args()
# Warnings when basic parameters are not supplied
unspecified_nprocs = False
unspecified_params = False
arg = '--nprocs'
if not any(n in sys.argv for n in ['-n'] + [arg[:i] for i in range(4, len(arg) + 1)]):
    unspecified_nprocs = True
arg = '--params'
if not any(p in sys.argv for p in ['-p'] + [arg[:i] for i in range(4, len(arg) + 1)]):
    if basename(dirname(args.main)) == 'tests':
        # Running a test but no parameterfile specified!
        args.params = dirname(args.main) + '/params_' + basename(args.main)
    else:
        unspecified_params = True
# Print out the arguments.
# These will be captured in the bash 'args' variable
print(args.nprocs,
      args.params,
      args.main,
      int(args.pure_python),
      int(unspecified_nprocs),
      int(unspecified_params)
      )
" "$@"`)
nprocs=${args[0]}
params=${args[1]}
main=${args[2]}
pure_python=${args[3]}
unspecified_nprocs=${args[4]}
unspecified_params=${args[5]}
if [ ${#args[@]} -ne 6 ]; then
    exit 1
fi

# Set up error trapping
ctrl_c()
{
    trap : 0
    exit 2
}
abort()
{
    printf "\e[1m\e[91mAn error occurred!\e[0m\n" >&2
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# Print warnings for unspecified parameters
if [ ${unspecified_nprocs} == 1 ]; then
    echo "Number of processes not specified - Will use ${nprocs}"
fi
if [ ${unspecified_params} == 1 ]; then
    echo "Parameterfile not specified - Will use ${params}"
fi

# Is nprocs a power of 2?
legal_nprocs=`${python} -c "
from numpy import log2
exponent = log2(${nprocs})
if exponent == int(exponent):
    legal_nprocs = 1
else:
    legal_nprocs = 0
print(legal_nprocs)
"`
if [ ${legal_nprocs} -eq 0 ]; then
    echo "Error: Number of processes (${nprocs}) is not a power of 2!"
    #exit 1
fi

# Do the parameterfile and the main file exist?
if [ ! -f "${params}" ]; then
    echo "Error: "${params}" does not exist!"
    exit 1
fi
if [ ! -f "${main}" ]; then
    echo "Error: "${main}" does not exist!"
    exit 1
fi

# Prompt the user for the secure shell password,
# if the live frame should be scp'ed.
(cd ${this_dir} && make clean_params_so >/dev/null)
(cd ${this_dir} && make params.py paramsfile=${params} >/dev/null)
args=(`${python} -c "
from params import liveframe, scp_liveframe
from getpass import getpass
import pexpect
password = ''
if liveframe != '' and scp_liveframe != '':
    # Get scp authentication message
    scp_cmd = 'scp ${this_file} ' + scp_liveframe
    scpp = pexpect.spawn(scp_cmd, timeout=10)
    msg = scpp.expect(['password:', 'passphrase', pexpect.EOF, 'continue connecting (yes/no)?'])
    prompt = ''
    if msg == 0:
        # scp asks for password
        prompt = scpp.before.decode('utf-8') + 'password: '
    elif msg == 1:
        # scp asks for passphrase
        prompt = 'Enter passphrase' + scpp.after.decode('utf-8')
    elif msg == 3:
        # scp cannot authenticate host. Connect anyway
        scpp.sendline('yes')
        msg = scpp.expect(['password:', 'passphrase', pexpect.EOF])
        if msg == 0:
            # scp asks for password
            prompt = scpp.before.decode('utf-8') + 'password: '
        elif msg == 1:
            # scp asks for passphrase
            prompt = 'Enter passphrase' + scpp.after.decode('utf-8')
    scpp.terminate(force=True)
    # Prompt the user for the password/passphrase
    password = getpass('\nThe latest frame will continuously be scp\'ed to '
                       + scp_liveframe[(scp_liveframe.find('@') + 1):] + '\n'
                       + prompt)
# Print out the password/passphrase.
# This will be captured in the bash 'args' variable.
print(password)
" "$@"`)
password=${args[0]}

# Compile or do cleanup from last compilation
if [ ${pure_python} -eq 0 ] ; then
    # Compile with Cython
    (cd ${this_dir} && make paramsfile=${params})
else
    # Remove compiled Cython modules
    (cd ${this_dir} && make clean_so >/dev/null)
    # Process the passed parameter file
    (cd ${this_dir} && make params.py paramsfile=${params})
fi

# Run!
if [ ${pure_python} -eq 0 ] ; then
    printf "\n\e[1m\e[93mRunning \e[3mN\e[0m\e[1m\e[93m-body\e[0m\n"
else
    printf "\n\e[1m\e[93mRunning \e[3mN\e[0m\e[1m\e[93m-body in pure Python mode\e[0m\n"
fi
echo "Entry point:   ${main}"
echo "Parameterfile: ${params}"
echo "Nr. of CPUs:   ${nprocs}"
cd ${this_dir}
${mpiexec} -n ${nprocs} ${python} ${main} "${password}"

# Run complete. Deactivate trap before exiting.
trap : 0
printf "\e[1m\e[92m\e[3mN\e[0m\e[1m\e[92m-body ran successfully\e[0m\n"

